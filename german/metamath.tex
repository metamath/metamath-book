% metamath.tex - Version of 15-Dec-2023
% If you change the date above, also change the "Printed date" below.
% SPDX-License-Identifier: CC0-1.0
%
%                              PUBLIC DOMAIN
%
% This file (specifically, the version of this file with the above date)
% has been released into the Public Domain per the
% Creative Commons CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
% https://creativecommons.org/publicdomain/zero/1.0/
%
% The public domain release applies worldwide.  In case this is not
% legally possible, the right is granted to use the work for any purpose,
% without any conditions, unless such conditions are required by law.
%
% Several short, attributed quotations from copyrighted works
% appear in this file under the "`fair use"' provision of Section 107 of
% the United States Copyright Act (Title 17 of the {\em United States
% Code}).  The public-domain status of this file is not applicable to
% those quotations.
%
% Norman Megill - email: nm(at)alum(dot)mit(dot)edu
%
% David A. Wheeler also donates his improvements to this file to the
% public domain per the CC0.  He works at the Institute for Defense Analyses
% (IDA), but IDA has agreed that this Metamath work is outside its "lane"
% and is not a work by IDA.  This was specifically confirmed by
% Margaret E. Myers (Division Director of the Information Technology
% and Systems Division) on 2019-05-24 and by Ben Lindorf (General Counsel)
% on 2019-05-22.
%
% Georg M. van der Vekens and Alexander W. van der Vekens also donate their
% German translation of this file to the public domain per the CC0.

% This file, 'metamath.tex', is self-contained with everything needed to
% generate the the PDF file 'metamath.pdf' (the _Metamath_ book) on
% standard LaTeX 2e installations.  The auxiliary files are embedded with
% "filecontents" commands.  To generate metamath.pdf file, run these
% commands under Linux or Cygwin in the directory that contains
% 'metamath.tex':
%
%   rm -f realref.sty metamath.bib
%   touch metamath.ind
%   pdflatex metamath
%   pdflatex metamath
%   bibtex metamath
%   makeindex metamath
%   pdflatex metamath
%   pdflatex metamath
%
% The warnings that occur in the initial runs of pdflatex can be ignored.
% For the final run,
%
%   egrep -i 'error|warn' metamath.log
%
% should show exactly these 5 warnings:
%
%   LaTeX Warning: File `realref.sty' already exists on the system.
%   LaTeX Warning: File `metamath.bib' already exists on the system.
%   LaTeX Font Warning: Font shape `OMS/cmtt/m/n' undefined
%   LaTeX Font Warning: Font shape `OMS/cmtt/bx/n' undefined
%   LaTeX Font Warning: Some font shapes were not available, defaults
%       substituted.
%
% Search for "Uncomment" below if you want to suppress hyperlink boxes
% in the PDF output file
%
% TYPOGRAPHICAL NOTES:
% * It is customary to use an en dash (--) to "connect" names of different
%   people (and to denote ranges), and use a hyphen (-) for a
%   single compound name. Examples of connected multiple people are
%   Zermelo--Fraenkel, Schr\"{o}der--Bernstein, Tarski--Grothendieck,
%   Hewlett--Packard, and Backus--Naur.  Examples of a single person with
%   a compound name include Levi-Civita, Mittag-Leffler, and Burali-Forti.
% * Use non-breaking spaces after page abbreviations, e.g.,
%   p.~\pageref{note2002}.
%
% --------------------------- Start of realref.sty -----------------------------
\begin{filecontents}{realref.sty}
% Save the following as realref.sty.
% You can then use it with \usepackage{realref}
%
% This has \pageref jumping to the page on which the ref appears,
% \ref jumping to the point of the anchor, and \sectionref
% jumping to the start of section.
%
% Author:  Anthony Williams
%          Software Engineer
%          Nortel Networks Optical Components Ltd
% Date:    9 Nov 2001 (posted to comp.text.tex)
%
% The following declaration was made by Anthony Williams on
% 24 Jul 2006 (private email to Norman Megill):
%
%   "`I hereby donate the code for realref.sty posted on the
%   comp.text.tex newsgroup on 9th November 2001, accessible from
%   http://groups.google.com/group/comp.text.tex/msg/5a0e1cc13ea7fbb2
%   to the public domain."'
%
\ProvidesPackage{realref}
\RequirePackage[plainpages=false,pdfpagelabels=true]{hyperref}
\def\realref@anchorname{}
\AtBeginDocument{%
% ensure every label is a possible hyperlink target
\let\realref@oldrefstepcounter\refstepcounter%
\DeclareRobustCommand{\refstepcounter}[1]{\realref@oldrefstepcounter{#1}
\edef\realref@anchorname{\string #1.\@currentlabel}%
}%
\let\realref@oldlabel\label%
\DeclareRobustCommand{\label}[1]{\realref@oldlabel{#1}\hypertarget{#1}{}%
\@bsphack\protected@write\@auxout{}{%
    \string\expandafter\gdef\protect\csname
    page@num.#1\string\endcsname{\thepage}%
    \string\expandafter\gdef\protect\csname
    ref@num.#1\string\endcsname{\@currentlabel}%
    \string\expandafter\gdef\protect\csname
    sectionref@name.#1\string\endcsname{\realref@anchorname}%
}\@esphack}%
\DeclareRobustCommand\pageref[1]{{\edef\a{\csname
            page@num.#1\endcsname}\expandafter\hyperlink{page.\a}{\a}}}%
\DeclareRobustCommand\ref[1]{{\edef\a{\csname
            ref@num.#1\endcsname}\hyperlink{#1}{\a}}}%
\DeclareRobustCommand\sectionref[1]{{\edef\a{\csname
            ref@num.#1\endcsname}\edef\b{\csname
            sectionref@name.#1\endcsname}\hyperlink{\b}{\a}}}%
}
\end{filecontents}
% ---------------------------- End of realref.sty ------------------------------

% --------------------------- Start of metamath.bib -----------------------------
\begin{filecontents}{metamath.bib}
@book{Albers, editor = "Donald J. Albers and G. L. Alexanderson",
  title = "Mathematical People",
  publisher = "Contemporary Books, Inc.",
  address = "Chicago",
  note = "[QA28.M37]",
  year = 1985 }
@book{Anderson, author = "Alan Ross Anderson and Nuel D. Belnap",
  title = "Entailment",
  publisher = "Princeton University Press",
  address = "Princeton",
  volume = 1,
  note = "[QA9.A634 1975 v.1]",
  year = 1975}
@book{Barrow, author = "John D. Barrow",
  title = "Theories of Everything:  The Quest for Ultimate Explanation",
  publisher = "Oxford University Press",
  address = "Oxford",
  note = "[Q175.B225]",
  year = 1991 }
@book{Behnke,
  editor = "H. Behnke and F. Backmann and K. Fladt and W. S{\"{u}}ss",
  title = "Fundamentals of Mathematics",
  volume = "I",
  publisher = "The MIT Press",
  address = "Cambridge, Massachusetts",
  note = "[QA37.2.B413]",
  year = 1974 }
@book{Bell, author = "J. L. Bell and M. Machover",
  title = "A Course in Mathematical Logic",
  publisher = "North-Holland",
  address = "Amsterdam",
  note = "[QA9.B3953]",
  year = 1977 }
@inproceedings{Blass, author = "Andrea Blass",
  title = "The Interaction Between Category Theory and Set Theory",
  pages = "5--29",
  booktitle = "Mathematical Applications of Category Theory (Proceedings
     of the Special Session on Mathematical Applications
     Category Theory, 89th Annual Meeting of the American Mathematical
     Society, held in Denver, Colorado January 5--9, 1983)",
  editor = "John Walter Gray",
  year = 1983,
  note = "[QA169.A47 1983]",
  publisher = "American Mathematical Society",
  address = "Providence, Rhode Island"}
@proceedings{Bledsoe, editor = "W. W. Bledsoe and D. W. Loveland",
  title = "Automated Theorem Proving:  After 25 Years (Proceedings
     of the Special Session on Automatic Theorem Proving,
     89th Annual Meeting of the American Mathematical
     Society, held in Denver, Colorado January 5--9, 1983)",
  year = 1983,
  note = "[QA76.9.A96.S64 1983]",
  publisher = "American Mathematical Society",
  address = "Providence, Rhode Island" }
@book{Boolos, author = "George S. Boolos and Richard C. Jeffrey",
  title = "Computability and Log\-ic",
  publisher = "Cambridge University Press",
  edition = "third",
  address = "Cambridge",
  note = "[QA9.59.B66 1989]",
  year = 1989 }
@book{Campbell, author = "John Campbell",
  title = "Programmer's Progress",
  publisher = "White Star Software",
  address = "Box 51623, Palo Alto, CA 94303",
  year = 1991 }
@article{DBLP:journals/corr/Carneiro14,
  author    = {Mario Carneiro},
  title     = {Conversion of {HOL} Light proofs into Metamath},
  journal   = {CoRR},
  volume    = {abs/1412.8091},
  year      = {2014},
  url       = {http://arxiv.org/abs/1412.8091},
  archivePrefix = {arXiv},
  eprint    = {1412.8091},
  timestamp = {Mon, 13 Aug 2018 16:47:05 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/corr/Carneiro14},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@article{CarneiroND,
  author    = {Mario Carneiro},
  title     = {Natural Deductions in the Metamath Proof Language},
  url       = {http://us.metamath.org/ocat/natded.pdf},
  year      = 2014
}
@inproceedings{Chou, author = "Shang-Ching Chou",
  title = "Proving Elementary Geometry Theorems Using {W}u's Algorithm",
  pages = "243--286",
  booktitle = "Automated Theorem Proving:  After 25 Years (Proceedings
     of the Special Session on Automatic Theorem Proving,
     89th Annual Meeting of the American Mathematical
     Society, held in Denver, Colorado January 5--9, 1983)",
  editor = "W. W. Bledsoe and D. W. Loveland",
  year = 1983,
  note = "[QA76.9.A96.S64 1983]",
  publisher = "American Mathematical Society",
  address = "Providence, Rhode Island" }
@book{Clemente, author = "Daniel Clemente Laboreo",
  title = "Introduction to natural deduction",
  year = 2014,
  url = "http://www.danielclemente.com/logica/dn.en.pdf" }
@incollection{Courant, author = "Richard Courant and Herbert Robbins",
  title = "Topology",
  pages = "573--590",
  booktitle = "The World of Mathematics, Volume One",
  editor = "James R. Newman",
  publisher = "Simon and Schuster",
  address = "New York",
  note = "[QA3.W67 1988]",
  year = 1956 }
@book{Curry, author = "Haskell B. Curry",
  title = "Foundations of Mathematical Logic",
  publisher = "Dover Publications, Inc.",
  address = "New York",
  note = "[QA9.C976 1977]",
  year = 1977 }
@book{Davis, author = "Philip J. Davis and Reuben Hersh",
  title = "The Mathematical Experience",
  publisher = "Birkh{\"{a}}user Boston",
  address = "Boston",
  note = "[QA8.4.D37 1982]",
  year = 1981 }
@incollection{deMillo,
  author = "Richard de Millo and Richard Lipton and Alan Perlis",
  title = "Social Processes and Proofs of Theorems and Programs",
  pages = "267--285",
  booktitle = "New Directions in the Philosophy of Mathematics",
  editor = "Thomas Tymoczko",
  publisher = "Birkh{\"{a}}user Boston, Inc.",
  address = "Boston",
  note = "[QA8.6.N48 1986]",
  year = 1986 }
@book{Edwards, author = "Robert E. Edwards",
  title = "A Formal Background to Mathematics",
  publisher = "Springer-Verlag",
  address = "New York",
  note = "[QA37.2.E38 v.1a]",
  year = 1979 }
@book{Enderton, author = "Herbert B. Enderton",
  title = "Elements of Set Theory",
  publisher = "Academic Press, Inc.",
  address = "San Diego",
  note = "[QA248.E5]",
  year = 1977 }
@book{Goodstein, author = "R. L. Goodstein",
  title = "Development of Mathematical Logic",
  publisher = "Springer-Verlag New York Inc.",
  address = "New York",
  note = "[QA9.G6554]",
  year = 1971 }
@book{Guillen, author = "Michael Guillen",
  title = "Bridges to Infinity",
  publisher = "Jeremy P. Tarcher, Inc.",
  address = "Los Angeles",
  note = "[QA93.G8]",
  year = 1983 }
@book{Hamilton, author = "Alan G. Hamilton",
  title = "Logic for Mathematicians",
  edition = "revised",
  publisher = "Cambridge University Press",
  address = "Cambridge",
  note = "[QA9.H298]",
  year = 1988 }
@unpublished{Harrison, author = "John Robert Harrison",
  title = "Metatheory and Reflection in Theorem Proving:
    A Survey and Critique",
  note = "Technical Report
    CRC-053.
    SRI Cambridge,
    Millers Yard, Cambridge, UK,
    1995.
    Available on the Web as
{\verb+http:+}\-{\verb+//www.cl.cam.ac.uk/users/jrh/papers/reflect.html+}"}
@TECHREPORT{Harrison-thesis,
        author          = "John Robert Harrison",
        title           = "Theorem Proving with the Real Numbers",
        institution   = "University of Cambridge Computer
                         Lab\-o\-ra\-to\-ry",
        address         = "New Museums Site, Pembroke Street, Cambridge,
                           CB2 3QG, UK",
        year            = 1996,
        number          = 408,
        type            = "Technical Report",
        note            = "Author's PhD thesis,
   available on the Web at
{\verb+http:+}\-{\verb+//www.cl.cam.ac.uk+}\-{\verb+/users+}\-{\verb+/jrh+}%
\-{\verb+/papers+}\-{\verb+/thesis.html+}"}
@book{Herrlich, author = "Horst Herrlich and George E. Strecker",
  title = "Category Theory:  An Introduction",
  publisher = "Allyn and Bacon Inc.",
  address = "Boston",
  note = "[QA169.H567]",
  year = 1973 }
@article{Hindley, author = "J. Roger Hindley and David Meredith",
  title = "Principal Type-Schemes and Condensed Detachment",
  journal = "The Journal of Symbolic Logic",
  volume = 55,
  year = 1990,
  note = "[QA.J87]",
  pages = "90--105" }
@book{Hofstadter, author = "Douglas R. Hofstadter",
  title = "G{\"{o}}del, Escher, Bach",
  publisher = "Basic Books, Inc.",
  address = "New York",
  note = "[QA9.H63 1980]",
  year = 1979 }
@article{Indrzejczak, author= "Andrzej Indrzejczak",
  title = "Natural Deduction, Hybrid Systems and Modal Logic",
  journal = "Trends in Logic",
  volume = 30,
  publisher = "Springer",
  year = 2010 }
@article{Kalish, author = "D. Kalish and R. Montague",
  title = "On {T}arski's Formalization of Predicate Logic with Identity",
  journal = "Archiv f{\"{u}}r Mathematische Logik und Grundlagenfor\-schung",
  volume = 7,
  year = 1965,
  note = "[QA.A673]",
  pages = "81--101" }
@article{Kalman, author = "J. A. Kalman",
  title = "Condensed Detachment as a Rule of Inference",
  journal = "Studia Logica",
  volume = 42,
  number = 4,
  year = 1983,
  note = "[B18.P6.S933]",
  pages = "443-451" }
@book{Kline, author = "Morris Kline",
  title = "Mathematical Thought from Ancient to Modern Times",
  publisher = "Oxford University Press",
  address = "New York",
  note = "[QA21.K516 1990 v.3]",
  year = 1972 }
@book{Klinel, author = "Morris Kline",
  title = "Mathematics, The Loss of Certainty",
  publisher = "Oxford University Press",
  address = "New York",
  note = "[QA21.K525]",
  year = 1980 }
@book{Kramer, author = "Edna E. Kramer",
  title = "The Nature and Growth of Modern Mathematics",
  publisher = "Princeton University Press",
  address = "Princeton, New Jersey",
  note = "[QA93.K89 1981]",
  year = 1981 }
@article{Knill, author = "Oliver Knill",
  title = "Some Fundamental Theorems in Mathematics",
  year = "2018",
  url = "https://arxiv.org/abs/1807.08416" }
@book{Landau, author = "Edmund Landau",
  title = "Foundations of Analysis",
  publisher = "Chelsea Publishing Company",
  address = "New York",
  edition = "second",
  note = "[QA241.L2541 1960]",
  year = 1960 }
@article{Leblanc, author = "Hugues Leblanc",
  title = "On {M}eyer and {L}ambert's Quantificational Calculus {FQ}",
  journal = "The Journal of Symbolic Logic",
  volume = 33,
  year = 1968,
  note = "[QA.J87]",
  pages = "275--280" }
@article{Lejewski, author = "Czeslaw Lejewski",
  title = "On Implicational Definitions",
  journal = "Studia Logica",
  volume = 8,
  year = 1958,
  note = "[B18.P6.S933]",
  pages = "189--208" }
@book{Levy, author = "Azriel Levy",
  title = "Basic Set Theory",
  publisher = "Dover Publications",
  address = "Mineola, NY",
  year = "2002"
}
@book{Margaris, author = "Angelo Margaris",
  title = "First Order Mathematical Logic",
  publisher = "Blaisdell Publishing Company",
  address = "Waltham, Massachusetts",
  note = "[QA9.M327]",
  year = 1967}
@book{Manin, author = "Yu I. Manin",
  title = "A Course in Mathematical Logic",
  publisher = "Springer-Verlag",
  address = "New York",
  note = "[QA9.M29613]",
  year = "1977" }
@article{Mathias, author = "Adrian R. D. Mathias",
  title = "A Term of Length 4,523,659,424,929",
  journal = "Synthese",
  volume = 133,
  year = 2002,
  note = "[Q.S993]",
  pages = "75--86" }
@article{Megill, author = "Norman D. Megill",
  title = "A Finitely Axiomatized Formalization of Predicate Calculus
     with Equality",
  journal = "Notre Dame Journal of Formal Logic",
  volume = 36,
  year = 1995,
  note = "[QA.N914]",
  pages = "435--453" }
@unpublished{Megillc, author = "Norman D. Megill",
  title = "A Shorter Equivalent of the Axiom of Choice",
  month = "June",
  note = "Unpublished",
  year = 1991 }
@article{MegillBunder, author = "Norman D. Megill and Martin W.
    Bunder",
  title = "Weaker {D}-Complete Logics",
  journal = "Journal of the IGPL",
  volume = 4,
  year = 1996,
  pages = "215--225",
  note = "Available on the Web at
{\verb+http:+}\-{\verb+//www.mpi-sb.mpg.de+}\-{\verb+/igpl+}%
\-{\verb+/Journal+}\-{\verb+/V4-2+}\-{\verb+/#Megill+}"}
}
@book{Mendelson, author = "Elliott Mendelson",
  title = "Introduction to Mathematical Logic",
  edition = "second",
  publisher = "D. Van Nostrand Company, Inc.",
  address = "New York",
  note = "[QA9.M537 1979]",
  year = 1979 }
@article{Meredith, author = "David Meredith",
  title = "In Memoriam {C}arew {A}rthur {M}eredith (1904-1976)",
  journal = "Notre Dame Journal of Formal Logic",
  volume = 18,
  year = 1977,
  note = "[QA.N914]",
  pages = "513--516" }
@article{CAMeredith, author = "C. A. Meredith",
  title = "Single Axioms for the Systems ({C},{N}), ({C},{O}) and ({A},{N})
      of the Two-Valued Propositional Calculus",
  journal = "The Journal of Computing Systems",
  volume = 3,
  year = 1953,
  pages = "155--164" }
@article{Monk, author = "J. Donald Monk",
  title = "Provability With Finitely Many Variables",
  journal = "The Journal of Symbolic Logic",
  volume = 27,
  year = 1971,
  note = "[QA.J87]",
  pages = "353--358" }
@article{Monks, author = "J. Donald Monk",
  title = "Substitutionless Predicate Logic With Identity",
  journal = "Archiv f{\"{u}}r Mathematische Logik und Grundlagenfor\-schung",
  volume = 7,
  year = 1965,
  pages = "103--121" }
  %% Took out this from above to prevent LaTeX underfull warning:
  % note = "[QA.A673]",
@book{Moore, author = "A. W. Moore",
  title = "The Infinite",
  publisher = "Routledge",
  address = "New York",
  note = "[BD411.M59]",
  year = 1989}
@book{Munkres, author = "James R. Munkres",
  title = "Topology: A First Course",
  publisher = "Prentice-Hall, Inc.",
  address = "Englewood Cliffs, New Jersey",
  note = "[QA611.M82]",
  year = 1975}
@article{Nemesszeghy, author = "E. Z. Nemesszeghy and E. A. Nemesszeghy",
  title = "On Strongly Creative Definitions:  A Reply to {V}. {F}. {R}ickey",
  journal = "Logique et Analyse (N.\ S.)",
  year = 1977,
  volume = 20,
  note = "[BC.L832]",
  pages = "111--115" }
@unpublished{Nemeti, author = "N{\'{e}}meti, I.",
  title = "Algebraizations of Quantifier Logics, an Overview",
  note = "Version 11.4, preprint, Mathematical Institute, Budapest,
    1994.  A shortened version without proofs appeared in
    {\glqq }Algebraizations of quantifier logics, an introductory overview{\grqq },
    {\em Studia Logica}, 50:485--569, 1991 [B18.P6.S933]"}
@article{Pavicic, author = "M. Pavi{\v{c}}i{\'{c}}",
  title = "A New Axiomatization of Unified Quantum Logic",
  journal = "International Journal of Theoretical Physics",
  year = 1992,
  volume = 31,
  note = "[QC.I626]",
  pages = "1753 --1766" }
@book{Penrose, author = "Roger Penrose",
  title = "The Emperor's New Mind",
  publisher = "Oxford University Press",
  address = "New York",
  note = "[Q335.P415]",
  year = 1989 }
@book{PetersonI, author = "Ivars Peterson",
  title = "The Mathematical Tourist",
  publisher = "W. H. Freeman and Company",
  address = "New York",
  note = "[QA93.P475]",
  year = 1988 }
@article{Peterson, author = "Jeremy George Peterson",
  title = "An automatic theorem prover for substitution and detachment systems",
  journal = "Notre Dame Journal of Formal Logic",
  volume = 19,
  year = 1978,
  note = "[QA.N914]",
  pages = "119--122" }
@book{Quine, author = "Willard Van Orman Quine",
  title = "Set Theory and Its Logic",
  edition = "revised",
  publisher = "The Belknap Press of Harvard University Press",
  address = "Cambridge, Massachusetts",
  note = "[QA248.Q7 1969]",
  year = 1969 }
@article{Robinson, author = "J. A. Robinson",
  title = "A Machine-Oriented Logic Based on the Resolution Principle",
  journal = "Journal of the Association for Computing Machinery",
  year = 1965,
  volume = 12,
  pages = "23--41" }
@article{RobinsonT, author = "T. Thacher Robinson",
  title = "Independence of Two Nice Sets of Axioms for the Propositional
    Calculus",
  journal = "The Journal of Symbolic Logic",
  volume = 33,
  year = 1968,
  note = "[QA.J87]",
  pages = "265--270" }
@book{Rucker, author = "Rudy Rucker",
  title = "Infinity and the Mind:  The Science and Philosophy of the
    Infinite",
  publisher = "Bantam Books, Inc.",
  address = "New York",
  note = "[QA9.R79 1982]",
  year = 1982 }
@book{Russell, author = "Bertrand Russell",
  title = "Mysticism and Logic, and Other Essays",
  publisher = "Barnes \& Noble Books",
  address = "Totowa, New Jersey",
  note = "[B1649.R963.M9 1981]",
  year = 1981 }
@article{Russell2, author = "Bertrand Russell",
  title = "Recent Work on the Principles of Mathematics",
  journal = "International Monthly",
  volume = 4,
  year = 1901,
  pages = "84"}
@article{Schmidt, author = "Eric Schmidt",
  title = "Reductions in Norman Megill's axiom system for complex numbers",
  url = "http://us.metamath.org/downloads/schmidt-cnaxioms.pdf",
  year = "2012" }
@book{Shoenfield, author = "Joseph R. Shoenfield",
  title = "Mathematical Logic",
  publisher = "Addison-Wesley Publishing Company, Inc.",
  address = "Reading, Massachusetts",
  year = 1967,
  note = "[QA9.S52]" }
@book{Smullyan, author = "Raymond M. Smullyan",
  title = "Theory of Formal Systems",
  publisher = "Princeton University Press",
  address = "Princeton, New Jersey",
  year = 1961,
  note = "[QA248.5.S55]" }
@book{Solow, author = "Daniel Solow",
  title = "How to Read and Do Proofs:  An Introduction to Mathematical
    Thought Process",
  publisher = "John Wiley \& Sons",
  address = "New York",
  year = 1982,
  note = "[QA9.S577]" }
@book{Stark, author = "Harold M. Stark",
  title = "An Introduction to Number Theory",
  publisher = "Markham Publishing Company",
  address = "Chicago",
  note = "[QA241.S72 1978]",
  year = 1970 }
@article{Swart, author = "E. R. Swart",
  title = "The Philosophical Implications of the Four-Color Problem",
  journal = "American Mathematical Monthly",
  year = 1980,
  volume = 87,
  month = "November",
  note = "[QA.A5125]",
  pages = "697--707" }
@book{Szpiro, author = "George G. Szpiro",
  title = "Poincar{\'{e}}'s Prize: The Hundred-Year Quest to Solve One
    of Math's Greatest Puzzles",
  publisher = "Penguin Books Ltd",
  address = "London",
  note = "[QA43.S985 2007]",
  year = 2007}
@book{Takeuti, author = "Gaisi Takeuti and Wilson M. Zaring",
  title = "Introduction to Axiomatic Set Theory",
  edition = "second",
  publisher = "Springer-Verlag New York Inc.",
  address = "New York",
  note = "[QA248.T136 1982]",
  year = 1982}
@inproceedings{Tarski, author = "Alfred Tarski",
  title = "What is Elementary Geometry",
  pages = "16--29",
  booktitle = "The Axiomatic Method, with Special Reference to Geometry and
     Physics (Proceedings of an International Symposium held at the University
     of California, Berkeley, December 26, 1957 --- January 4, 1958)",
  editor = "Leon Henkin and Patrick Suppes and Alfred Tarski",
  year = 1959,
  publisher = "North-Holland Publishing Company",
  address = "Amsterdam"}
@article{Tarski1965, author = "Alfred Tarski",
  title = "A Simplified Formalization of Predicate Logic with Identity",
  journal = "Archiv f{\"{u}}r Mathematische Logik und Grundlagenforschung",
  volume = 7,
  year = 1965,
  note = "[QA.A673]",
  pages = "61--79" }
@book{Tymoczko,
  title = "New Directions in the Philosophy of Mathematics",
  editor = "Thomas Tymoczko",
  publisher = "Birkh{\"{a}}user Boston, Inc.",
  address = "Boston",
  note = "[QA8.6.N48 1986]",
  year = 1986 }
@incollection{Wang,
  author = "Hao Wang",
  title = "Theory and Practice in Mathematics",
  pages = "129--152",
  booktitle = "New Directions in the Philosophy of Mathematics",
  editor = "Thomas Tymoczko",
  publisher = "Birkh{\"{a}}user Boston, Inc.",
  address = "Boston",
  note = "[QA8.6.N48 1986]",
  year = 1986 }
@manual{Webster,
  title = "Webster's New Collegiate Dictionary",
  organization = "G. \& C. Merriam Co.",
  address = "Springfield, Massachusetts",
  note = "[PE1628.W4M4 1977]",
  year = 1977 }
@manual{Whitehead, author = "Alfred North Whitehead",
  title = "An Introduction to Mathematics",
  year = 1911 }
@book{PM, author = "Alfred North Whitehead and Bertrand Russell",
  title = "Principia Mathematica",
  edition = "second",
  publisher = "Cambridge University Press",
  address = "Cambridge",
  year = "1927",
  note = "(3 vols.) [QA9.W592 1927]" }
@article{DBLP:journals/corr/Whalen16,
  author    = {Daniel Whalen},
  title     = {Holophrasm: a neural Automated Theorem Prover for higher-order logic},
  journal   = {CoRR},
  volume    = {abs/1608.02644},
  year      = {2016},
  url       = {http://arxiv.org/abs/1608.02644},
  archivePrefix = {arXiv},
  eprint    = {1608.02644},
  timestamp = {Mon, 13 Aug 2018 16:46:19 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/corr/Whalen16},
  bibsource = {dblp computer science bibliography, https://dblp.org} }
@article{Wiedijk-revisited,
  author = {Freek Wiedijk},
  title = {The QED Manifesto Revisited},
  year = {2007},
  url = {http://mizar.org/trybulec65/8.pdf} }
@book{Wolfram,
  author = "Stephen Wolfram",
  title = "Mathematica:  A System for Doing Mathematics by Computer",
  edition = "second",
  publisher = "Addison-Wesley Publishing Co.",
  address = "Redwood City, California",
  note = "[QA76.95.W65 1991]",
  year = 1991 }
@book{Wos, author = "Larry Wos and Ross Overbeek and Ewing Lusk and Jim Boyle",
  title = "Automated Reasoning:  Introduction and Applications",
  edition = "second",
  publisher = "McGraw-Hill, Inc.",
  address = "New York",
  note = "[QA76.9.A96.A93 1992]",
  year = 1992 }

%
%
%[1] Church, Alonzo, Introduction to Mathematical Logic,
% Volume 1, Princeton University Press, Princeton, N. J., 1956.
%
%[2] Cohen, Paul J., Set Theory and the Continuum Hypothesis,
% W. A. Benjamin, Inc., Reading, Mass., 1966.
%
%[3] Hamilton, Alan G., Logic for Mathematicians, Cambridge
% University Press,
% Cambridge, 1988.

%[6] Kleene, Stephen Cole, Introduction to Metamathematics, D.  Van
% Nostrand Company, Inc., Princeton (1952).

%[13] Tarski, Alfred, "A simplified formalization of predicate
% logic with identity," Archiv fur Mathematische Logik und
% Grundlagenforschung, vol. 7 (1965), pp. 61-79.

%[14] Tarski, Alfred and Steven Givant, A Formalization of Set
% Theory Without Variables, American Mathematical Society Colloquium
% Publications, vol. 41, American Mathematical Society,
% Providence, R. I., 1987.

%[15] Zeman, J. J., Modal Logic, Oxford University Press, Oxford, 1973.
\end{filecontents}
% --------------------------- End of metamath.bib -----------------------------


%Book: Metamath
%Author:  Norman Megill Email:  nm at alum.mit.edu
%Author:  David A. Wheeler Email:  dwheeler at dwheeler.com

% A book template example
% http://www.stsci.edu/ftp/software/tex/bookstuff/book.template

\documentclass[leqno]{book} % LaTeX 2e. 10pt. Use [leqno,12pt] for 12pt
% hyperref 2002/05/27 v6.72r  (couldn't get pagebackref to work)
\usepackage[plainpages=false,pdfpagelabels=true]{hyperref}

\usepackage{needspace}     % Enable control over page breaks
%% AV (nicht verfügbar, nicht benötigt?): \usepackage{breqn}         % automatic equation breaking
\usepackage{microtype}     % microtypography, reduces hyphenation

% Packages for flexible tables.  We need to be able to
% wrap text within a cell (with automatically-determined widths) AND
% split a table automatically across multiple pages.
% * "tabularx" wraps text in cells but only 1 page
% * "longtable" goes across pages but by itself is incompatible with tabularx
% * "ltxtable" combines longtable and tabularx, but table contents
%    must be in a separate file.
% * "ltablex" combines tabularx and longtable - must install specially
% * "booktabs" is recommended as a way to improve the look of tables,
%   but doesn't add these capabilities.
% * "tabu" much more capable and seems to be recommended. So use that.

\usepackage{makecell}      % Enable forced line splits within a table cell
\usepackage{longtable}     % Enable multi-page tables
\usepackage{tabu}          % Multi-page tables with wrapped text in a cell

% You can find more Tex packages using commands like:
% tlmgr search --file tabu.sty
% find /usr/share/texmf-dist/ -name '*tab*'
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Uncomment the next 3 lines to suppress boxes and colors on the hyperlinks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\hypersetup{
%colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black
%}
%
\usepackage{realref}

% Restarting page numbers: try?
%   \printglossary
%   \cleardoublepage
%   \pagenumbering{arabic}
%   \setcounter{page}{1}    ???needed
%   \include{chap1}

% not used:
% \def\R2Lurl#1#2{\mbox{\href{#1}\texttt{#2}}}

\usepackage{amssymb}

% Version 1 of book: margins: t=.4, b=.2, ll=.4, rr=.55
% \usepackage{anysize}
% % \papersize{<height>}{<width>}
% % \marginsize{<left>}{<right>}{<top>}{<bottom>}
% \papersize{9in}{6in}
% % l/r 0.6124-0.6170 works t/b 0.2418-0.3411 = 192pp. 0.2926-03118=exact
% \marginsize{0.7147in}{0.5147in}{0.4012in}{0.2012in}

\usepackage{anysize}
% \papersize{<height>}{<width>}
% \marginsize{<left>}{<right>}{<top>}{<bottom>}
\papersize{9in}{6in}
% l/r 0.85in&0.6431-0.6539 works t/b ?-?
%\marginsize{0.85in}{0.6485in}{0.55in}{0.35in}
\marginsize{0.8in}{0.65in}{0.5in}{0.3in}

% \usepackage[papersize={3.6in,4.8in},hmargin=0.1in,vmargin={0.1in,0.1in}]{geometry}  % page geometry
\usepackage{special-settings}

\usepackage{ngerman}
%\addto
\captionsngerman{% Replace "ngerman" with the language you use
%not needed
%  \renewcommand{\contentsname}
%    {Inhalt}
% \renewcommand{\chaptername}
%   {Kapitel}
% \renewcommand{\appendixname}
%   {Anhang}
%  \renewcommand{\bibliographyname}
%    {Bibliographie}
% \renewcommand{\indexname}
%   {Register}
}

\raggedbottom
\makeindex

\begin{document}
% Discourage page widows and orphans:
\clubpenalty=300
\widowpenalty=300

%%%%%%% load in AMS fonts %%%%%%% % LaTeX 2.09 - obsolete in LaTeX 2e
%\input{amssym.def}
%\input{amssym.tex}
%\input{c:/texmf/tex/plain/amsfonts/amssym.def}
%\input{c:/texmf/tex/plain/amsfonts/amssym.tex}

\bibliographystyle{plain}
\pagenumbering{roman}
\pagestyle{headings}

\thispagestyle{empty}

\hfill
\vfill

\begin{center}
{\LARGE\bf Metamath} \\
\vspace{1ex}
{\large Eine Computersprache für mathematische Beweise} \\
\vspace{7ex}
{\large Norman Megill} \\
\vspace{7ex}
mit umfangreichen Überarbeitungen durch \\
\vspace{1ex}
{\large David A. Wheeler} \\
\vspace{7ex}
Deutsche Übersetzung von \\
\vspace{1ex}
{\large Georg M. van der Vekens und Alexander W. van der Vekens} \\
\vspace{7ex}
% Printed date. If changing the date below, also fix the date at the beginning.
15.12.2023
\end{center}

\vfill
\hfill

\newpage
\thispagestyle{empty}

\hfill
\vfill

\begin{center}
$\sim$\ {\sc Public Domain}\ $\sim$

\vspace{2ex}
Dieses Buch (einschließlich seiner späteren Überarbeitungen und Übersetzungen) wurde von Norman Megill gemäß der 'Creative Commons CC0 1.0 Universal (CC0 1.0) Public Domain Dedication' in die Public Domain veröffentlicht. 
David A. Wheeler, Georg M. van der Vekens und Alexander W. van der Vekens haben selbiges getan. Diese Public Domain Veröffentlichung gilt weltweit. Für den Fall, dass dies rechtlich nicht möglich ist, wird das Recht eingeräumt, das Werk für jeden Zweck zu nutzen, ohne irgendwelche Bedingungen, es sei denn, solche Bedingungen sind gesetzlich vorgeschrieben.
Siehe \url{https://creativecommons.org/publicdomain/zero/1.0/}.

\vspace{3ex}
In diesem Buch erscheinen mehrere kurze, gekennzeichnete Zitate aus urheberrechtlich geschützten Werken gemäß der "`fair use"'-Bestimmung von Abschnitt 107 des United States Copyright Act (Titel 17 des {\em United States Code}). Der Status der Public Domain ist auf diese Zitate nicht anwendbar.

\vspace{3ex}
Alle in diesem Buch verwendeten Warenzeichen sind Eigentum der jeweiligen Inhaber.

% QA76.9.L63.M??

% \vspace{1ex}
%
% \vspace{1ex}
% {\small Permission is granted to make and distribute verbatim copies of this
% book
% provided the copyright notice and this
% permission notice are preserved on all copies.}
%
% \vspace{1ex}
% {\small Permission is granted to copy and distribute modified versions of this
% book under the conditions for verbatim copying, provided that the
% entire
% resulting derived work is distributed under the terms of a permission
% notice
% identical to this one.}
%
% \vspace{1ex}
% {\small Permission is granted to copy and distribute translations of this
% book into another language, under the above conditions for modified
% versions,
% except that this permission notice may be stated in a translation
% approved by the
% author.}
%
% \vspace{1ex}
% %{\small   For a copy of the \LaTeX\ source files for this book, contact
% %the author.} \\
% \ \\
% \ \\

\vspace{7ex}
% ISBN: 1-4116-3724-0 \\
% ISBN: 978-1-4116-3724-5 \\
ISBN: 978-0-359-70223-7 \\
{\ } \\
Lulu Press \\
Morrisville, North Carolina\\
USA


\hfill
\vfill

Norman Megill\\ 93 Bridge St., Lexington, MA 02421 \\
E-Mail Adresse: \texttt{nm{\char`\@}alum.mit.edu} \\
\vspace{7ex}
David A. Wheeler \\
E-Mail Adresse: \texttt{dwheeler{\char`\@}dwheeler.com} \\
% See notes added at end of Preface for revision history. \\
% For current information on the Metamath software see \\
\vspace{7ex}
\url{http://metamath.org}
\end{center}

\hfill
\vfill

{\parindent0pt%
\footnotesize{%
Titelseite: Aleph Null ($\aleph_0$) ist das Symbol für die erste unendliche Kardinalzahl, entdeckt von Georg Cantor im Jahr 1873. Wir verwenden ein rotes Aleph Null (mit dunklem Umriss und goldenem Schimmer) als das Logo für Metamath.
Urheber: Norman Megill (1994) und Giovanni Mascellani (2019),
Public Domain.%
\index{aleph null}%
\index{Metamath!Logo}\index{Cantor, Georg}\index{Mascellani, Giovanni}}}

\newpage
\thispagestyle{empty}

\hfill
\vfill

\begin{center}
{\it Diese Übersetzung ist Norman Dwight Megill,\\
	 dem Erfinder von Metamath, gewidmet.}
\end{center}

\vfill
\hfill

\newpage

\tableofcontents
%\listoftables

\chapter*{Vorwort}
\markboth{Vorwort}{Vorwort}
\addcontentsline{toc}{section}{Vorwort}


% (For current information, see the notes added at the
% end of this preface on p.~\pageref{note2002}.)

\subsubsection{Übersicht}

Metamath\index{Metamath} ist eine Computersprache und ein zugehöriges Computerprogramm zur Archivierung, Verifikation und Untersuchung mathematischer Beweise auf einer sehr detaillierten Ebene. Die Metamath-Sprache enthält keine Mathematik an sich, sondern betrachtet alle mathematischen Aussagen als reine Folgen von Symbolen. Bei der Nutzung von Metamath werden bestimmte, spezielle Symbolsequenzen (Axiome) vorgegeben, die Metamath sagen, welche Schlussfolgerungsregeln erlaubt sind. Metamath ist nicht auf ein bestimmtes mathematisches Gebiet beschränkt.  Die Metamath-Sprache ist einfach und robust, sie besitzt so gut wie keine fest verdrahtete Syntax. 
Wir\footnote{Sofern nicht anders angegeben, beziehen sich die Worte "`Ich"', "`mich"' und "`mein"' auf Norman Megill\index{Megill, Norman}, während "`wir"', "`uns"' und "`unser"' auf Norman Megill und David A. Wheeler\index{Wheeler, David A.} beziehen.}
glauben, dass sie vielleicht den einfachst möglichen Ansatz bietet, mit dem im Wesentlichen die gesamte Mathematik mit absoluter Strenge ausgedrückt werden kann.

% index test
%\newcommand{\nn}[1]{#1n}
%\index{aaa@bbb}
%\index{abc!def}
%\index{abd|see{qqq}}
%\index{abe|nn}
%\index{abf|emph}
%\index{abg|(}
%\index{abg|)}

Mit der Metamath-Sprache können formale oder mathematische Systeme\index{formales System}\footnote{Ein formales oder mathematisches System besteht aus einer Sammlung von Symbolen (solche wie $2$, $4$, $+$ und $=$), Syntaxregeln, die beschreiben, wie Symbole kombiniert werden können um einen gültigen Ausdruck zu formen (solch ein Ausdruck wird auch 'wohlgeformte Formel', engl. 'well formed formula', genannt, oder kurz {\em wff}, gesprochen "`whiff"'), einige wffs (Axiome genannt), mit denen begonnen wird, und Schlussfolgerungsregeln, die beschreiben, wie Theoreme aus den Axiomen abgeleitet (bewiesen) werden können. Ein Theorem ist eine mathematische Tatsache so wie $2+2=4$. Streng genommen muss selbst solch eine offensichtliche Tatsache anhand von Axiomen bewiesen werden, um von einem Mathematiker formal akzeptiert werden zu können.}\index{Theorem}\index{Axiom}\index{Regel}\index{wohlgeformte Formel (wff)} aufgebaut werden, die Schlussfolgerungen aus Axiomen umfassen.  Obwohl zusammen mit Metamath eine Datenbasis bereitgestellt wird, die einen empfohlenen Satz von Axiomen für die Standardmathematik enthält, könnte man nach Belieben eigene Symbole, Syntax, Axiome, Regeln und Definitionen vorgeben.

Der Name "`Metamath"' wurde gewählt um anzudeuten, dass die Sprache ein Mittel zur {\em Beschreibung} der Mathematik und nicht die Mathematik {\em selbst} ist. Tatsächlich ist in gewissem Sinne jede mathematische Sprache metamathematisch. Auf Papier geschriebene oder in einem Computer gespeicherte Symbole sind nicht die Mathematik selbst, sondern vielmehr eine Möglichkeit, mathematische Gegebenheiten und Zusammenhänge auszudrücken. Beispielsweise sind "`7"' und "`VII"' Symbole um die Zahl sieben in arabischen und römischen Ziffern zu bezeichnen; keines von beiden Symbolen {\em ist} die Zahl sieben.

Wenn Sie in der Lage sind, Computerprogramme zu verstehen und zu schreiben, sollten Sie in der Lage sein, abstrakte Mathematik mit Hilfe von Metamath nachzuvollziehen. In Verbindung mit Standard-Lehrbüchern kann Metamath Sie Schritt für Schritt zu einem Verständnis der abstrakten Mathematik von einem sehr rigorosen Standpunkt aus führen, auch wenn Sie keine formale Ausbildung in abstrakter Mathematik haben. Sobald Sie die grundlegenden Konzepte verstanden haben, bietet Metamath Ihnen durch die Verwendung einer einzigen, konsistenten Notation zur Darstellung von Beweisen die Möglichkeit, allen Beweisschritten sofort zu folgen und im Detail zu verstehen, und das selbst in Ihnen völlig unbekannten Bereichen.

Natürlich führt die bloße Fähigkeit einem Beweis zu folgen nicht unbedingt zu einer intuitive Vertrautheit mit der Mathematik. Das Auswendiglernen der Schachregeln gibt Ihnen nicht die Fähigkeit, die Spielweise eines Meisters zu würdigen, und zu wissen wie die Noten einer Partitur den Klaviertasten zugeordnet sind, gibt Ihnen nicht die Fähigkeit, in Ihrem Kopf zu hören, wie sich diese anhören würde. Aber jede dieser Tätigkeiten kann ein erster Schritt für den Einstieg in ein neues Themengebiet sein.

Metamath erlaubt es Ihnen, Beweise so zu erforschen, dass Sie den Beweis jedes Theorems, auf das in einem Beweisschritt verwiesen wird, wiederum im Detail betrachten können, und das immer weiter bis hin zu den zugrunde liegenden Axiomen der Logik und der Mengenlehre (im Falle der mitgelieferten Datenbasis für die Mengenlehre). Während Metamath nicht das nur durch Übung und harte Arbeit zu erlangende Verständnis der Mathematik auf höherer Ebene ersetzen kann, so hilft die Möglichkeit zu sehen, wie Lücken in einem Beweis geschlossen werden, den Lernprozess zu beschleunigen und Ihnen Zeit zu sparen, wenn Sie nicht selbst bei einem Beweis weiterkommen.

Die Metamath-Sprache zerlegt einen mathematischen Beweis in seine kleinstmöglichen Teile. Diese können wie Puzzleteile zusammengesetzt werden, und zwar so, dass korrekte und absolut strenge Mathematik entsteht.

Die Natur von Metamath erzwingt ein sehr präzises mathematisches Denken, ähnlich dem, das beim Schreiben eines Computerprogramms erforderlich ist. Ein entscheidender Unterschied ist jedoch, dass ein Beweis, sobald er (durch das Metamath-Programm) als korrekt verifiziert wurde, definitiv korrekt ist; er kann niemals einen versteckten "`Fehler"' haben. Nachdem Sie sich an die Strenge und Genauigkeit von Metamath gewöhnt haben, könnten Sie sogar versucht sein die Haltung einzunehmen, dass ein Beweis niemals als korrekt angesehen werden sollte, bevor er nicht von einem Computer verifiziert wurde, genauso wie Sie einem Ausrechnen im Kopf oder auf Papier nicht völlig vertrauen, bis Sie die Berechnung auf einem Taschenrechner nachgeprüft haben.

Meine Zielvorstellung für Metamath war ein System zur Beschreibung und Verifikation der Mathematik, das vollständig universell und dennoch konzeptionell so einfach wie möglich ist. Da ich die Mathematik von einem axiomatischen, formalen Standpunkt aus betrachte, wollte ich erreichen, dass Metamath in der Lage ist, mit fast jedem mathematischen System umzugehen. Das ist nicht gerade einfach, aber zumindest im Prinzip möglich und hoffentlich anwendungstauglich. Ich wollte, dass es Beweise mit absoluter Strenge verifiziert, und aus diesem Grund ist Metamath eher eine "`nur-kompilierbare"' Sprache als eine algorithmische oder Turing-Maschinensprache (wie Pascal, C, Prolog, Mathematica, usw.).  Mit anderen Worten, eine in der Metamath-Sprache geschriebene Datenbasis "`macht"' nichts; sie stellt lediglich mathematisches Wissen dar und erlaubt es, dieses Wissen als korrekt zu verifizieren.  Ein Programm, das in einer algorithmischen Sprache geschrieben ist, kann potentiell versteckte Programmfehler(Bugs)\index{Programmfehler}\index{Bug} haben und möglicherweise auch schwer zu verstehen sein.  Aber jedes Eintrag in einer Metamath-Datenbasis muss konsistent mit den vorherigen Inhalt der Datenbasis sein, nach einfachen, festen Regeln.
Wenn eine Datenbasis als korrekt verifiziert wurde,\footnote{Dies beinhaltet die Verifikation, dass eine sequentielle Liste von Beweisschritten zu dem angegebenen Theorem führt.} dann ist der mathematische Inhalt korrekt, wenn der Verifizierer korrekt ist und die Axiome korrekt sind.
Das Verifikationsprogramm könnte zwar prinzipiell falsch sein, der verwendete Verifikationsalgorithmus ist jedoch relativ einfach, so dass es unwahrscheinlich ist, dass er in einem Metamath-Programm falsch implementiert wird. Außerdem gibt es mehr als ein Dutzend Verifizierer für die Metamath-Datenbasen, geschrieben von verschiedenen Programmierern in unterschiedlichen Programmiersprachen, so dass diese unterschiedlichen Verifizierer als unabhängige Prüfer einer Datenbasis fungieren können.
Die meistgenutzte Metamath-Datenbasis, der Metamath Proof Explorer (auch bekannt als \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}%
\index{Metamath Proof Explorer}), wird derzeit von vier verschiedenen Metamath-Verifikationsprogrammen verifiziert, die von vier unterschiedlichen Personen in vier verschiedenen Programmiersprachen geschrieben wurden, einschließlich des originalen Metamath-Programms, das in diesem Buch beschrieben wird.
Deshalb könnten die einzig möglichen "`Fehler"' in der Formulierung der Axiome liegen, zum Beispiel, wenn die Axiome inkonsistent sind (ein berühmtes Problem, das durch den Gödelschen Unvollständigkeitssatz\index{Gödelscher Unvollständigkeitssatz} als unlösbar aufgezeigt wurde).
Reale mathematische Systeme haben jedoch nur sehr wenige Axiome, und diese können sorgfältig studiert werden.
All dies bietet eine außerordentlich hohe Sicherheit, dass die geprüfte Datenbasis in der Tat korrekt ist.

Das Metamath-Programm beweist Theoreme nicht automatisch, sondern ist darauf ausgelegt, Beweise zu überprüfen, die ihm bereitgestellt werden.
Die Metamath zugrunde liegende Sprache ist völlig allgemein und hat keine eingebaute, vorgefasste Vorstellung über Ihr formales System, seine Logik oder seine Syntax.
Für die Konstruktion von Beweisen verfügt das Metamath-Programm über einen Beweis-Assistenten\index{Beweis-Assistent}, der Sie beim Ausfüllen einiger Details eines Beweisschritts unterstützt, und Ihnen die Möglichkeiten bei jedem Schritt zeigt.
Weiterhin verifiziert er den Beweis, während Sie ihn erstellen; den Beweis führen müssen Sie aber immer noch selbst.

Es gibt viele andere Programme, die Informationen in der Metamath-Sprache verarbeiten oder erzeugen können, und es werden immer mehr geschrieben. Das liegt zum Teil daran, dass die Metamath-Sprache selbst sehr einfach ist und mit Absicht leicht automatisch verarbeitet werden kann.
Einige Programme, wie z. B. \texttt{mmj2}\index{mmj2}, enthalten einen Beweis-Assistenten, der einige Beweisschritte automatisiert erstellen kann, die über das hinausgehen, was das Metamath-Programm kann.
Mario Carneiro hat einen Algorithmus entwickelt, der Beweise im OpenTheory-Austauschformat, welches aus und in jede einzelne Beweissprache der HOL-Familie (HOL4, HOL Light, ProofPower, und Isabelle) übersetzt werden kann, in die Metamath Sprache \cite{DBLP:journals/corr/Carneiro14}\index{Carneiro, Mario} überführt.
Daniel Whalen hat Holophrasm entwickelt, das automatisch viele Metamath-Beweise mithilfe von Ansätzen des maschinellen Lernens\index{maschinelles Lernen}\index{künstliche Intelligenz} (einschließlich mehrerer neuronaler Netze) beweisen kann\cite{DBLP:journals/corr/Whalen16}\index{Whalen, Daniel}.
Eine ausführliche Besprechung dieser anderen Programme würde jedoch den Rahmen dieses Buches sprengen.

Wie die meisten Computersprachen verwendet die Metamath\index{Metamath}-Sprache den
Standardzeichensatz ({\sc ascii}), der auf jeder Computertastatur zur Verfügung steht. Daher kann sie viele der speziellen Symbole, die Mathematiker verwenden, nicht direkt darstellen. 
Eine nützliche Eigenschaft des Metamath-Programms ist sein Fähigkeit, die von ihm verwendete Notation in die Textsatzsprache \LaTeX\ umzuwandeln.\index{latex@{\LaTeX}}
Mit dieser Funktion können Sie die von Ihnen definierten ASCII-Tokens in standardmäßig verwendete mathematische Symbole umwandeln, so dass Sie am Ende Symbole und Formeln erhalten, mit denen Sie vertraut sind, anstelle der etwas kryptischen {\sc ascii}-Darstellungen davon.
Das Metamath-Programm kann auch HTML\index{HTML} generieren, was die Veröffentlichung von Ergebnissen im Internet vereinfacht und die Bereitstellung weiterer Informationen zu einem Thema über Hypertext-Links ermöglicht.

Metamath ist wahrscheinlich konzeptionell anders als alles, was Sie bisher gesehen haben, und einige Aspekte sind vielleicht etwas gewöhnungsbedürftig. Dieses Buch wird Ihnen bei der Entscheidung helfen, ob Metamath Ihren speziellen Bedürfnissen entspricht.


\subsubsection{Was Sie erwartet}

Es ist wichtig, dass Sie verstehen, was Metamath\index{Metamath} ist und was nicht. Wie bereits erwähnt, ist das Metamath-Programm {\em kein} automatischer Theorembeweiser, sondern vielmehr ein Beweisprüfer. Die Entwicklung einer Datenbasis kann eine langwierige, harte Arbeit sein, vor allem wenn man die Beweise so kurz wie möglich halten möchte. Aber es wird einfacher, wenn man bereits eine Sammlung nützlicher Theoreme aufgebaut hat. Der Zweck von Metamath ist es einfach, die bestehende Mathematik in einer absolut strengen, durch Computer überprüfbare Weise zu dokumentieren, nicht um direkt bei der Schaffung neuer mathematischer Sätze oder Erkenntnisse zu helfen.  Es ist auch keine magische Lösung für das Erlernen abstrakter Mathematik, obwohl es hilfreich sein kann, die implizite Strenge hinter dem zu sehen, was man aus den Lehrbüchern lernt. Außerdem erhält man Hinweise um Beweise auszuarbeiten, bei denen man sonst nicht weiterkommt.

Bis zum Zeitpunkt der Erstellung dieses Buches wurde bereits eine umfangreiche Datenbasis für die Mengenlehre entwickelt, die eine Grundlage für viele Bereiche der Mathematik bietet. Aber es ist noch viel mehr Arbeit nötig, um nützliche Datenbasen für andere Bereiche zu entwickeln.

Metamath\index{Metamath} "`kennt keine Mathematik"'; es bietet lediglich Rahmenbedingungen zur Formulierung von Mathematik. Sein Sprachumfang ist sehr klein: man kann zwei Arten von Symbolen definieren, nämlich Konstanten\index{Konstante} und Variablen\index{Variable}.
Das Einzige, was Metamath beherrscht, ist das Ersetzen von Symbolen durch Zeichenketten für die Variablen\index{Substitution!Variable}\index{Variablensubstitution} in einem Ausdruck, der auf Anweisungen basiert, die man in einem Beweis angibt, vorbehaltlich bestimmter Einschränkungen, die man für die Variablen festlegt.  Sogar die dezimale Darstellung einer Zahl ist lediglich eine Folge von bestimmten Konstanten (Ziffern), die zusammengenommen einem beliebigen mathematischen Objekt entsprechen, das man für sie in einem bestimmten Kontext definiert. Im Gegensatz zu anderen Computersprachen wird tatsächlich keine Zahl explizit im Computer gespeichert.
In einem Beweis gibt man Metamath vor, welche Symbol-Substitutionen in vorherigen Axiomen oder Theoremen vorzunehmen sind, und fügt eine Folge von solchen Substitutionen zusammen, um das gewünschte Theorem zu erhalten.  Diese Art der Symbolmanipulation erfasst das Wesentliche der Mathematik auf einer präaxiomatischen Ebene.


\subsubsection{Metamath und mathematische Literatur}

In der Literatur für höhere Mathematik werden die Beweise gewöhnlich in Form von kurzen Skizzen dargestellt, denen oft nur ein Experte folgen kann.  Dies resultiert zum Teil aus dem Wunsch nach Kürze, aber es wäre auch unklug (selbst wenn es praktisch möglich wäre) Beweise mit allen formalen Details zu präsentieren, da das Gesamtbild verloren gehen würde.\index{formaler Beweis}

Eine Lösung\label{envision}, so wie ich sie mir vorstelle, besteht aus einer Kombination des traditionellen kurzen, informellen Beweises in gedruckter Form, begleitet von einem vollständigen formalen Beweis, der in einer Computerdatenbasis gespeichert ist. Dies würde es ermöglichen, dass die Mathematik für den Experten akzeptabel bleibt, aber auch dem Nichtspezialisten zugänglich ist.
In Analogie zu einem Computerprogramm kann man den informellen Beweis als Pseudocode ansehen, der die übergreifenden Schlussfolgerungen und den Inhalt des Beweises beschreibt, während die Computerdatenbasis mit dem tatsächlichen Programmcode verglichen werden kann, die jedem, auch einem Laien, die Möglichkeit bietet, den Beweis so detailliert wie gewünscht nachzuvollziehen, indem man in immer tiefere Schichten von Theoremen bis hin zu den Axiomen der Theorie vordringt (wie bei Unterprogrammen, die wiederum andere Unterprogramme aufrufen).  Darüber hinaus hätte die Computerdatenbasis den Vorteil, dass sie die absolute Sicherheit bietet, dass der Beweis korrekt ist, da jeder Schritt automatisch überprüft werden kann.

Neben Metamath gibt es mehrere andere Ansätze für ein Projekt wie dieses.  Abschnitt~\ref{proofverifiers} erörtert einige davon.

Ein hehres Ziel wäre für uns eine Datenbasis mit Hunderttausenden von Theoremen und ihren durch Computer überprüfbaren Beweisen, die einen bedeutenden Teil der bekannten Mathematik umfasst und für den sofortigen Zugriff zur Verfügung stellt.
Diese würden von mehreren unabhängig voneinander implementierten Verifizierern vollständig geprüft werden, um ein extrem hohes Maß an Vertrauen in die vollständige Korrektheit der Beweise herzustellen.
Die Datenbasis würde es allen ermöglichen, jegliche interessierende Details zu untersuchen, so dass man jeden gewünschten Teil eines Beweises bestätigen kann.
Ob Metamath die richtige Wahl ist, bleibt abzuwarten, aber im Prinzip glauben wir, dass sie hinreichend angemessen ist.


\subsubsection{Formalismus}

In den letzten fünfzig Jahren hat eine Gruppe französischer Mathematiker, die unter dem Pseudonym Bourbaki\index{Bourbaki, Nicolas} zusammenarbeiten, eine Reihe von Monographien verfasst, die versuchen, große Teile der Mathematik konsequent von den Grundlagen her zu formalisieren.  Einerseits hat ein solcher Versuch sicherlich seine Vorzüge; andererseits ist das Bourbaki-Projekt wegen seiner "`Scholastik"' und "`Hyperaxiomatik"', welche die intuitiven, zu den Ergebnissen führenden Schritte verbergen, kritisiert worden \cite[S.~191]{Barrow}\index{Barrow, John D.}.

Metamath treibt diese Philosophie ungeniert auf die Spitze und ist zweifellos der gleichen Art von Kritik ausgesetzt.  Nichtsdestotrotz denke ich, dass in Verbindung mit konventionellen Ansätzen der Mathematik Metamath einen nützlichen Zweck erfüllen kann.  Der Ansatz von Bourbaki ist im Wesentlichen pädagogisch und verlangt vom Leser, sich mit jedem Detail in einer sehr großen Hierarchie vertraut zu machen, bevor er oder sie zum nächsten Schritt übergehen kann.  Der Unterschied zu Metamath besteht darin, dass der "`Leser"' (Benutzer) weiß, dass alle Details in seiner Computerdatenbasis enthalten sind, die bei Bedarf abgerufen werden können; es wird nicht verlangt, dass der Benutzer alles weiß, sondern es werden ihm komfortabel die Teile zur Verfügung gestellt, die von Interesse sind.  Da der Umfang des gesamten mathematischen Wissens immer größer wird, kann kein Einzelner seine Gesamtheit in voller Tiefe überblicken. Metamath kann alle Fragen über die Gültigkeit eines beliebigen Teils des Wissens abschließend klären und Zweifel ausräumen, und kann im Prinzip jeden Teil davon für einen Nicht-Spezialisten zugänglich machen.


\subsubsection{Eine persönliche Anmerkung}
Warum habe ich Metamath\index{Metamath} entwickelt?  Ich mag abstrakte Mathematik, aber manchmal verirre ich mich in einer Flut von Definitionen und verliere das Vertrauen in die Korrektheit meiner Beweise.  Oder ich erreiche einen Punkt, an dem ich aus den Augen verliere, wie alles, was ich tue, mit den Axiomen zusammenhängt, auf denen eine Theorie beruht. Ich habe manchmal den Verdacht, dass unterwegs ein übersehenes implizites Axiom versehentlich eingebracht wurde (wie es historisch mit der euklidischen Geometrie\index{euklidische Geometrie}, deren Auslassung des Pasch'schen Axioms\index{Axiom von Pasch} für 2000 Jahre unbemerkt blieb \cite[p.~160]{Davis}!).
Ich bin auch etwas faul und möchte den Aufwand vermeiden Lücken in informellen Beweisen, die "`dem Leser überlassen"' werden, erneut selbst nachzuprüfen. Ich ziehe es vor, sie nur einmal herauszufinden und mich nicht ein Jahr später erneut durch dieselbe Frustration zu kämpfen, wenn ich vergesse, was ich getan habe.  Metamath bietet eine bessere Möglichkeit zur Wiederherstellung meiner Bemühungen als Papierfetzen, die ich nicht mehr entziffern kann.  Aber vor allem finde ich die Idee sehr reizvoll, mathematisches Wissen in einer Computerdatenbasis zu archivieren, die Präzision, Gewissheit und die Eliminierung menschlicher Fehler gewährleistet.


\subsubsection{Anmerkung zu Bibliographie und Index}

Die Bibliographie enthält in der Regel die Library of Congress-Klassifikation für ein Werk, damit Sie es in einem Regal einer Universitätsbibliothek leichter finden.  Der Index enthält Verweise auf Seiten, auf denen die Werke der Autoren zitiert werden, auch wenn die Namen der Autoren vielleicht nicht auf diesen Seiten erscheinen.


\subsubsection{Danksagungen}

Dank gebührt zunächst meiner Frau Deborah (die am 4. September 1998 verstorben ist), für die Kritik am Manuskript, aber vor allem für ihre Geduld und Unterstützung.  Ich möchte auch Joe Wright, Richard Becker, Clarke Evans, Buddha Buck, und Jeremy Henty für hilfreiche Kommentare danken.  Etwaige Fehler, Auslassungen und andere Unzulänglichkeiten liegen natürlich in meiner Verantwortung.


\subsubsection{Notiz hinzugefügt am 22. Juni 2005}\label{note2002}

Die ursprüngliche, unveröffentlichte Version dieses Buches wurde 1997 geschrieben und über das Internet verbreitet.  Die vorliegende Ausgabe wurde aktualisiert, um das aktuelle Metamath-Programm und die Datenbasen sowie aktuellere {\sc url}s für Internet-Seiten wiederzugeben.  Dank an Josh Purinton\index{Purinton, Josh}, One Hand Clapping, Mel L.\ O'Cat und Roy F. Longton für das Aufzeigen von typografischen und anderen Fehler.  Ich habe auch von zahlreichen Diskussionen mit Raph Levien\index{Levien, Raph} profitiert, der Metamaths Philosophie der Strenge erweitert hat, was in seine Beweissprache {\em Ghilbert}\index{Ghilbert} (\url{http://ghilbert.org}) resultierte.

Robert (Bob) Solovay\index{Solovay, Robert} teilte ein neues Ergebnis von A.~R.~D.~Mathias über das System von Bourbaki mit, und der Text wurde entsprechend aktualisiert (S.~\pageref{bourbaki}).

Bob wies auch auf eine Klärung der Literatur bezüglich der Kategorientheorie und unzugängliche Kardinalzahlen\index{Kategorientheorie}\index{Kardinalzahl, unzugänglich} (S.~\pageref{categoryth}) hin, und eine missverständliche Aussage wurde aus dem Text entfernt.  Genauer gesagt ist es im Gegensatz zu einer Aussage in früheren Ausgaben möglich, "`Es gibt eine eigene Klasse von unzugänglichen Kardinalen"' in der Sprache von ZFC auszudrücken.  Dies lässt sich wie folgt bewerkstelligen:  "`Für jede Menge $x$ gibt es eine unzugängliche Kardinalzahl $\kappa$, so dass $\kappa$ nicht in $x$ liegt"'. Bob schreibt:\footnote{Private Korrespondenz, 30. November 2002.}
\begin{quotation}
  
  Dieses Axiom ist die Art und Weise, wie Grothendieck die Kategorientheorie darstellt.  Jedem unzugänglichen Kardinal $\kappa$ ordnet man ein Grothendieck-Universum \index{Grothendieck, Alexander} $U(\kappa)$ zu. $U(\kappa)$ besteht aus denjenigen Mengen, die in einer transitiven Menge der Kardinalität kleiner als $\kappa$ liegen.  Anstelle der "`Kategorie aller Gruppen"' arbeitet man relativ zu einem Universum [unter Berücksichtigung der Kategorie der Gruppen mit Kardinalität kleiner als $\kappa$].  Nun ist die Kategorie, deren Objekte alle Kategorien "`relativ zum Universum $U(\kappa)$"' sind, eine Kategorie nicht relativ zu diesem Universum, sondern zum nächsten Universum.
  
  All die Dinge, die Kategorientheoretiker gerne tun, können in diesem Rahmen getan werden.  Der einzige strittige Punkt ist, ob das Grothen-Dieck-Axiom für die Bedürfnisse der Kategorientheoretiker zu stark ist.  Mac Lane \index{Mac Lane, Saunders} argumentiert, dass "`ein Universum ausreicht"' und Feferman\index{Feferman, Solomon} hat argumentiert, dass man mit der gewöhnlichen ZFC auskommen kann.  Ich finde die Argumente von Feferman nicht überzeugend.  Mac Lane mag recht haben, aber wenn ich über Kategorientheorie nachdenke, tue ich das \`{a} la Grothendieck.
  
  Übrigens fügt Mizar\index{Mizar} das Axiom "`Es gibt eine eigene Klasse von Unzugänglichkeiten"' hinzu, genau um Kategorientheorie zu betreiben.

\end{quotation}

Die aktuellsten Informationen über das Metamath-Programm und die Datenbasen sind immer unter \url{http://metamath.org} zu finden.


\subsubsection{Notiz hinzugefügt am 24. Juni 2006}\label{note2006}

Die Metamath-Spezifikation wurde leicht eingeschränkt, um das Schreiben von Parsern zu erleichtern.  Siehe die Fußnote auf S.~\pageref{namespace}.


%\subsubsection{Note Added July 24, 2006}\label{note2006b}
\subsubsection{Notiz hinzugefügt 10 März 2007}\label{note2006b}

Ich bin Anthony Williams\index{Williams, Anthony} dankbar für das Schreiben des \LaTeX-Pakets namens {\tt realref.sty} und dafür, dass er es der Public Domain zur Verfügung gestellt hat.  Mit diesem Paket können die internen Hyperlinks in einer {\sc pdf}-Datei auf bestimmte Seitenzahlen verankert werden, anstatt nur auf Abschnittsüberschriften, was die Navigation in der {\sc pdf}-Datei für dieses Buch viel angenehmer und "`logischer"' macht.

Ein von Martin Kiselkov gefundener Druckfehler wurde korrigiert.
Eine verwirrende Bemerkung über die Vereinheitlichung wurde auf Anregung von Mel O'Cat entfernt.


\subsubsection{Notiz hinzugefügt am 27. Mai 2009}\label{note2009}

Mehrere von Kim Sparre gefundene Tippfehler wurden korrigiert.  Es wurde ein Hinweis hinzugefügt, dass die Poincar'{e}-Vermutung bewiesen wurde (S.~\pageref{poincare}).


\subsubsection{Notiz hinzugefügt am 17 Nov. 2014}\label{note2014}

Die Aussage des Schröder-Bernstein-Theorems in Abschnitt~\ref{trust} wurde korrigiert.  Dank an Bob Solovay für den Hinweis auf den Fehler.


\subsubsection{Notiz hinzugefügt am 25. Mai 2016}\label{note2016}

Dank an Jerry James für die Korrektur von 16 Tippfehlern.


\subsubsection{Notiz hinzugefügt Februar 25, 2019}\label{note201902}

David A. Wheeler\index{Wheeler, David A.} hat, in Zusammenarbeit mit mir, eine große Anzahl von Verbesserungen und Aktualisierungen vorgenommen.
Die Axiome der Prädikatenlogik wurden neu nummeriert, und der Text macht nun deutlich, dass sie auf Tarskis System S2 beruhen; die einzige geringfügige Abweichung im Axiom ax-6 wird erklärt und begründet.
Die Axiome für reelle und komplexe Zahlen wurden geändert, damit sie mit \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}%
\index{Metamath Proof Explorer} konsistent sind.
Lang erwartete Änderungen der Spezifikation "`1--8"' wurden vorgenommen, was zur Klärung von zuvor mehrdeutigen Punkten führte.
Einige Fehler im Text, welche die \texttt{\$f}- und \texttt{\$d}-Anweisungen betreffen, wurden korrigiert (die Spezifikation war korrekt, aber die Erklärungen im Buch widersprachen versehentlich der Spezifikation).
Wir haben jetzt ein System zur automatischen Erzeugung von schmalen PDFs, damit alle, die ein Smartphone besitzen, einen einfachen Zugang zur aktuellen Version des Dokuments haben.
Ein neuer Abschnitt über Deduktion wurde hinzugefügt; er behandelt das Standard-Deduktionstheorem, das Theorem der schwachen Deduktion, den Deduktionsstil und die natürliche Deduktion.
Viele kleinere Korrekturen (zu zahlreich, um sie hier aufzulisten) wurden ebenfalls vorgenommen.


\subsubsection{Notiz hinzugefügt am 7. März 2019}\label{note201903}

Eine Beschreibung der Metamath-Syntax in erweiterter Backus--Naur-Form (EBNF)\index{erweiterte Backus--Naur-Form}\index{EBNF} wurde im Anhang \ref{BNF} ergänzt, eine kurze Erklärung über Typcodes hinzugefügt, weitere Beispiele im Abschnitt über Deduktion eingefügt, und eine Vielzahl kleinerer Verbesserungen durchgeführt.


\subsubsection{Notiz hinzugefügt am 7. April 2019}\label{note201904}

In dieser Version des Buches wird die Notation für die "`echte Substitution"' geklärt, die
Erläuterungen zu dem Theorem der schwachen Deduktion und zu der natürlichen Deduktion verbessert,
der Befehl \texttt{undo} dokumentiert, die Informationen zu \texttt{write source} aktualisiert,  der Typcode von \texttt{set} in \texttt{setvar} geändert, um mit der aktuellen Version von \texttt{set.mm} übereinzustimmen, weitere Erläuterungen über Kommentarauszeichnungen hinzugefügt (z.B. wurde dokumentiert, wie man Überschriften erstellt), und die Unterschiede zwischen den verschiedenen Behauptungsformen (insbesondere der Ableitungsform) klargestellt.


\subsubsection{Notiz hinzugefügt am 2. Juni 2019}\label{note201906}

Diese Version behebt eine große Anzahl kleinerer Probleme, die von Beno\^{i}t Jubin\index{Jubin, Beno\^{i}t} gemeldet wurden, wie z.B. redaktionelle Probleme und die Notwendigkeit, \texttt{verify markup} zu dokumentieren (Vielen Dank!).
Außerdem enthält diese Version nun konkrete Beispiele für die Formen von Theoremen (Deduktionsform, Inferenzform und geschlossene Form).
Wir nennen diese Version die "`zweite Auflage"'; die vorherige Ausgabe, die 2007 offiziell veröffentlicht wurde, hatte einen etwas anderen Titel (\textit{Metamath: Eine Computersprache für die reine Mathematik}).


\chapter{Einleitung}
\pagenumbering{arabic}

\begin{quotation}

  {\em {\em I.M.:}  Nein, nein.  Da ist nichts Subjektives dran!  Jeder weiß, was ein Beweis ist.  Lesen Sie einfach ein paar Bücher, besuchen Sie Kurse bei einem kompetenten Mathematiker, und Sie werden es verstehen.     
  
  {\em Schüler:}  Sind Sie sicher?
  
  {\em I.M.:}  Nun - es ist möglich, dass Sie es nicht verstehen, wenn Sie keine Begabung dafür haben.  Das kann auch passieren.
  
  {\em Schüler:}  Dann entscheiden Sie, was ein Beweis ist, und wenn ich nicht lerne auf dieselbe Art und Weise zu entscheiden, dann bestimmen Sie, dass ich keine Begabung habe.
  
  {\em I.M.:}  Wenn nicht ich, wer dann?}       
  
      \flushright\sc "`Der ideale Mathematiker"'
      \index{Davis, Phillip J.}
      \footnote{Frei übersetzt nach \cite{Davis}, \sc  "`The Ideal Mathematician"' S.~40.}\\
\end{quotation}

Brillante Mathematiker haben nahezu unvorstellbar tiefgreifende Ergebnisse erzielt, die zu den krönenden intellektuellen Errungenschaften der Menschheit zählen.  Allerdings hinkt die moderne abstrakte Mathematik in gewisser Weise der Zeit hinterher, und ist in einer Ära vor der Existenz von Computern stecken geblieben.
Zwar bestreitet niemand die bemerkenswerten Ergebnisse, die erzielt wurden.  Jedoch ist es praktisch unmöglich, diese Ergebnisse einem Uneingeweihten in präziser Weise zu vermitteln.  Um diese Ergebnisse zu beschreiben, wird eine knappe, informelle Sprache verwendet, die trotz ihrer Eleganz sehr schwer zu erlernen ist.  Diese informelle Sprache ist nicht unpräzise, ganz im Gegenteil, jedoch werden Details häufig einfach ausgelassen, und es werden Symbole mit verborgenem Kontext verwendet, die implizit von einem Experten verstanden werden, aber nur von wenigen anderen.
Äußerst komplexe technische Bedeutungen werden verbunden mit harmlos klingenden Wörtern wie "`kompakt"' und "`messbar"', die kaum einen Hinweis darauf geben, was eigentlich damit ausgesagt wird.  Wer sich die genaue technische Bedeutung nicht ständig vor Augen hält scheitert, und die Fähigkeit dazu kann nur durch viel Übung und harte Arbeit erworben werden.  Nur die wenigen, welche diese notwendige, schmerzhafte Lernerfahrung machen, können der kleinen, geschlossenen Gruppe der reinen Mathematiker beitreten.  Die informelle Sprache schottet die wahre Natur ihres Wissens von den meisten anderen ab.

Metamath\index{Metamath} macht abstrakte Mathematik konkreter.  Es ermöglicht einem Computer, die mit jedem Wort oder Symbol verbundene Komplexität mit absoluter Strenge zu erfassen.  Man kann diese Komplexität in aller Ruhe erforschen, und zwar bis zum gewünschten Detaillierungsgrad.  Ob Sie nun glauben, dass Konzepte wie Unendlichkeit tatsächlich außerhalb des Verstandes "`existieren"' oder nicht, mit Metamath können Sie das ergründen, was damit tatsächlich ausgesagt werden soll.

Metamath ermöglicht auch eine völlig rigorose und gründliche Überprüfung von Beweisen.
Seine Sprache ist so einfach, dass man sich nicht auf die Autorität von Experten verlassen muss, sondern die Ergebnisse Schritt für Schritt selbst überprüfen kann.  Wenn Sie versuchen wollen, Ihre eigenen Ergebnisse abzuleiten, lässt Metamath Sie keinen Denkfehler machen.
Auch professionelle Mathematiker machen Fehler; Metamath dagegen ermöglicht es, die Korrektheit von Beweisen gründlich zu überprüfen.

Metamath\index{Metamath} ist eine Computersprache und ein zugehöriges Computerprogramm für das Archivieren, Überprüfen und Studieren mathematischer Beweise auf einer sehr detaillierten Ebene.
Mit der Metamath-Sprache können formale mathematische Systeme\index{formales System} beschrieben und Beweise für Theoreme in diesen Systemen formuliert werden.  Eine solche Sprache wird von Mathematikern als Metasprache bezeichnet. Das Metamath-Programm ist ein Computerprogramm zur Überprüfung von Beweisen, die in der Metamath-Sprache geschrieben sind.  Das Metamath-Programm verfügt nicht über die eingebaute Fähigkeit, logische Schlüsse zu ziehen; es führt lediglich eine Reihe von Ersetzungen von Symbolen gemäß den Anweisungen durch, die ihm in einem Beweis gegeben werden, und prüft, ob das Ergebnis mit dem erwarteten Theorem übereinstimmt.  Es macht logische  Schlussfolgerungen nur auf der Grundlage von Regeln der Logik, welche in einer Menge von Axiomen\index{Axiom} oder ersten Prinzipien enthalten sind, die ihm als Ausgangspunkt für Beweise vorgegeben werden.
	
Die vollständige Spezifikation der Metamath-Sprache ist nur vier Seiten lang (Abschnitt~\ref{spec}, S.~\pageref{spec}).  Ihre Einfachheit mag Sie zunächst fragen lassen, was man damit überhaupt erreichen kann.  Aber in der Tat sind die verwendeten Symbolmanipulationen diejenigen, die in allen mathematischen Systemen auf der untersten Ebene implizit durchgeführt werden.  Man kann sie relativ schnell lernen und volles Vertrauen in jeden mathematischen Beweis haben, den Metamath verifiziert.  Andererseits ist die Metamath-Sprache leistungsfähig und allgemein genug, um mit ihr  praktisch jede mathematische Theorie, von der einfachsten bis zur abstraktesten, zu beschreiben.

Obwohl Metamath im Prinzip für jede Art von Mathematik verwendet werden kann, ist es am besten für abstrakte oder "`reine"' Mathematik geeignet, die sich hauptsächlich mit Theoremen und deren Beweisen befasst - im Gegensatz zu der Art von Mathematik, die sich mit der praktischen Handhabung von Zahlen beschäftigt.
Beispiele für Teilgebiete der reinen Mathematik sind die Logik\footnote{Logik ist die Lehre von den Aussagen, die unabhängig von den Objekten, die sie beschreiben, universell wahr sind. Ein Beispiel ist die Aussage: "`Wenn $P$	$Q$ impliziert, dann ist entweder $P$ falsch oder $Q$ wahr."'}, Mengenlehre\index{Mengenlehre}\footnote{Die Mengenlehre ist die Lehre von allgemeinen mathematischen Objekten, den so genannten "`Mengen"'. Von ihr lässt sich im Wesentlichen die gesamte Mathematik ableiten. Zahlen können beispielsweise als spezifische Mengen definiert werden, und ihre Eigenschaften können mit den Werkzeugen der Mengenlehre erforscht werden.}, Zahlentheorie\index{Zahlentheorie}\footnote{Die Zahlentheorie befasst sich mit den Eigenschaften von positiven und negativen ganzen Zahlen.}, Gruppentheorie\index{Gruppentheorie}\footnote{Die Gruppentheorie untersucht die Eigenschaften von mathematischen Objekten, die als "`Gruppen"' bezeichnet werden: Sie gehorchen einem einfachen Satz von Axiomen und haben Symmetrieeigenschaften, die sie für viele andere Bereiche nützlich machen.}, abstrakte Algebra\index{abstrakte Algebra}\footnote{Abstrakte Algebra umfasst die Gruppentheorie und untersucht auch Gruppen mit zusätzlichen Eigenschaften, die sie als "`Ringe"' und "`Körper"' qualifizieren.  Die Menge der reellen Zahlen ist ein bekanntes Beispiel für einen Körper.}, Analysis\index{Analysis}\index{reelle Zahl}\index{komplexe Zahl}\footnote{Analysis ist die Lehre von den reellen und komplexen Zahlen.} und Topologie\index{Topologie}\footnote{Ein Bereich, der von der Topologie untersucht wird, sind Eigenschaften geometrischer Objekte, die unverändert bleiben, wenn sie Verformungen unterzogen werden.  Zum Beispiel haben ein Donut und eine Kaffeetasse jeweils ein Loch (die Tasse hat ein Loch im Henkel) und werden daher als topologisch äquivalent betrachtet.  Im Allgemeinen ist die Topologie jedoch die Lehre von abstrakten mathematischen Objekten, die einer bestimmten (erstaunlich einfachen) Reihe von Axiomen gehorchen. Siehe z. B. Munkres \cite{Munkres}\index{Munkres, James R.}.}. Auch in der Physik könnte Metamath auf bestimmte Zweige angewandt werden, die sich der abstrakten Mathematik, wie z.B. der Quantenlogik (die zur Untersuchung von Aspekten der Quantenmechanik genutzt wird), bedienen.

Andererseits ist Metamath\index{Metamath} weniger geeignet für Anwendungen, die sich hauptsächlich mit intensiven numerischen Berechnungen befassen.  Metamath hat keine eingebaute Darstellung von Zahlen\index{Metamath!Zahlendarstellung}; stattdessen muss eine bestimmte Folge von Symbolen (Ziffern) syntaktisch als Teil eines Beweises konstruiert werden, in dem eine gewöhnliche Zahl verwendet wird.  Aus diesem Grund sind Zahlen in Metamath am besten auf spezifische Konstanten beschränkt, die im Verlauf eines Theorems oder seines Beweises auftauchen.  Zahlen sind nur ein winziger Teil der Welt der abstrakten Mathematik.  Der Ausschluss von eingebauten Zahlen war eine bewusste Entscheidung, um die Einfachheit von Metamath sicherzustellen. Es gibt andere Software-Tools für andere mathematische Fragestellungen. Wenn Sie schnell algebraische Probleme lösen möchten, sind die Computeralgebrasysteme\index{Computeralgebrasystem} Macsyma\index{Macsyma}, Mathematica\index{Mathematica} und Maple\index{Maple} besonders gut geeignet, um mit Zahlen und Algebra effizient umzugehen.  Wenn Sie einfach nur numerische Ausdrücke oder Matrixausdrücke bequem berechnen möchten, dürften Tools wie Octave\index{Octave} eine bessere Wahl sein.

Nach dem Erlernen der grundlegenden Anweisungstypen von Metamath sollte jeder technisch versierte Mensch, ob Mathematiker oder nicht, sofort in der Lage sein, jedes in der Metamath-Sprache bewiesene Theorem so weit wie gewünscht zurückzuverfolgen - bis hin zu den Axiomen, auf denen das Theorem beruht.  Diese Möglichkeit erlaubt eine nicht-traditionelle Art und Weise des Lernens der reine Mathematik.  In Verbindung mit traditionellen Methoden könnte Metamath die reine Mathematik für Menschen zugänglich machen, die nicht ausreichend qualifiziert sind, um die impliziten Details in gewöhnlichen Lehrbuchbeweisen zu verstehen.  Sobald man die Axiome einer Theorie kennt, kann man sich darauf verlassen, dass alles vorhanden ist, was man zum Verstehen eines vorliegenden Beweises braucht.  Somit kann man sich auf jeden Beweisschritt konzentrieren, den man nicht versteht - und zwar so tief wie nötig, ohne sich Sorgen machen zu müssen, dass man bei einem Schritt, den man sich nicht erklären kann, nicht mehr weiter kommt.\footnote{Andererseits ist das Schreiben von Beweisen in der Metamath-Sprache anspruchsvoll und erfordert einen Grad an Strenge, der weit über das hinausgeht, was Schülern oder Studenten normalerweise beigebracht wird.  Ich bezweifle, dass im Mathematikunterricht das Schreiben von Metamath-Beweisen jemals die traditionellen Hausaufgaben mit informellen Beweisen ersetzen wird, denn aufgrund der Zeit, die für die Ausarbeitung der Details benötigt wird, könnten im Unterricht nur wenige Themen behandelt werden.  Schülern mit Schwierigkeiten, die implizite Strenge im vorliegenden, traditionell verfassten Material zu verstehen, kann das Schreiben einiger einfacher Beweise in der Metamath-Sprache jedoch helfen, ungenaue Gedankengänge zu klären.  Obwohl es anfangs etwas schwierig ist, macht dies aufgrund der sofortigen Rückmeldung durch den Computer sogar Spaß, wie das Lösen eines Rätsels.}

Metamath ist wahrscheinlich anders als alles, was Ihnen bisher begegnet ist.  In diesem ersten Kapitel werden wir uns mit der Philosophie und dem Einsatz von Computern in der Mathematik beschäftigen, um die Motivation hinter Metamath besser zu verstehen. Das Material in diesem Kapitel ist nicht erforderlich, um Metamath zu benutzen.  Sie können es überspringen, wenn Sie ungeduldig sind, aber ich hoffe, Sie werden es lehrreich und unterhaltsam finden.  Wenn Sie gleich mit dem Experimentieren mit dem Metamath-Programm beginnen wollen, gehen Sie direkt zu Kapitel~\ref{using}
(S.~\pageref{using}).  Um die Metamath-Sprache zu lernen, überfliegen Sie Kapitel~\ref{using} und fahren direkt fort mit Kapitel~\ref{languagespec} (S.~\pageref{languagespec}).


\section{Mathematik als eine Computersprache}

\begin{quote}
  
  {\em Das Studium der Mathematik beginnt oft mit einer Enttäuschung. \ldots \\
  	Uns wird gesagt, dass mit ihrer Hilfe die Sterne gewogen und die Milliarden von Molekülen in einem Wassertropfen gezählt werden.  Doch wie der Geist von Hamlets Vater entzieht sich diese große Wissenschaft den Bemühungen unserer geistigen Waffen, sie zu begreifen.}
  \flushright\sc  Alfred North Whitehead\footnote{Frei übersetzt nach \cite{Whitehead}, Kap.\ 1.}\\
\end{quote}\index{Whitehead, Alfred North}

\subsection{Ist die Mathematik "`benutzerfreundlich"'?}

Angenommen, Sie haben keine formale Ausbildung in abstrakter Mathematik erhalten.  Aber populäre Bücher, die Sie gelesen haben, bieten verlockende Einblicke in diese Welt voller tiefgründiger Ideen, die den menschlichen Geist aufgewühlt haben.  Sie sind nicht zufrieden mit den informellen, verwässerten Beschreibungen, die Sie gelesen haben, sondern halten es für wichtig, die zugrundeliegende Mathematik selbst zu begreifen, um ihre wahre Bedeutung zu verstehen.  Es ist aber nicht sinnvoll, wieder zur Schule zu gehen, um sie zu lernen; Sie wollen nicht Jahre Ihres Lebens damit verbringen.  Es gibt viele wichtige Dinge im Leben, und man muss Prioritäten für das setzen, was einem wichtig ist.  Was würde passieren, wenn Sie versuchen würden, dieses Vorhaben allein in Ihrer Freizeit zu verfolgen?

Immerhin waren Sie in der Lage, eine Computer-Programmiersprache wie Pascal ohne große Schwierigkeiten selbst zu erlernen, obwohl Sie keine formale Ausbildung für Computer hatten.  Sie behaupten nicht, ein Experte für Software-Design zu sein, aber Sie können ein passables Programm schreiben, das Ihren Bedürfnissen entspricht.  Wichtiger ist sogar noch, dass Sie wissen, dass Sie sich das Pascal-Programm eines anderen ansehen können, egal wie komplex es ist, und mit genügend Geduld herausfinden können, wie es genau funktioniert, auch wenn Sie kein Spezialist sind.  Mit Pascal können Sie alles tun, was ein Computer tun kann, zumindest im Prinzip.  Sie wissen also, dass Sie die Fähigkeit haben, im Prinzip alles zu tun, was ein Computerprogramm tun kann: Sie müssen es nur in genügend kleine Stücke zerlegen.

Das folgende imaginäre Szenario könnte eintreten, wenn Sie sich unbedarft der gleichen Sichtweise der abstrakten Mathematik annehmen und versuchen würden, sie selbst zu lernen.  Und zwar in einem Zeitraum, der vergleichbar ist mit dem Erlernen einer Programmiersprache für Computer.


\subsubsection{Die Suche eines Nicht-Mathematikers nach der Wahrheit}

\begin{quote}
  {\em \ldots meine Töchter studieren schon seit mehreren Semestern (Chemie) und meinen, in der Schule Differential- und Integralrechnung gelernt zu haben, aber wissen doch bis heute nicht, warum $x\cdot y=y\cdot x$ gilt.}
    \flushright\sc Edmund Landau\footnote{Frei übersetzt nach \cite{Landau}, S.~vi.}\
\end{quote}\index{Landau, Edmund}

\begin{quote}
  {\em Minus mal minus ergibt plus,\\
   warum das so ist müssen wir nicht diskutieren.}
    \flushright\sc W.\ H.\ Auden\footnote{Frei übersetzt nach dem Zitat in \cite{Guillen}, S.~64.}\\
\end{quote}\index{Auden, W.\ H.}\index{Guillen, Michael}

Nehmen wir an, Sie sind ein technisch orientierter Fachmann, vielleicht ein Ingenieur, ein Computerprogrammierer oder ein Physiker, aber eben kein Mathematiker.  Sie halten sich für einigermaßen intelligent.  Sie waren gut in der Schule und lernten eine Vielzahl von Methoden und Techniken der praktischen Mathematik, wie z.~B. der Infinitesimalrechnung und das Lösen von Differentialgleichungen.  Aber in Ihrem Unterricht ging es selten um moderne abstrakte Mathematik, und Beweise tauchten nur gelegentlich in Ihren Lehrbüchern auf - eine Art notwendiges Übel, das Sie von einem bestimmten Schlüsselergebnis überzeugen sollte.  Die meisten Ihrer Hausaufgaben bestanden aus Übungen, in denen die Techniken geübt wurden, und Sie wurden kaum jemals aufgefordert, einen eigenen Beweis zu erstellen.

Sie sind neugierig auf fortgeschrittene, abstrakte Mathematik.  Sie sind von der inneren Überzeugung getrieben, dass es wichtig ist, einige der tiefgreifendsten Erkenntnisse der Menschheit zu verstehen und zu schätzen.  Aber es scheint sehr schwer erlernbar zu sein, etwas, das nur bestimmte begabte Fachidioten begreifen und verstehen können.  Sie sind frustriert, dass Ihnen solche Erkenntnisse scheinbar für immer verschlossen bleiben.

Schließlich treibt Sie Ihre Neugierde dazu, etwas dagegen zu tun.
Sie setzen sich das Ziel, Mathematik "`wirklich"' zu verstehen: nicht nur wie man Gleichungen in Algebra oder Infinitesimalrechnung nach Kochbuchregeln manipuliert, sondern vielmehr ein tiefes Verständnis dafür zu erlangen, woher diese Regeln kommen.
In Wirklichkeit geht es Ihnen gar nicht um diese Art von gewöhnlicher Mathematik,
sondern über einen viel abstrakteren, feinstofflichen Bereich der reinen Mathematik, zu denen berühmte Ergebnisse wie der Gödelsche Unvollständigkeitssatz\index{Gödelscher Unvollständigkeitssatz} und Cantors verschiedene Arten von Unendlichkeiten gehören.

Sie haben wahrscheinlich eine Reihe populärer Bücher mit Titeln wie {\em Infinity and the Mind} \cite{Rucker}\index{Rucker, Rudy} zu Themen wie diesen gelesen.  Sie fanden sie inspirierend, aber gleichzeitig auch etwas unbefriedigend.  Sie gaben Ihnen eine allgemeine Vorstellung davon, worum es bei diesen Ergebnissen geht, aber wenn jemand Sie bitten würde, sie zu beweisen, wüssten Sie nicht, wo man anfangen soll.  Sicher, Sie könnten denselben allgemeinen Überblick geben, den Sie aus den populären Büchern gelernt haben, und in gewisser Weise haben Sie auch ein Verständnis.  Aber tief in Ihrem Inneren wissen Sie, dass eine gewisse Strenge fehlt, dass es auf dem Weg dorthin wahrscheinlich viele subtile Schritte und Fallstricke gibt, und dass man sich letztlich auf die Experten auf diesem Fachgebiet verlassen muss.  Das gefällt Ihnen nicht; Sie möchten diese Ergebnisse selbst überprüfen können.

Was tun Sie also als Nächstes?  Als ersten Schritt beschließen Sie, in einigen der Originalarbeiten zu den Sie interessierenden Theoremen nachzuschlagen, oder besser noch, sich einige Standardlehrbücher auf diesem Gebiet zu beschaffen.  Sie schlagen ein Theorem nach, das Sie verstehen wollen.  Natürlich steht es da, aber es wird mit seltsamen Begriffen und merkwürdigen Symbolen ausgedrückt, die für Sie absolut nichts bedeuten.  Es könnte genauso gut in einer Fremdsprache geschrieben sein, die Sie noch nie gesehen haben und deren Symbole Ihnen völlig fremd sind.
Sie sehen sich den Beweis an und haben nicht die leiseste Ahnung, was die einzelnen Schritte bedeuten, geschweige denn, wie ein Schritt auf den anderen folgt.  Nun, offensichtlich müssen Sie eine Menge lernen, wenn Sie diese Dinge verstehen wollen.

Sie denken, dass Sie es wahrscheinlich verstehen könnten, wenn Sie noch einmal drei bis sechs Jahre zur Uni gehen und ein Mathematikstudium absolvieren.  Aber das passt nicht zu Ihrer Karriere und den anderen Dingen in Ihrem Leben und würde keinen praktischen Nutzen bringen.  Sie beschließen, einen schnelleren Weg zu suchen.  Sie denken sich, Sie gehen einfach zurück zum Anfang, Schritt für Schritt, wie bei einem Computerprogramm, bis Sie es verstehen.  Aber Sie stellen schnell fest, dass dies nicht möglich ist, da Sie nicht einmal genug verstehen, um zu wissen, wohin man zurückgehen muss.

Vielleicht ist ein anderer Ansatz angebracht - vielleicht sollte man am Anfang beginnen und sich hocharbeiten.  Zuerst lesen Sie die Einleitung des Buches um herauszufinden, was die Voraussetzungen dafür sind.  Auf ähnliche Art und Weise verfolgen Sie Ihren Weg durch zwei oder drei weitere Bücher zurück und stoßen schließlich auf eines, das am Anfang zu stehen scheint: Es listet die Axiome der Arithmetik auf.  "`Aha!"', denken Sie naiv, "`Das muss der Ausgangspunkt sein, die Quelle allen mathematischen Wissens"'. Oder zumindest der Ausgangspunkt für die Mathematik, die sich mit Zahlen befasst; irgendwo muss man ja anfangen, und man hat keine Ahnung, wo der Ausgangspunkt für eine andere Mathematik sein könnte.  Aber das Wort "`Axiome"' sieht vielversprechend aus.  Also liest man eifrig weiter und arbeitet sich durch einige elementare Übungen am Anfang des Buches durch.  Sie fühlen sich vage beunruhigt: Diese scheinen überhaupt nicht wie Axiome zu sein, zumindest nicht in dem Sinne, den Sie sich vorstellen, wenn Sie an Axiome denken.  Axiome implizieren einen Ausgangspunkt, von dem aus alles andere nach genauen, im Axiomensystem festgelegten Regeln aufgebaut werden kann.  Auch wenn Sie die ersten Beweise auf informelle Weise verstehen können, und in der Lage sind, einige der Übungen zu erledigen, ist es schwer, die Regeln genau auszumachen.   Sicher, jeder Schritt scheint logisch aus den anderen zu folgen, aber was bedeutet das genau?  Ist die "`Logik"' nur eine Frage des gesunden Menschenverstands, etwas Unbestimmtes, das wir alle verstehen, aber nie ganz genau benennen können?

Sie haben einige Jahre - mit Unterbrechungen - damit verbracht Computer zu programmieren, und Sie wissen, dass es bei Computersprachen keine Frage nach den Regeln gibt - sie sind präzise und kristallklar.  Wenn Sie sie befolgen, wird Ihr Programm funktionieren, und wenn Sie es nicht tun, wird es nicht funktionieren.  Egal wie komplex ein Programm ist, es kann jederzeit in immer einfachere Teile zerlegt werden, bis man schließlich die Bits identifizieren kann, die herumgeschoben werden, um eine bestimmte Funktion auszuführen.  Einige Programme erfordern vielleicht viel Ausdauer, um sie zu schreiben, aber wenn Sie sich auf einen bestimmten Teil konzentrieren, müssen Sie nicht einmal unbedingt wissen, wie der Rest des Programms funktioniert. Sollte es nicht eine Analogie in der Mathematik geben?

Sie beschließen, den ultimativen Test durchzuführen: Sie fragen sich, wie ein Computer überprüfen oder sicherstellen könnte, dass die Schritte in diesen Beweisen aufeinander aufbauen.
Sicherlich muss die Mathematik mindestens genauso genau definiert sein wie eine Computersprache, wenn nicht sogar noch präziser; schließlich basiert die Informatik selbst auf ihr.
Wenn man einen Computer dazu bringen kann, diese Beweise zu überprüfen, dann sollte man im Grunde ebenfalls in der Lage sein, sie im Prinzip auch selbst kristallklar, in einer präzisen Weise zu verstehen.

Sie werden überrascht sein: Sie können sich keine Vorgehensweise vorstellen, wie Sie die Beweise, die in deutscher oder englischer Sprache abgefasst sind, in eine Form bringen können, die der Computer versteht.
Die Beweise sind voll von Sätzen wie "`Angenommen, es gibt ein eindeutiges $x$\ldots"' und "`Bei einem beliebigen $y$ sei $z$ eine solche Zahl, dass\ldots"' Das ist nicht die Art von Logik, die man aus der Computerprogrammierung kennt, wo sich alles, sogar die Arithmetik, auf boolesche Einsen und Nullen reduziert, wenn man sie nur ausreichend aufschlüsselt.  Auch wenn Sie glauben, dass Sie die Beweise verstehen, scheint eine Art höheres Denken notwendig zu sein und nicht präzise Regeln, die festlegen, wie man die Symbole in den Axiomen manipuliert.  Was auch immer es ist, es ist einfach nicht offensichtlich, wie man es einem Computer gegenüber ausdrücken würde, und je mehr man darüber nachdenkt, desto verwirrter wird man. Schließlich gelangt man zu einem Punkt, an dem man sich sogar fragt, ob man es wirklich versteht.  Es steckt viel mehr hinter diesen Axiomen der Arithmetik, als man auf den ersten Blick sieht.

Darüber hat in der Schule in den naturwissenschaftlichen Fächern nie jemand gesprochen.  Sie haben nur die Regeln gelernt, die man Ihnen vorgab, ohne ganz zu verstehen, wie oder warum sie funktionierten.  Manchmal waren Sie vage misstrauisch oder unsicher, und haben durch Hausaufgaben und Übertragung von dem Präsentierten gelernt, wie man Lösungen präsentiert, die den Dozenten zufriedenstellten und Ihnen eine "`1"' einbrachten.  Selten hat man tatsächlich etwas auf rigorose Weise "`bewiesen"', und die Mathe-Studenten, die so etwas taten, schienen in einer anderen Welt zu leben.

Natürlich gibt es Computeralgebra-Programme, die Mathematik betreiben können, und zwar ziemlich beeindruckend.  Sie können im Handumdrehen die Integrale lösen, mit denen man in dem Fach Infinitesimalrechnung zu kämpfen hatte, und können noch viel, viel mehr.  Aber wenn man diese Programme anschaut, sieht man eine große Sammlung von Algorithmen und Techniken, die im Laufe der Zeit weiterentwickelt und ergänzt wurden, zusammen mit grundlegender Software, die Symbole manipuliert.  Jeder eingebaute Algorithmus ist das Ergebnis eines Theorems, dessen Beweis weggelassen wurde; man muss nur derjenigen Person vertrauen, die ihn bewiesen hat, und der Person, die ihn einprogrammiert hat, und hoffen, dass es keine Bugs gibt.\index{Programmfehler}\index{Bug} Irgendwie scheint dies nicht die Essenz der Mathematik zu sein.  Obwohl Computeralgebrasysteme Theoreme mit erstaunlicher Geschwindigkeit generieren können, können sie nicht ein einziges davon wirklich beweisen.

Nach einigem Grübeln schauen Sie sich einige populäre Bücher darüber an, worum es in der Mathematik geht.  Irgendwo liest man, dass die gesamte Mathematik eigentlich von etwas abgeleitet ist, das sich "`Mengenlehre"' nennt.  Das ist ein wenig verwirrend, denn in dem Buch, in dem die Axiome der Arithmetik vorgestellt werden, wird nirgends die Mengenlehre erwähnt, oder wenn, dann nur als ein Werkzeug, das hilft, Dinge besser zu beschreiben - die Menge der geraden Zahlen und so weiter.  Wenn Mengenlehre die Grundlage für die gesamte Mathematik ist, warum werden dann zusätzliche Axiome für die Arithmetik benötigt?

Irgendetwas stimmt nicht, aber Sie sind sich nicht sicher, was.  Einer Ihrer Freunde ist ein reiner Mathematiker.  Er weiß, dass er nicht in der Lage ist, Ihnen mitzuteilen, womit er sein Geld verdient und er scheint wenig Interesse daran zu haben, es zu versuchen.  Sie wissen aber, dass für ihn Beweise das sind, worum es in der Mathematik geht. Sie fragen ihn, was ein Beweis ist, und er sagt Ihnen, dass er zwar auf Logik basiert, aber dass das Beweisen eigentlich etwas ist, das man lernt, indem man es immer und immer wieder macht, bis man es kapiert hat.  Er verweist auf ein Buch, {\em How to Read and Do Proofs} \cite{Solow}.\index{Solow, Daniel}  Obwohl dieses Buch Ihnen hilft, traditionelle informelle Beweise zu verstehen, gibt es immer noch etwas, das Sie noch nicht ganz begreifen können.

Sie fragen Ihren Freund, wie Sie einen Beweis von einem Computer überprüfen lassen würden.
Zuerst scheint er über die Frage verwirrt zu sein; warum sollte man das tun?
Dann sagt er, dass es keinen Sinn ergeben würde, aber er hat gehört, dass man den Beweis in Tausende oder sogar Millionen von Einzelschritten zerlegen müsste, um so etwas zu tun, weil die damit verbundenen Überlegungen auf einer so hohen Abstraktionsebene liege.  Er sagt, dass man so etwas vielleicht bis zu einem gewissen Punkt machen könne, aber dass der Computer völlig unpraktisch wäre, sobald man in eine sinnvolle Mathematik einsteigt.  Dort kann man einen Beweis nur noch von Hand verifizieren, und die Fähigkeit dazu kann man nur erwerben, wenn man sich ein paar Jahre lang in der Universität auf das Gebiet spezialisiert.  Wie auch immer, er glaubt, dass das alles mit der Mengenlehre zu tun hat, obwohl er nie einen formalen Kurs im Fach Mengentheorie belegt hat, sondern sich das, was er brauchte, einfach nach und nach angeeignet hat.

Sie sind fasziniert und erstaunt.  Offenbar kann ein Mathematiker mit einem einzigen Konzept etwas erfassen, für das ein Computer tausend oder eine Million Schritte benötigen würde, um es zu verifizieren, und er hat volles Vertrauen darin.  Jeder einzelne dieser Schritte muss absolut korrekt sein, sonst ist der ganze Beweis sinnlos.  Wenn Sie eine Million Zahlen von Hand addieren würden, würden Sie dem Ergebnis vertrauen?  Woher wissen Sie wirklich, dass all diese Schritte korrekt sind, dass es in einem dieser Millionen Schritte nicht irgendeinen subtilen Fallstrick gibt, wie einen Bug in einem Computerprogramm?\index{Programmfehler}\index{Bug}  Immerhin haben Sie gelesen, dass berühmte Mathematiker gelegentlich Fehler gemacht haben, und Sie wissen sicherlich, dass Sie bei Ihren Mathehausaufgaben in der Schule auch schon Fehler gemacht haben.

Sie erinnern sich an die Analogie mit einem Computerprogramm.  Sicher, Sie können verstehen, was ein großes Computerprogramm (z.~B. ein Textverarbeitungsprogramm) tut, als ein einziges hochrangiges Konzept oder eine kleine Menge solcher Konzepte, aber Ihre Fähigkeit, es zu verstehen, garantiert keineswegs, dass das Programm korrekt ist und keine versteckten Fehler enthält.  Sogar wenn Sie das Programm selbst geschrieben haben, können Sie das nicht wirklich wissen; die meisten großen Programme, die Sie geschrieben haben, hatten Fehler, die zu einem späteren Zeitpunkt auftauchten, egal wie sorgfältig Sie beim Schreiben waren.

Also gut, es scheint nun also, dass der Grund dafür ist, warum Sie nicht herausfinden können, wie man einen Computer Beweise verifizieren lassen kann, dass jeder Schritt in Wirklichkeit einer Million kleiner Schritte entspricht.  Nun, Sie mögen sagen, ein Computer könne eine Million Berechnungen in einer Sekunde durchführen, also wäre es vielleicht trotzdem praktisch.  Jetzt ist es also eine Rätselaufgabe, wie man die eine Million Schritte, die jedem der Schritte in deutscher oder englischer Sprache entsprechen, herausfinden kann.  Ihr mathematischer Freund hat keine Ahnung, schlägt aber vor, dass man die Antwort vielleicht durch das Studium der Mengenlehre fände.  Eigentlich findet Ihr Freund, dass Sie ein bisschen verrückt sind, dass Sie sich so etwas überhaupt fragen.  Für ihn ist das nicht das, worum es in der Mathematik geht.

Das Thema Mengenlehre taucht immer wieder auf, also beschließen Sie, dass es an der Zeit ist, es sich genauer anzuschauen.

Sie beschließen, vorsichtig anzufangen, und beginnen mit der Lektüre einiger sehr elementarer Bücher über Mengenlehre.  Vieles davon scheint ziemlich offensichtlich zu sein, wie Schnittmengen, Teilmengen und Venn-Diagramme.  Sie blättern durch eines der Bücher; nirgends werden Axiome erwähnt. Ein anderes Buch verweist auf einen Anhang, eine kurze Diskussion, in der eine Reihe von Axiomen erwähnt wird, die "`Zermelo--Fraenkel-Mengenlehre"'\index{Zermelo--Fraenkel-Mengenlehre} und gibt sie auf Deutsch oder Englisch wieder.  Man sieht sie sich an und hat keine Ahnung, was sie wirklich bedeuten oder was man mit ihnen anfangen kann.  Die Kommentare in diesem Anhang besagen, dass ihre Erwähnung dazu diene, Sie mit der Idee vertraut zu machen, dass sie aber für das grundlegende Verständnis nicht notwendig seien und dass sie eigentlich Gegenstand fortgeschrittener Abhandlungen sind, in denen Feinheiten wie ein bestimmtes Paradoxon (Russells Paradoxon\index{Russells Paradoxon}\footnote{Russells Paradoxon setzt voraus, dass es eine Menge $S$ gibt, die eine Sammlung aller Mengen ist, die sich selbst nicht enthalten.  Also, entweder enthält $S$ sich selbst oder nicht.  Enthält diese Menge sich selbst, widerspricht sie ihrer Definition.  Enthält sie sich aber nicht selbst, widerspricht sie ebenso ihrer Definition.  Das Russellsche Paradoxon wird in der ZF-Mengenlehre Theorie aufgelöst, indem man ausschließt, dass eine solche Menge $S$ existiert.}) gelöst werden.  Moment mal - sollten die Axiome nicht ein Ausgangspunkt und kein Endpunkt sein?  Wenn es Paradoxien gibt, welche ohne die Axiome entstehen, woher weiß man dann, dass man nicht zufällig über eines stolpert, wenn man den informellen Ansatz verwendet?

Und nirgends wird in diesen Büchern beschrieben, wie sich "`die gesamte Mathematik aus der Mengenlehre ableiten lässt"', was Sie inzwischen schon ein paar Mal gehört haben.

Sie finden ein fortgeschritteneres Buch über Mengenlehre.  Dieses Buch listet die
Axiome der ZF-Mengentheorie in einfachem Deutsch oder Englisch auf Seite eins auf.  {\em Jetzt} denken Sie, Ihre Suche sei zu Ende und Sie haben endlich die Quelle allen mathematischen Wissens gefunden; Sie müssen nur noch verstehen, was sie bedeuten.  Hier, an einem einzigen Ort, ist die Grundlage für die gesamte Mathematik!  Sie starren voller Ehrfurcht auf die Axiome, rätseln über sie, lernen sie auswendig und hoffen, dass sie Ihnen klar werden, wenn Sie nur lange genug über sie nachdenken.  Natürlich haben Sie nicht die geringste Ahnung, wie der Rest der Mathematik von ihnen "`abgeleitet"' ist; insbesondere, wenn dies die Axiome der Mathematik sind, warum brauchen dann Arithmetik, Gruppentheorie und so weiter ihre eigenen Axiome?
	
Sie fangen an, dieses fortgeschrittene Buch sorgfältig zu lesen, und denken über die Bedeutung jedes Wortes nach, denn Sie wollen der Sache unbedingt auf den Grund gehen.
Das erste, was das Buch tut, ist zu erklären, wie die Axiome zustande gekommen sind, nämlich um das Russellsche Paradoxon zu lösen.  In der Tat scheint das der Hauptzweck ihrer Existenz zu sein; dass sie angeblich dazu verwendet werden können, die gesamte Mathematik abzuleiten, scheint irrelevant zu sein und wird nicht einmal erwähnt.  Wie dem auch sei, Sie fahren fort.  Sie hoffen, dass das Buch Ihnen klar und deutlich, Schritt für Schritt, erklären wird, wie man die Dinge aus den Axiomen ableitet.  Schließlich ist dies der Ausgangspunkt der Mathematik, so wie ein Buch, das die Grundlagen einer Programmiersprache erklärt.  Aber irgendetwas fehlt.  Sie können nicht einmal den ersten Beweis verstehen oder die erste Übung machen.  Symbole wie $\exists$ und $\forall$ durchziehen die Seite, ohne dass erwähnt wird, woher sie kommen oder wie man sie manipuliert. Der Autor geht davon aus, dass man mit ihnen völlig vertraut ist, und sagt Ihnen nicht einmal, was sie bedeuten.  Inzwischen wissen Sie, dass $\exists$ "`es gibt"' bedeutet und dass $\forall$ "`für alle"' bedeutet, aber sollten nicht die Regeln für die Manipulation dieser Symbole Teil der Axiome sein?  Sie haben immer noch keine Idee, wie man die Axiome überhaupt einem Computer beschreiben könnte.
	
Sicherlich gibt es hier etwas ganz anderes als die technische Literatur, die Sie zu lesen gewohnt sind.  In einem Handbuch für Computersprachen wird fast immer sehr deutlich, was alle Symbole bedeuten, was sie genau machen und welche Regeln es gibt, nach denen sie kombiniert werden, und man arbeitet sich von dort aus weiter vor.

Nach einem Blick in vier oder fünf andere Bücher dieser Art kommt man zu der Erkenntnis, dass es noch ein ganzes Studienfach gibt, das man braucht, um die Axiome der Mengenlehre zu verstehen.  Dieses Gebiet wird "`Logik"' genannt.  In der Tat wurde es in einigen Büchern als Voraussetzung empfohlen, aber man hat es einfach nicht realisiert.  Man nahm an, Logik sei, nun ja, einfach nur Logik, etwas, das ein Mensch mit gesundem Menschenverstand intuitiv versteht.  Warum Ihre Zeit mit der Lektüre langweiliger Abhandlungen über symbolische Logik verschwenden, die Manipulation von 1en und 0en, die Computer machen, wenn man das schon weiß?  Aber dies ist eine andere Art von Logik, die Ihnen völlig fremd ist.  Das Thema von {\sc nand} und {\sc nor}-Gattern wird nicht einmal berührt oder hat ohnehin nur mit einem sehr kleinen Teil dieses Bereichs zu tun.

Ihre Suche geht also weiter.  Wenn Sie die ersten einführenden Bücher überfliegen, bekommen Sie eine allgemeine Vorstellung davon, worum es in der Logik geht und was Quantoren ("`Für alle"', "`Es gibt"') bedeuten, aber Sie finden die Beispiele etwas trivial und leicht nervig ("`Alle Hunde sind Tiere"', "`Einige Tiere sind Hunde"' und so weiter).  Aber alles, was Sie wissen wollen, sind die Regeln für die Manipulation der Symbole, damit man sie in der Mengenlehre anwenden kann.  Einige Formeln, die die Beziehungen zwischen den Quantoren ($\exists$ und $\forall$) beschreiben, sind in Tabellen aufgelistet, zusammen mit einigen verbalen Begründungen, um sie zu rechtfertigen.
Wenn Sie herausfinden wollen, ob eine Formel richtig ist, durchlaufen Sie vermutlich die gleiche Art von Denkprozessen, möglicherweise mit Bildern von Hunden und Tieren.  Intuitiv scheinen die Formeln einen Sinn zu ergeben.  Aber wenn Sie sich fragen "`Was sind die Regeln, die ich brauche, um einen Computer dazu zu bringen, herauszufinden, ob diese Formel richtig ist?"', wissen Sie es immer noch nicht.  Man bittet den Computer ja auch nicht, sich Hunde und Tiere vorzustellen.

Sie sehen sich einige fortgeschrittenere Logikbücher an.  Viele von ihnen haben ein einführendes Kapitel mit einer Zusammenfassung der Mengenlehre, was sich als Voraussetzung erweist.  Sie brauchen Logik, um die Mengenlehre zu verstehen, aber anscheinend braucht man auch die Mengenlehre, um Logik zu verstehen!  Diese Bücher stürzen sich gleich auf den Beweis von ziemlich fortgeschrittenen Theoremen über Logik, ohne den geringsten Hinweis darauf zu geben, woher die Logik kommt, mit der sie diese Theoreme beweisen können.

Glücklicherweise stoßen Sie auf ein elementares Buch über Logik, das nach der Hälfte der Lektüre, nach den üblichen Wahrheitstabellen und Metaphern, auf klare und präzise Weise präsentiert, wonach Sie die ganze Zeit gesucht haben: die Axiome!  Sie sind unterteilt in Aussagenlogik (auch Satzlogik genannt) und Prädikatenlogik (auch Logik erster Ordnung genannt),\index{Logik erster Ordnung} mit Regeln, die so einfach und kristallklar sind, dass man jetzt endlich einen Computer programmieren kann, um sie zu verstehen.  Sie sind in der Tat nicht schwieriger als das Erlernen einer Schachpartie.
Soweit es um das geht, was Sie zu brauchen scheinen, hätte man das ganze Buch auf fünf Seiten schreiben können!

{\em Jetzt} glauben Sie, die ultimative Quelle der mathematischen Wahrheit gefunden zu haben.  Also - die Axiome der Mathematik bestehen aus den Axiomen der Logik, zusammen mit den Axiomen der ZF-Mengentheorie. (Inzwischen haben Sie auch herausgefunden wie man die ZF-Axiome aus dem Deutschen oder Englischen in die eigentlichen Symbole der Logik übersetzen kann, die Sie nun nach präzisen, leicht verständlichen Regeln manipulieren können.)

Natürlich verstehen Sie immer noch nicht, wie "`die gesamte Mathematik aus der Mengenlehre abgeleitet werden kann"', aber vielleicht wird sich das zu gegebener Zeit offenbaren.
	
Sie machen sich eifrig daran, die Axiome und Regeln in einen Computer zu programmieren und beginnen sich mit den Theoremen zu befassen, die Sie beweisen müssen, während die Logik entwickelt wird.  Alle Arten von wichtigen Theoremen tauchen auf: das Deduktionstheorem\index{Deduktionstheorem}, das Substitutionstheorem\index{Substitutionstheorem}, der Vollständigkeitssatz der Aussagenlogik\index{Vollständigkeitssatz der Aussagenlogik}, der Vollständigkeitssatz der Prädikatenlogik.
Oh-oh, da scheint es Probleme zu geben.  Sie werden alle schwieriger und schwieriger, und nicht eine davon kann mit den Axiomen und Regeln der Logik, die Sie gerade erhalten haben, abgeleitet werden.  Stattdessen benötigen sie alle eine "`Metalogik"' für ihre Beweise, eine Art Mischung aus Logik und Mengenlehre, die es erlaubt, Dinge {\em über} die Axiome und Theoreme der Logik zu beweisen, anstatt {\em mit} ihnen.

Sie machen trotzdem weiter.  Einen Monat später haben Sie einen Großteil Ihrer Freizeit damit verbracht, den Computer dazu zu bringen, Beweise in der Aussagenlogik zu verifizieren.
Sie haben die Axiome einprogrammiert, aber Sie mussten auch den Deduktionssatz, den Substitutionssatz und den Satz von der Vollständigkeit der Aussagenlogik einprogrammieren, da Sie sich inzwischen damit abgefunden haben, diese Sätze als ziemlich komplexe Zusatzaxiome zu betrachten, da sie nicht aus den Axiomen bewiesen werden können.  Sie können nun den Computer dazu bringen, vollständige, strenge, formale Beweise\index{formaler Beweis} zu überprüfen und sogar zu erzeugen.  Es macht nichts, dass die Beweise 100.000 Schritte haben können - zumindest können Sie jetzt vollständiges, absolutes Vertrauen in sie haben.  Leider sind die einzigen Theoreme, die Sie bewiesen haben, ziemlich trivial, und Sie können sie in wenigen Minuten mit Wahrheitstabellen überprüfen, wenn nicht sogar durch direkte Überprüfung.

Es sieht so aus, als hätte Ihr Freund, der Mathematiker, recht gehabt.  Den Computer dazu zu bringen, ernsthafte Mathematik mit dieser Art von Strenge zu betreiben, scheint fast aussichtslos.  Sogar schlimmer noch, je weiter man kommt, desto mehr "`Axiome"' muss man hinzufügen, da jedes neue Theorem zusätzliche "`metamathematische"' Argumentation zu beinhalten scheint, die nicht formalisiert wurde, und nichts davon lässt sich aus den Axiomen der Logik ableiten.  Nicht nur, dass die Beweise exponentiell wachsen, je weiter man kommt, sondern auch das Programm zu ihrer Verifizierung wird immer größer, je mehr "`Metatheoreme"'\index{Metatheorem}\footnote{Ein Metatheorem ist normalerweise eine Aussage, die zu allgemein ist, um direkt in einer Theorie bewiesen werden zu können.  Zum Beispiel: "`Wenn $n_1$, $n_2$ und $n_3$ ganze Zahlen sind, dann ist $n_1+n_2+n_3$ eine ganze Zahl"' ist ein Satz der Zahlentheorie.  Aber "`für jede ganze Zahl $k > 1$, wenn $n_1, \ldots, n_k$ ganze Zahlen sind, dann ist $n_1+\ldots +n_k$ eine ganze Zahl"' ist ein Metatheorem, das heißt eine Familie von Theoremen, eines für jedes $k$.  Warum dies kein Theorem ist, ist darin begründet, dass die allgemeine Summe $n_1+\ldots +n_k$ (als Funktion von $k$) keine Operation ist, die direkt in der Zahlentheorie definiert werden kann.} man einprogrammiert. Die bisher aufgetauchten Fehler in Ihrem Computerprogramm haben Sie bereits dazu gebracht, den Glauben an die Strenge zu verlieren, die Sie scheinbar erreicht haben, und Sie wissen, dass es nur noch schlimmer wird, je größer Ihr Programm wird.

\subsection{Mathematik und der Nichtfachmann}

\begin{quote}
  {\em Ein echter Beweis ist nicht von einer Maschine überprüfbar, und sogar nicht von einem Mathematiker, wenn er nicht in die Gestalt, die Denkweise des speziellen Bereichs der Mathematik eingeweiht ist, in dem der Beweis angesiedelt ist.}
  \flushright\sc  Davis und Hersh\index{Davis, Phillip J.}
  \footnote{Frei übersetzt nach \cite{Davis}, S.~354.}\\
\end{quote}

Der größte Teil der abstrakten oder theoretischen Mathematik liegt in der Regel außerhalb der Reichweite aller, mit Ausnahme von nur wenigen Spezialisten auf dem jeweiligen Gebiet, die eine notwendige, schwierige Ausbildung absolviert haben, um in diesen Kreis aufgenommen zu werden.  Der typisch intelligente Laie hat keine begründete Hoffnung, viel davon zu verstehen, und auch der spezialisierte Mathematiker hat keine Chance, andere Bereiche zu verstehen.
Es ist wie eine Fremdsprache, für die es kein Wörterbuch gibt, um die Übersetzung nachzuschlagen; die einzige Möglichkeit sie zu lernen besteht darin, ein paar Jahre in dem jeweiligen Land zu leben.
Der Aufwand, der mit dem Erlernen eines Fachgebiets verbunden ist, wird als ein notwendiger Prozess angesehen, um ein tiefes Verständnis zu erlangen.  Natürlich gilt dies sicherlich, wenn man einen bedeutenden Beitrag zu einem Fachgebiet leisten will; insbesondere Beweise zu "`führen"', was wahrscheinlich der wichtigste Teil der Ausbildung eines Mathematikers ist.  Aber ist es auch notwendig, Außenstehenden den Zugang dazu zu verwehren?  Ist es notwendig, dass abstrakte Mathematik für einen Laien so schwer zu begreifen ist?

Ein Computer ist normalerweise überhaupt keine Hilfe.  Die meisten veröffentlichten Beweise sind eigentlich nur eine Reihe von Hinweisen, die in einem informellen Stil geschrieben sind, der ein beträchtliches Wissen auf dem Gebiet erfordert, um sie zu verstehen.  Dies sind die "`echten Beweise"', auf die Davis und Hersh hinweisen\index{informeller Beweis}. Es gibt eine implizite Übereinkunft darüber, dass ein solcher Beweis im Prinzip in einen vollständigen formalen Beweis umgewandelt werden kann.
Es heißt jedoch, dass niemand eine solche Umwandlung jemals versuchen würde, selbst wenn er es könnte, denn das würde vermutlich Millionen von Schritten erfordern (Abschnitt~\ref{dream}).  Leider schließt der informelle Stil automatisch das Verstehen des Beweises für jeden aus, der nicht die notwendige Ausbildung durchlaufen hat.  Es bleibt einem intelligenten Laien nichts anderes übrig als populäre Bücher über tiefe und berühmte Ergebnisse zu lesen; dies kann zwar hilfreich, aber auch irreführend sein, und der Mangel an Details lässt den Leser in der Regel ohne jegliche Möglichkeit zurück, einen Aspekt des beschriebenen Bereichs zu erforschen.

Die Aussagen der Theoreme verwenden oft eine komplizierte Notation, die sie für den Nichtfachmann unzugänglich machen.  Für einen Nichtfachmann, der einen Beweises genauer verstehen möchte, wird der Prozess der Rückverfolgung von Definitionen und Lemmata durch ihre Hierarchie schnell verwirrend und entmutigend.  Lehrbücher werden normalerweise geschrieben, um Mathematiker auszubilden oder um Mathematikern neues Wissen zu vermitteln, und große Lücken in Beweisen werden oft dem Leser als Aufgabe überlassen, der in eine Sackgasse gerät, wenn er oder sie damit nicht weiterkommt.

Ich glaube, dass Computer es irgendwann auch Nichtfachleuten und sogar intelligenten Laien ermöglichen, fast jeden mathematischen Beweis auf jedem Gebiet nachvollziehen zu können.
Metamath ist ein Ansatz in diese Richtung.  Wäre die gesamte Mathematik so leicht zugänglich wie eine Computerprogrammiersprache, könnte ich mir vorstellen, dass es Computerprogrammierern und Hobbyisten, denen es sonst an mathematischer Raffinesse fehlt, die Welt der Theoreme und Beweise in obskuren Fachgebieten zu erkunden und darüber zu staunen.  Vielleicht gelingt es ihnen dann sogar, eigene Ergebnisse zu finden.  Ein enormer Vorteil wäre, dass jeder mit Vermutungen auf jedem Gebiet experimentieren könnte - der Computer würde eine sofortige Rückmeldung darüber geben, ob ein Schritt in einer Schlussfolgerung korrekt ist.

Mathematiker müssen manchmal das Ärgernis über Spinner\index{Spinner} ertragen, denen es an einem grundlegenden Verständnis der Mathematik mangelt, die aber darauf bestehen, dass ihre Beweise für, sagen wir, den Großen Fermatschen Satz\index{Großer Fermatscher Satz}, ernst genommen werden.  Ich denke, ein Teil des Problems ist, dass diese Leute von der informellen mathematischen Sprache in die Irre geführt werden und sie so behandeln, als ob sie gewöhnliches, erklärendes Deutsch oder Englisch lesen würden, und nicht die implizit zugrunde liegende Strenge beachten.  Solche Verrückten sind im Bereich der Computer selten, denn Computersprachen sind viel expliziter, und der Beweis liegt letztlich darin, ob ein Computerprogramm funktioniert oder nicht.  Mit leicht zugänglicher, computergestützter abstrakter Mathematik könnte ein Mathematiker zu einem Verrückten sagen, "`Belästigen Sie mich nicht, bis Sie Ihre Behauptung auf dem Computer bewiesen haben!"'

% 22-May-04 nm
% Attempt to move De Millo quote so it doesn't separate from attribution
% CHANGE THIS NUMBER (AND ELIMINATE IF POSSIBLE) WHEN ABOVE TEXT CHANGES
\vspace{-0.5em}

\subsection{Ein unmöglicher Traum?}\label{dream}

\begin{quote}
  {\em Die Darstellung der Beweise selbst ganz einfacher Theoreme würde unglaublich umfangreiche Bücher füllen.}
    \flushright\sc  Robert E. Edwards\footnote{Frei übersetzt nach \cite{Edwards}, S.~68.}\\
\end{quote}\index{Edwards, Robert E.}

\begin{quote}
  {\em Oh, natürlich {\em macht} das nie jemand wirklich.  Das würde ewig dauern!  Du zeigst nur, dass du es könntest, das reicht aus.}
    \flushright\sc  "`Der ideale Mathematiker"'
    \index{Davis, Phillip J.}\footnote{Frei übersetzt nach \cite{Davis},
\sc  "`The Ideal Mathematician"' S.~40.}\\
\end{quote}

\begin{quote}
  {\em Es gibt ein Theorem in der elementaren Notation der Mengenlehre, das dem arithmetischen Theorem `$1000+2000=3000$' entspricht.  Die Formel wäre furchtbar lang, denn selbst wenn [man] die Definitionen kennt und gebeten wird, die lange Formel entsprechend zu vereinfachen, wird man wahrscheinlich Fehler machen und zu einem falschen Ergebnis kommen.}
    \flushright\sc  Hao Wang\footnote{Frei übersetzt nach \cite{Wang}, S.~140.}\\
\end{quote}\index{Wang, Hao}

% 22-May-04 nm
% Attempt to move De Millo quote so it doesn't separate from attribution
% CHANGE THIS NUMBER (AND ELIMINATE IF POSSIBLE) WHEN ABOVE TEXT CHANGES
\vspace{-0.5em}

\begin{quote}
  {\em {\em Die Principia Mathematica} war die krönende Leistung der Formalisten.  Es war auch der Todesstoß für die formalistische Sichtweise. \ldots {[Rus\-sell]} gelang es in drei riesigen Bänden nicht, über die elementaren Fakten der Arithmetik hinauszukommen.  Er zeigte, was prinzipiell möglich ist und was in der Praxis nicht möglich ist.  Wäre der mathematische Prozess wirklich eine streng logische Abfolge, dann würden wir immer noch unsere Finger zählen. \ldots Ein Theoretiker schätzt\ldots, dass die Darstellung einer von Ramanujans Vermutungen mithilfe der Mengenlehre und elementarer Analysis etwa zweitausend Seiten umfassen würde; die Länge einer Ableitung aus ersten Prinzipien ist fast unvorstellbar \ldots Die Wahrscheinlichkeitstheoretiker argumentieren, dass \ldots jeder sehr lange Beweis bestenfalls als "`wahrscheinlich richtig"' angesehen werden kann. \ldots}
  \flushright\sc Richard de Millo et. al.\footnote{Frei übersetzt nach \cite{deMillo}, S.~269,
  271.}\\
\end{quote}\index{de Millo, Richard}

Einige Autoren haben den Eindruck erweckt, dass die Art von absoluter Strenge, wie sie Metamath bietet, ein unmöglicher Traum ist und suggeriert, dass ein vollständiger, formaler Beweis eines typischen Theorems Millionen von Schritten in unzähligen Bänden von Büchern erfordern würde.  Selbst wenn es möglich wäre, dann wird manchmal angenommen, dass jegliche Bedeutung bei einer solchen monströsen, langwierigen Überprüfung verloren gehen würde.\index{informeller Beweis}\index{Beweislänge}

Diese Autoren gehen jedoch davon aus, dass man für eine solche Art von vollständiger, formaler Verifikation einen Beweis in einzelne primitive Schritte herunterbrechen müsse, die sich direkt auf die Axiome beziehen.  Dies ist nicht notwendig.  Es gibt keinen Grund, nicht auf bereits bewiesene Theoreme zurückzugreifen, anstatt sie immer wieder aufs Neue zu beweisen.

Genauso wichtig ist es, dass Definitionen\index{Definition} auf dem Beweisweg eingeführt werden können, so dass sehr komplexe Formeln mit wenigen Symbolen dargestellt werden können. Wird dies nicht getan, können absurd lange Formeln entstehen.  Zum Beispiel würde allein das Formulieren des Gödelschen Unvollständigkeitssatzes\index{Gödelscher Unvollständigkeitssatz}, das mit einer überschaubaren Anzahl definierter Symbole ausgedrückt werden kann, etwa 20.000 primitive Symbole erfordern\index{Boolos, George S.}\footnote{George S.\ Boolos, Vortrag am Massachusetts Institute of Technology, Frühling 1990.}.
Ein extremes Beispiel ist Bourbakis\label{bourbaki} Sprache für die Mengenlehre, die \\ 4.523.659.424.929 Symbole plus 1.179.618.517.981 "`unterscheidende Verbin\-dun\-gen"' (Linien, die Symbolpaare miteinander verbinden, die normalerweise unterhalb oder oberhalb der Formel gezogen werden) erfordert, um die Zahl "`eins"' auszudrücken \cite{Mathias}\index{Mathias, Adrian R. D.}\index{Bourbaki, Nicolas}.
% http://www.dpmms.cam.ac.uk/~ardm/

Eine Hierarchie\index{Hierarchie} von Theoremen und Definitionen ermöglicht es, dass exponentiell wachsende Formelgrößen und primitive Beweisschritte mit nur einer linear wachsenden Anzahl von verwendeten Symbole beschrieben werden können.  Natürlich ist dies die Art und Weise, wie sie auch in der gewöhnlichen, informellen Mathematik normalerweise praktiziert wird, aber mit Metamath\index{Metamath} kann dies mit absoluter Strenge und Präzision geschehen.

\subsection{Schönheit}


\begin{quote}
  {\em Aus dem Paradies, das Cantor uns geschaffen, soll uns niemand vertreiben können.}
   \flushright\sc  David Hilbert\footnote{"`Über das Unendliche"' in {\em Mathematische Annalen}, 95. Band, Verlag von Julius Springer, Berlin 1926, S. 170. Außerdem zitiert in \cite{Moore}, S.~131.}\\
\end{quote}\index{Hilbert, David}

\needspace{3\baselineskip}
\begin{quote}
  {\em Die Mathematik hat nicht nur Wahrheit inne, sondern auch eine höchste Schönheit --- eine kalte und strenge Schönheit, wie die einer Skulptur.}
    \flushright\sc  Bertrand Russell\footnote{Frei übersetzt nach \cite{Russell}.}\\
\end{quote}\index{Russell, Bertrand}

\begin{quote}
  {\em Euklid allein hat die schiere Schönheit gesehen.}
  \flushright\sc Edna Millay\footnote{Frei übersetzt nach dem Zitat in \cite{Davis}, S.~150.}\\
\end{quote}\index{Millay, Edna}

\begin{quote}
	{\em Das Wissen eines Menschen macht seine Miene strahlend, und seine strengen Züge lösen sich.}
	\flushright\sc Kohelet/Prediger 8:1\footnote{Ergänzung der Übersetzer, aus {\em Die Bibel - Einheitsübersetzung}, Katholische Bibelanstalt, 1980, Stuttgart.}\\
\end{quote}\index{Bibel}

Für die meisten Menschen ist die abstrakte Mathematik weit weg, fremd und unverständlich.  Viele populäre Bücher haben versucht, etwas von dem Sinn der Schönheit berühmter Theoreme zu vermitteln.  Aber selbst ein intelligenter Laie hat nur eine allgemeine Vorstellung davon, worum es in einem Theorem geht, und erhält kaum die Werkzeuge, die er braucht um sie zu nutzen.  Traditionell erfordert es erst ein jahrelanges, mühsames Studium, um die für ein tiefes Verständnis erforderlichen Konzepte zu erfassen.
Metamath\index{Metamath} ermöglicht es, den Beweis des Satzes aus einer ganz anderen Perspektive anzugehen, indem man die Formeln und Definitionen Schicht für Schicht auseinandernimmt, bis man ein völlig anderes Verständnis gewonnen hat.
Jeder Schritt des Beweises ist nachvollziehbar, mit absoluter Präzision zusammengesetzt, und kann sofort wie durch ein Mikroskop mit einer beliebigen Vergrößerung, so stark ist wie Sie es wünschen, weiter inspiziert werden.

Ein Beweis an sich kann als ein Kunstobjekt angesehen werden.  Das Konstruieren eines eleganten Beweis ist eine Kunst.  Sobald ein berühmtes Theorem bewiesen ist, werden oft beträchtliche Anstrengungen unternommen, um einfachere und leichter verständliche Beweise zu finden.  Das Erstellen und Vermitteln eleganter Beweise ist ein Hauptanliegen von Mathematikern.  Metamath ist eine Möglichkeit, eine gemeinsame Sprache für die Archivierung und Bewahrung dieser Informationen zu bieten.

Die Länge eines Beweises kann bis zu einem gewissen Grad als objektives Maß für seine "`Schönheit"' sein, da kürzere Beweise gewöhnlich als eleganter gelten.  In der Mengenlehre-Datenbasis\texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}%
\index{Metamath Proof Explorer}, die zusammen mit dem Metamath-Programm bereitgestellt wird, war und ist es ein Ziel, alle Beweise so kurz wie möglich zu halten.

\needspace{4\baselineskip}
\subsection{Einfachheit}

\begin{quote}
  {\em Gott hat die Menschen einfach und aufrichtig erschaffen, aber manche wollen alles kompliziert haben.}
    \flushright\sc Kohelet/Prediger 7:29\footnote{{\em Die Bibel im heutigem Deutsch}, Deutsche Bibelgesellschaft, 1982, Stuttgart. (Anm. der Übersetzer: Das hier wiedergegebene Zitat entspricht dem Zitat aus dem englischen Original; in anderen Ausgaben der Bibel wird diese Stelle häufig etwas anders übersetzt, z.B. {\em Gott hat die Menschen rechtschaffen gemacht, aber sie haben sich in allen möglichen Berechnungen versucht} in {\em Die Bibel - Einheitsübersetzung}, Katholische Bibelanstalt, 1980, Stuttgart.)}\\
\end{quote}\index{Bibel}

\needspace{3\baselineskip}
\begin{quote}
  {\em Die ganzen Zahlen hat der liebe Gott gemacht, alles andere ist Menschenwerk.}
    \flushright\sc Leopold Kronecker\footnote{{\em Jahresbericht
	der Deutschen Mathematiker-Vereinigung }, Ausg. 2, S. 19.}\\
\end{quote}\index{Kronecker, Leopold}

\needspace{3\baselineskip}
\begin{quote}
  {\em Denn das Klare und leicht Faßliche zieht uns an, das Verwickelte schreckt uns ab.}
    \flushright\sc David Hilbert\footnote{{\em Mathematische Probleme} (1900), S. 254.}\\
\end{quote}\index{Hilbert, David}

Die Metamath\index{Metamath}-Sprache ist einfach und spartanisch.  Metamath betrachtet alle mathematischen Ausdrücke als einfache Abfolgen von Symbolen, die an sich keine Bedeutung haben.
Die übergeordneten oder "`metamathematischen"' Grundsätze, auf denen Metamath basiert, sind so einfach wie möglich gehalten.  Jeder einzelne Schritt in einem Beweis basiert auf einem einzigen Grundkonzept, nämlich der Ersetzung einer Variablen durch einen Ausdruck, so dass im Prinzip fast jeder, ob Mathematiker oder nicht, komplett verstehen kann, wie er zustande gekommen ist.

Eine der grundlegendsten Anwendungen von Metamath\index{Metamath} ist die Entwicklung der Grundlagen der Mathematik\index{Grundlagen der Mathematik} von Anfang an.  Dies geschieht in der Mengenlehre-Datenbasis, die in dem  Metamath-Paket mitgeliefert wird und Gegenstand von Kapitel~\ref{fol} ist. Jede Sprache (eine Metasprache\index{Metasprache}) die zur Beschreibung der Mathematik verwendet wird (eine Objektsprache\index{Objektsprache}), muss selbst mathematische Konzepte beinhalten.  Aber es ist wünschenswert, diese Konzepte auf ein absolutes Minimum zu beschränken, nämlich auf die für die Anwendung der axiomatisch spezifizierten Inferenzregeln benötigten.  Für jede Metasprache gibt es ein "`Henne-Ei'-Problem, ähnlich wie bei einem Zirkelschluss: Man muss die Gültigkeit der Mathematik der Metasprache voraussetzen, um die Gültigkeit der Mathematik der Objektsprache zu beweisen.  Der mathematische Anteil von Metamath selbst ist recht begrenzt.  Wie die Regeln eines Schachspiels sind die  wesentlichen Konzepte so einfach, dass praktisch jeder in der Lage sein sollte, sie zu verstehen (auch wenn das an sich nicht dazu führt, dass man wie ein Meister spielt).  Die Symbole, mit denen Metamath arbeitet, haben an sich keine eigene Bedeutung.  Die Interpretation der Axiome, die Sie für Metamath festlegen, durch Sie selbst ist es, was ihnen Bedeutung verleiht.  Metamath ist ein Versuch, das mathematisches Denken auf seine pure Essenz zu reduzieren und Ihnen genau zu zeigen, wie die Symbole manipuliert werden.

Philosophen und Logiker haben es aus verschiedenen Gründen oft für wichtig gehalten, "`schwache"' Teilbereiche der Logik\index{schwache Logik}\cite{Anderson}\index{Anderson, Alan Ross} \cite{MegillBunder}\index{Megill, Norman}\index{Bunder, Martin}, andere unkonventionelle Systeme der Logik (wie z.B. "`modale"' Logik\index{modale Logik} \cite[Kap.\ 27]{Boolos}\index{Boolos, George S.}), und Quantenlogik\index{Quantenlogik} in der Physik\cite{Pavicic}\index{Pavi{\v{c}}i{\'{c}}, M.} zu untersuchen.  Metamath\index{Metamath} bietet einen Rahmen, in dem solche Systeme mit einer absoluten Präzision ausgedrückt werden können, die alle zugrundeliegenden metamathematischen Annahmen präzise und kristallklar darlegt.

Einige philosophische Denkschulen wie der Intuitionismus\index{Intuitionismus} und der Konstruktivismus\index{Konstruktivismus} fordern, dass die jedem mathematischen System zugrunde liegenden Begriffe so einfach und konkret wie möglich seien.  Metamath sollte den Anforderungen dieser Philosophien entsprechen.  Metamath muss die Symbole, Axiome\index{Axiom}, und Regeln\index{Regel} für eine bestimmte Theorie, vom Skeptischen (wie beim Intuitionismus\index{Intuitionismus}
\footnote{Der Intuitionismus akzeptiert nicht das Gesetz des ausgeschlossenen Dritten ("`entweder ist etwas wahr oder es ist nicht wahr"').  Siehe \cite[S.~xi]{Tymoczko}\index{Tymoczko, Thomas} für Diskussionen und Referenzen zu diesem Thema.  Betrachten Sie das Theorem "`Es gibt irrationale Zahlen $a$ und $b$, so dass $a^b$ rational ist"'.  Ein Intuitionist würde den folgenden Beweis ablehnen:  Wenn $\sqrt{2}^{\sqrt{2}}$ rational ist, sind wir fertig.  Ansonsten gilt $a=\sqrt{2}^{\sqrt{2}}$ und $b=\sqrt{2}$. Dann ist $a^b=2$, was eine rational Zahl ist.})
bis zum Kühnen (wie zum Beispiel das Auswahlaxiom in der Mengenlehre
\footnote{Das Auswahlaxiom\index{Auswahlaxiom} besagt, dass bei einer beliebigen Sammlung von paarweise disjunkten, nicht leeren Mengen eine Menge existiert, die mit jeder Menge der Sammlung genau ein Element gemeinsam hat.  Es wird verwendet, um viele wichtige Theoreme in der Standardmathematik zu beweisen.  Einige Philosophen lehnen es ab, weil die Existenz einer Menge behauptet wird, ohne ihre Elemente benennen zu können\cite[S.~154]{Enderton}\index{Enderton, Herbert B.}.  In einer Grundlage für die Mathematik, die auf Quine\index{Quine, Willard Van Orman} zurückgeht und sich nicht als inkonsistent erwiesen hat, erweist sich das Auswahlaxiom als falsch\cite[S.~23]{Curry}\index{Curry, Haskell B.}.  Der \texttt{show trace{\char`\_}back}-Befehl des Metamath-Programms ermöglicht es Ihnen herauszufinden, ob das Auswahlaxiom oder ein anderes Axiom in einem Beweis angenommen wurde.}\index{\texttt{show trace{\char`\_}back}-Befehl}) beigebracht werden.
	
Die Einfachheit der Metamath-Sprache erlaubt es dem Algorithmus (Computerprogramm),
der die Gültigkeit eines Metamath-Beweises verifiziert, einfach und
robust zu sein.  Sie können darauf vertrauen, dass die Theoreme, die er verifiziert, wirklich aus Ihren Axiomen abgeleitet werden können.

\subsection{Strenge}

\begin{quote}
  {\em Rigorosität wurde bei den Griechen zu einem Ziel \ldots Aber die Bemühungen, die Strenge bis zum Äußersten zu treiben, haben in eine Sackgasse geführt, in der es keine Einigung mehr darüber gibt, was sie wirklich bedeutet.  Die Mathematik bleibt lebendig und vital, aber nur auf einer pragmatischen Basis.}
    \flushright\sc  Morris Kline\footnote{Frei übersetzt nach \cite{Kline}, S.~1209.}\\
\end{quote}\index{Kline, Morris}

Kline bezieht sich auf eine viel tiefere Art von Strenge als die, die wir in diesem Abschnitt erörtern werden.  Der Gödelsche Unvollständigkeitssatz\index{Gödelscher Unvollständigkeitssatz} zeigte, dass es unmöglich ist, in der Standardmathematik absolute Strenge zu erreichen, weil wir nie beweisen können, dass die Mathematik konsistent (frei von Widersprüchen) ist.\index{konsistente Theorie}  Wenn die Mathematik konsistent ist, werden wir es nie wissen, sondern müssen uns auf den Glauben darauf verlassen.  Wenn die Mathematik inkonsistent ist, können wir bestenfalls darauf hoffen, dass in der Zukunft ein kluger Mathematiker die Inkonsistenz entdecken wird.  In diesem Fall würden die Axiome wahrscheinlich leicht überarbeitet werden, um die Inkonsistenz zu beseitigen, wie im Fall des Russell'schen Paradoxons geschehen ist. Aber der Großteil der Mathematik wäre von einer solchen Entdeckung wahrscheinlich nicht betroffen.  Das Russell-Paradoxon hatte zum Beispiel keinen Einfluss auf die meisten bemerkenswerten Ergebnisse, die von Mathematikern des 19. Jahrhunderts und früher erzielt wurden.  Es widerlegte hauptsächlich einige der Arbeiten von Gottlob Frege über die Grundlagen der Mathematik in den späten 1800er Jahren; tatsächlich inspirierte Freges Arbeit Russells Entdeckung.  Trotz dieses Paradoxons enthält Freges Werk wichtige Konzepte, die die moderne Logik maßgeblich beeinflusst haben.  Kline's {\em Mathematics, The Loss of Certainty} \cite{Klinel}\index{Kline, Morris} enthält eine interessante Diskussion zu diesem Thema.

Was mit absoluter Gewissheit\index{Gewissheit} erreicht werden {\em kann} ist das Wissen, dass unter der Annahme, dass die Axiome konsistent und wahr sind, die Ergebnisse, die aus ihnen abgeleitet werden, wahr sind.  Ein Teil der Schönheit der Mathematik ist, dass sie der einzige Bereich menschlichen Strebens ist, in dem absolute Gewissheit in diesem Sinne erreicht werden kann.  Eine mathematische Wahrheit wird bis in alle Ewigkeit wahr bleiben.  Dennoch ist unser tatsächliches Wissen darüber, ob eine bestimmte Aussage eine mathematische Wahrheit darstellt, jedoch nur so sicher wie die Korrektheit des Beweises, der dieser Aussage zugrunde liegt.
Wenn der Beweis einer Aussage fragwürdig oder vage ist, können wir nicht absolutes Vertrauen in die von der Aussage behaupteten Wahrheit haben.

Schauen wir uns einige traditionelle Arten an, Beweise auszudrücken.

Außer auf dem Gebiet der formalen Logik\index{formale Logik} sind fast alle traditionellen Beweise in der Mathematik eigentlich gar keine Beweise, sondern eher Beweisskizzen oder Hinweise darauf, wie der Beweis zu konstruieren ist.  Viele Lücken\index{Lücken in Beweisen} werden dem Leser zum Ausfüllen überlassen. Dafür gibt es mehrere Gründe.  Erstens wird in der mathematischen Literatur gewöhnlich angenommen, dass die Person, die den Beweis liest, ein Mathematiker ist, der mit dem beschriebenen Spezialgebiet vertraut ist, und dass die fehlenden Schritte für einen solchen Leser offensichtlich sind oder er zumindest in der Lage ist, sie zu ergänzen.
Diese Haltung ist für professionelle Mathematiker des Fachgebiets in Ordnung, aber leider hat sie oft den Nachteil, dass sie den Rest der Welt, einschließlich der Mathematiker anderer Fachgebiete, vom Verstehen des Beweises ausschließt.
Wir haben eine mögliche Lösung für dieses Problem auf S.~\pageref{envision} diskutiert.
Zweitens wird oft angenommen, dass ein vollständig formaler Beweis {index{formaler Beweis} unzählige Millionen von Symbolen erfordern würde (Abschnitt~\ref{dream}). Dies könnte richtig sein, wenn der Beweis direkt durch die Axiome der Logik und der Mengenlehre ausgedrückt würde.  Aber es ist normalerweise nicht richtig, wenn wir uns
eine Hierarchie von Definitionen und Theoremen erlauben, auf denen wir aufbauen können, und eine Notation verwenden, die es uns erlaubt, neue Symbole, Definitionen und Theoreme auf eine genau spezifizierte Weise einzuführen.

Selbst in der formalen Logik\index{formale Logik} enthalten formale Beweise\index{formaler Beweis}, die als vollständig angesehen werden, immer noch versteckte oder implizite Informationen.
Zum Beispiel wird ein "`Beweis"' gewöhnlich als eine Folge von wffs,\index{wohlgeformte Formel (wff)}
\footnote{Eine {\em wff} oder eine wohlgeformte Formel ist ein mathematischer Ausdruck (eine Kette von Symbolen), der nach einigen präzisen Regeln aufgebaut ist.  Ein formales mathematisches System\index{formales System} enthält (1) die Regeln für die Konstruktion von syntaktisch korrekten wffs,\index{Syntax-Regeln} (2) eine Liste von Ausgangs-wffs, genannt Axiome, \index{Axiom} und (3) eine oder mehrere Regeln, die vorschreiben, wie man neue wffs, genannt Theoreme\index{Theorem}, aus den Axiomen oder vorher abgeleiteten Theoremen ableitet.  Ein Beispiel für ein solches System ist in Metamaths\index{Metamath} Mengenlehre-Datenbasis enthalten, die ein formales System definiert, aus dem die gesamte Standardmathematik abgeleitet werden kann.
Abschnitt~\ref{startf} führt Sie durch ein vollständiges Beispiel für ein formales Systems, und Sie sollten ihn überfliegen, wenn Sie mit dem Konzept nicht vertraut sind.}
definiert, von denen jedes ein Axiom ist oder aus einer Regel folgt, die auf vorherige wffs in der Sequenz angewendet wird.  Der implizite Teil des Beweises ist der Algorithmus, mit dem eine Folge von Symbolen als gültige wff verifiziert wird, wenn die Definition einer wff gegeben ist.  Der Algorithmus ist in diesem Fall recht einfach, aber damit ein Computer den Beweis verifizieren kann, muss er den Algorithmus in sein Verifikationsprogramm eingebaut haben.
\footnote{Es ist natürlich möglich, die Syntax der wff-Konstruktion außerhalb des Programms mit einer geeigneten Eingabesprache selbst zu spezifizieren (die Metamath-Sprache ist ein Beispiel dafür), aber einige Programme zur Beweisverifikation oder zum Beweisen von Theoremen sind nicht in der Lage, die wff-Syntax auf eine solche Weise zu erweitern.}
Wenn man sich ausschließlich mit Axiomen und elementaren wffs beschäftigt, ist es einfach, einen solchen Algorithmus zu implementieren.  Aber wenn mehr und mehr Definitionen zur Theorie hinzugefügt werden, um diese kompakter zu machen, wird der Algorithmus immer komplizierter.
Ein Computerprogramm, das den Algorithmus implementiert, wird größer und mit jeder neuen Definition schwieriger zu verstehen und damit anfälliger für Bugs.  Je größer das Programm, desto misstrauischer wird der Mathematiker gegenüber der Gültigkeit seiner Algorithmen.  Dies gilt insbesondere, weil Computerprogramme von Natur aus schwer nachzuvollziehen sind, und nur wenige Menschen Spaß daran haben, sie manuell im Detail zu überprüfen.

Metamath\index{Metamath} verfolgt einen anderen Ansatz.  Das "`Wissen"' von Metamath beschränkt sich auf die Fähigkeit, Variablen durch Ausdrücke zu ersetzen, und zwar unter einigen einfachen Einschränkungen.  Sobald der grundlegende Algorithmus von Metamath als getestet und vielleicht unabhängig bestätigt wurde, kann man ihm ein für alle Mal vertrauen.  Die Informationen, die Metamath benötigt, um Mathematik zu verstehen, ist vollständig in dem Wissensbestand enthalten, der Metamath zugrunde gelegt wird.  Jegliche Fehler in der Argumentation können nur Fehler in den Axiomen oder Definitionen sein, die in diesem Wissensbestand enthalten sind.
Als eine "`konstruktive"' Sprache\index{konstruktive Sprache} hat Metamath keine bedingte Verzweigungen oder Schleifen, wie sie Computerprogramme schwer entschlüsselbar machen; stattdessen kann die Sprache nur neue Folgen von Symbolen aus vorherigen Folgen von Symbolen aufbauen.

Die Einfachheit der Regeln, die Metamath zugrunde liegen, macht Metamath nicht nur leicht zu erlernen, sondern verleiht Metamath auch ein hohes Maß an Flexibilität. Metamath ist zum Beispiel nicht auf die Beschreibung der Standardlogik erster Ordnung\index{Logik erster Ordnung} beschränkt; Logik höherer Ordnung\index{Logik höherer Ordnung (HOL)}} und Teilbereiche der Logik\index{schwache Logik} können ebenso einfach beschrieben werden.
Metamath gibt Ihnen die Freiheit, jede beliebige wff-Notation zu definieren, die Sie bevorzugen; es hat keine eingebaute Interpretation der Syntax einer wff.\index{wohlgeformte Formel (wff)} Mit geeigneten Axiomen und Definitionen kann Metamath sogar Dinge über sich selbst beschreiben und beweisen.\index{Metamath!Selbstbeschreibung} (John Harrison\index{Harrison, John} erörtert das "`Reflexions"'-Prinzip\index{Reflexionsprinzip} in selbstbeschreibenden Systemen in \cite{Harrison}.)

Die Flexibilität von Metamath erfordert, dass die Beweise sehr viele Details enthalten, viel mehr als in einem gewöhnlichen "`formalen"' Beweis.\index{formaler Beweis}
Zum Beispiel besteht in einem gewöhnlichen formalen Beweis ein einzelner Schritt aus der Anzeige der wff, die diesen Schritt darstellt.  Damit ein Computerprogramm verifizieren kann dass der Schritt gültig ist, muss es zunächst prüfen, ob die angezeigte Symbolfolge eine gültige wff\index{automatisierte Beweisverifizierung} ist. Die meisten Prüfprogramme haben zumindest eine grundlegende wff-Syntax eingebaut.
Metamath hat kein fest verdrahtetes Wissen darüber eingebaut, was eine wff ist; stattdessen muss jede wff explizit konstruiert werden, basierend auf Regeln, die in einer Datenbasis vorhanden wffs definieren.
Daher kann ein einzelner Schritt in einem gewöhnlichen formalen Beweis vielen Schritten in einem Metamath-Beweis entsprechen. Trotz der größeren Anzahl von Schritten bedeutet dies jedoch nicht, dass ein Metamath-Beweis wesentlich größer sein muss als ein gewöhnlicher formaler Beweis. Der Grund dafür ist, dass wir wissen, da wir die wff von Grund auf neu konstruiert haben, was die wff ist - also gibt es keinen Grund, sie anzuzeigen.  Wir müssen nur auf eine Folge von Aussagen verweisen, die sie konstruieren.  In gewissem Sinne ist die Darstellung der wff in einem gewöhnlichen formalen Beweis ein impliziter Beweis für seine eigene Gültigkeit als wff; Metamath macht den Beweis einfach explizit. (Abschnitt~\ref{proof} beschreibt die Beweisnotation von Metamath.)

\section{Computer und Mathematiker}

\begin{quote}
  {\em Der Computer ist wichtig, aber nicht für die Mathematik.}
  \flushright\sc  Paul Halmos\footnote{Frei übersetzt nach dem Zitat in \cite{Albers}, S.~121.}\\
\end{quote}\index{Halmos, Paul}

Reine Mathematiker stehen Computern seit jeher gleichgültig gegenüber, bis hin zur Verachtung.\index{Computer und reine Mathematik}  Die Computerwissenschaft/Informatik selbst wird manchmal in den banalen Bereich der "`angewandten"' Mathematik eingeordnet, die vielleicht für die reale Welt wichtig, aber für diejenigen, die nach den tiefsten Wahrheiten der Mathematik suchen, intellektuell wenig aufregend ist.  Vielleicht liegt ein Grund für diese Einstellung gegenüber Computern darin, dass es wenig oder gar keine Computersoftware gibt, die ihren Bedürfnissen gerecht wird, und es mag die allgemeine Meinung vorherrschen, dass eine solche Software gar nicht existieren kann.  Auf der einen Seite gibt es die praktischen Computeralgebrasysteme, die erstaunliche Symbolmanipulationen in den Bereichen Algebra und Infinitesimalrechnung\index{Computeralgebrasystem} durchführen können, aber nicht einmal den einfachsten Existenzsatz beweisen, wenn die Vorstellung eines Beweises überhaupt vorhanden ist.  Andererseits gibt es spezialisierte automatische Theorembeweiser,\index{automatisches Theorembeweisen} die technisch gesehen korrekte Beweise generieren können.  Aber manchmal sind ihre speziellen Eingabenotationen sehr kryptisch, und ihre Ausgaben werden als lange, unelegant wirkende, unverständliche Beweise wahrgenommen. 
Die Ausgabe kann mit Misstrauen betrachtet werden, da das Programm, das sie erzeugt, in der Regel sehr groß ist und seine Größe das Potenzial für Bugs\index{Programmfehler}\index{Bug} erhöht.
Ein solcher Beweis kann nur dann als vertrauenswürdig angesehen werden, wenn er von einem Menschen unabhängig verifiziert und "`verstanden"' wurde, aber niemand möchte seine Zeit mit einer solch langweiligen, undankbaren Aufgabe verschwenden.



\needspace{4\baselineskip}
\subsection{Dem Computer vertrauen}

\begin{quote}
  {\em \ldots ich halte die quasi-empirische Interpretation von Computerbeweisen nach wie vor für die plausiblere.\ldots Da nicht alles, was angeblich ein Computerbeweis ist, als gültig anerkannt werden kann, was sind die mathematischen Kriterien für akzeptable Computerbeweise?}
    \flushright\sc  Thomas Tymoczko\footnote{Frei übersetzt nach \cite{Tymoczko}, S.~245.}\\
\end{quote}\index{Tymoczko, Thomas}

In einigen Fällen waren Computer unverzichtbare Werkzeuge für den Beweis berühmter Theoreme.  Aber wenn ein Beweis so lang und obskur ist, dass er praktisch nur mit einem Computer überprüft werden kann, wird er vage als verdächtig empfunden.
Zum Beispiel der Beweis des berühmten Vier-Farben-Satzes\index{Vier-Farben-Satz}\index{Beweislänge} ("`es werden nicht mehr als vier Farben benötigt, um eine Landkarte so einzufärben, dass zwei benachbarte Länder nicht die gleiche Farbe haben"'), kann derzeit nur mit Hilfe eines sehr komplexen Computerprogramms durchgeführt werden, das ursprünglich 1200 Stunden Rechenzeit erforderte. Es hat eine beträchtliche Debatte darüber gegeben, ob man einem solchen Beweis trauen kann und ob ein solcher Beweis "`echte"' Mathematik ist \cite{Swart}\index{Swart, E. R.}.\index{Computern vertrauen}

Unter normalen Umständen würde jedoch selbst ein skeptischer Mathematiker ein sehr großes Vertrauen in das Ergebnis der Multiplikation zweier Zahlen auf einem Taschenrechner haben, auch wenn die genauen Einzelheiten des Vorgangs vor dem Benutzer verborgen sind.
Selbst der Überprüfung, dass eine große Zahl eine Primzahl ist, durch einen Supercomputer wird vertraut, vor allem, wenn es eine unabhängige Überprüfung gibt; niemand macht sich die Mühe über die philosophische Bedeutung des "`Beweises"' zu diskutieren, obwohl der eigentliche Beweis so umfangreich wäre, dass es völlig unpraktisch wäre, ihn jemals auf Papier zu bringen.  Es scheint, dass man dann dem Computer vertrauen kann, wenn der vom Computer verwendete Algorithmus einfach genug ist, um leicht verstanden zu werden.

Metamath\index{Metamath} macht sich diese Philosophie zu eigen.  Die Einfachheit der Sprache macht es leicht sie zu erlernen, und aufgrund seiner Einfachheit kann man prinzipiell absolut sicher sein, dass ein Beweis korrekt ist. Alle Axiome, Regeln und Definitionen sind jederzeit einsehbar, da sie vom Benutzer selbst definiert werden.
Es gibt keine versteckten oder eingebauten Regeln, die anfällig für subtile Bugs\index{Programmfehler}\index{Bug} sein könnten.
Der grundlegende Algorithmus, im Herzstück von Metamath ist einfach und feststehend, und es kann mit einem an Gewissheit grenzenden Grad an Vertrauen davon ausgegangen werden, dass er fehlerfrei und robust ist.
Unabhängig geschriebene Implementierungen des Metamath-Verifizierers können den Restzweifel eines Skeptikers noch weiter reduzieren.
Es gibt inzwischen mehr als ein Dutzend solcher Implementierungen, die von vielen verschiedenen Personen geschrieben wurden.

\subsection{Dem Mathematiker vetrauen}\label{trust}

\begin{quote}
  {\em Es gibt keinen Algebraiker oder Mathematiker, der in seiner Wissenschaft so bewandert ist, dass er sofort volles Vertrauen in eine von ihm entdeckte Gültigkeit setzt oder sie als etwas anderes als eine bloße Wahrscheinlichkeit betrachtet.  Jedes Mal, wenn er seine Beweise durchgeht, wächst sein Vertrauen; aber noch mehr durch die Zustimmung seiner Freunde; und wird durch die allgemeine Zustimmung und den Beifall der gelehrten Welt zu seiner höchsten Vollkommenheit erhoben.}
  \flushright\sc David Hume\footnote{{\em A Treatise of Human Nature}, Frei übersetzt nach dem Zitat in \cite{deMillo}, S.~267.}\\
\end{quote}\index{Hume, David}

\begin{quote}
  {\em Stanislaw Ulam schätzt, dass Mathematiker jedes Jahr 200.000 Theoreme veröffentlichen.  Einige davon werden später widerlegt oder anderweitig nicht anerkannt, andere werden angezweifelt, und die meisten werden ignoriert.}
  \flushright\sc Richard de Millo et. al.\footnote{Frei übersetzt nach \cite{deMillo}, S.~269.}\\
\end{quote}\index{Ulam, Stanislaw}

Unabhängig davon, ob man dem Computer vertrauen kann oder nicht, werden sich Menschen natürlich gelegentlich irren. Nur die denkwürdigsten Beweise werden von unabhängiger Seite verifiziert, und von diesen erlangen nur eine Handvoll wirklich großartiger Beweise den Status von "`bekannten"' mathematischen Wahrheiten, die ohne einen zweiten Gedanken an ihre Richtigkeit verwendet werden.

Es gibt viele berühmte Beispiele für falsche Theoreme und Beweise in der mathematischen Literatur.\index{Fehler in Beweisen}

\begin{itemize}
\item Es gibt Tausende von angeblichen Beweisen für den Großen Fermatschen Satz\index{Großer Fermatscher Satz} ("`keine ganzzahligen Lösungen existieren zu $x^n + y^n = z^n$ für $n > 2$"'), von Amateuren, Spinnern und angesehenen Mathematikern \cite[S.~5]{Stark}\index{Stark, Harold M}.  Fermat schrieb eine Notiz in sein Exemplar von Bachets {\em Diophantus}, dass er "`hierfür einen wahrhaft wunderbaren Beweis entdeckt [hat], doch ist dieser Rand hier zu schmal, um ihn zu fassen."'\cite[S.~507]{Kramer}.  Ein neuerer, viel beachteter Beweis von Yoichi Miyaoka\index{Miyaoka, Yoichi} wurde als falsch erwiesen ({\em Science News}, April 9, 1988, S.~230).  Das Theorem wurde schließlich von Andrew Wiles\index{Wiles, Andrew} ({\em Science News}, 3. Juli 1993, S.~5) bewiesen, aber der Beweis wies anfangs einige Lücken auf und es dauerte über ein Jahr nach seiner Bekanntgabe, bis er gründlich von Experten überprüft wurde.  Am 25. Oktober 1994 gab Wiles bekannt, dass die letzte Lücke in seinem Beweis geschlossen worden sei.
\item 1882 entdeckte M. Pasch, dass in Euklids Formulierung der Geometrie\index{euklidische Geometrie} ein Axiom ausgelassen wurde; ohne dieses Axiom sind die Beweise der wichtigen Theoreme von Euklid nicht gültig.  Das Axiom von Pasch\index{Axiom von Pasch} besagt, dass eine Linie, die eine Seite eines Dreiecks schneidet, auch eine andere Seite schneiden muss, vorausgesetzt, sie berührt keine der Scheitelpunkte.  Das Fehlen des Axioms von Pasch blieb, trotz der (vermutlich) Tausenden von Studenten, Lehrern und Mathematikern, die Euklid studierten, 2000 Jahre lang unbemerkt.
\item Der erste veröffentlichte Beweis des berühmten Schr\"{o}der--Bernstein-Theorems\index{Schr\"{o}der--Bernstein-Theorem} in der Mengenlehre war unkorrekt\cite[p.~148]{Enderton}\index{Enderton, Herbert B.}.  Dieses Theorem besagt, dass wenn es eine 1-zu-1-Funktion
\footnote{Eine {\em Menge}\index{Menge} ist eine beliebige Sammlung von Objekten. Eine {\em Funktion}\index{Funktion} oder {\em Zuordnung}\index{Zuordnung} ist eine Regel, die jedem Element einer Menge (dem sogenannten {\em Definitionsbereich}\index{Definitionsbereich}) ein Element aus einer anderen Menge zuordnet.} 
von der Menge $A$ in die Menge $B$ und umgekehrt gibt, dann haben die Mengen $A$ und $B$ eine 1-zu-1-Entsprechung.  Obwohl es einfach und offensichtlich klingt, ist der Standardbeweis recht lang und komplex.
\item In den frühen 1900er Jahren veröffentlichte Hilbert\index{Hilbert, David} einen angeblichen Beweis für die Kontinuumshypothese\index{Kontinuumshypothese}, die schließlich 1963 von Cohen\index{Cohen, Paul} als unbeweisbar festgestellt wurde\cite[S.~166]{Enderton}.  Die Kontinuumshypothese besagt, dass keine Unendlichkeit\index{Unendlichkeit} ("`transfinite Kardinalzahl"')\index{Kardinalzahl, transfinit} existiert, deren Größe (oder "`Kardinalität"')\index{Kardinalität} zwischen der Größe der Menge der ganzen Zahlen und der Größe der Menge der reellen Zahlen liegt.  Diese Hypothese geht auf den deutschen Mathematiker Georg
Cantor\index{Cantor, Georg} in den späten 1800er Jahren zurück, und seine Unfähigkeit, sie zu beweisen soll zu seiner Geisteskrankheit beigetragen haben, die ihn in seinen späteren
Jahren plagte.
\item Ein falscher Beweis für den Vier-Farben-Satz\index{Vier-Farben-Satz} wurde von Kempe\index{Kempe, A. B.} 1879 veröffentlicht\cite[S.~582]{Courant}\index{Courant, Richard}; er bestand 11 Jahre lang, bevor sein Fehler entdeckt wurde.  Dieses Theorem besagt, dass jede Karte mit nur vier Farben gefärbt werden kann, so dass keine zwei benachbarten Länder die gleiche Farbe haben.
Im Jahr 1976 wurde das Theorem schließlich durch den berühmten computergestützten Beweis von Haken, Appel und Koch bewiesen \cite{Swart}\index{Appel, K.}\index{Haken, W.}\index{Koch, K.}.  Zumindest scheint es so zu sein.  Der Mathematiker H.~S.~M.~Coxeter\index{Coxeter, H. S. M.} hat Zweifel \cite[S.~58]{Davis}:  "`Ich habe das Gefühl, dass das eine unsaubere Art der Nutzung der Computer ist, und je mehr man mit Haken und Appel korrespondiert, desto wackeliger scheint sie zu sein."'
\item Viele falsche "`Beweise"' der Poincar\'{e}-Vermutung\index{Poincar\'{e}-Vermutung} sind im Laufe der Jahre vorgeschlagen worden.  Diese Vermutung besagt, dass jedes Objekt, das sich mathematisch wie eine dreidimensionale Kugel verhält, topologisch eine dreidimensionale Kugel ist, unabhängig davon, wie sehr es verzerrt ist.  Im März 1986 haben die Mathematiker Colin Rourke\index{Rourke, Colin} und Eduardo R\^{e}go\index{R\^{e}go, Eduardo} Aufsehen in der mathematischen Gemeinschaft erregt, als sie verkündeten, einen Beweis gefunden zu haben; im November desselben Jahres stellte sich heraus, dass der Beweis falsch war \cite[S.218]{PetersonI}.  Sie wurde schließlich 2003 von Grigory Perelman bewiesen \label{poincare}\index{Szpiro, George}\index{Perelman, Grigory}\cite{Szpiro}.
 \end{itemize}

Viele Gegenbeispiele zu "`Theoremen"' in der neueren mathematischen Literatur im Zusammenhang mit Clifford-Algebren\index{Clifford-Algebren} wurden von Pertti Lounesto (der 2002 verstorben ist) gefunden.\index{Lounesto, Pertti} Siehe dazu \url{http://mathforum.org/library/view/4933.html}.
% http://users.tkk.fi/~ppuska/mirror/Lounesto/counterexamples.htm

Einer der Verwendungszwecke von Metamath\index{Metamath} ist es, Beweise mit absoluter Präzision zu formulieren.  Die Entwicklung eines Beweises in der Metamath-Sprache kann eine Herausforderung sein, weil Metamath nicht einmal den kleinsten Fehler zulässt.\index{Fehler in Beweisen}  Ist der Beweis jedoch einmal erstellt, kann man sich sofort auf seine Korrektheit verlassen, ohne dass man zur Bestätigung auf den Prozess der Peer Reviews angewiesen ist.

\section{Der Einsatz von Computern in der Mathe\-matik}

\subsection{Computeralgebrasysteme}

In den meisten Fällen werden Sie feststellen, dass Metamath\index{Metamath} kein praktisches Werkzeug zum Rechnen mit Zahlen ist.  (Selbst der Beweis, dass $2 + 2 = 4$, kann ziemlich komplex sein, wenn Sie mit der Mengenlehre beginnen).  Mehrere kommerzielle Softwareprogramme für Mathematik sind ziemlich gut in Arithmetik, Algebra und Infinitesimalrechnung, und als praktische Werkzeuge sind sie von unschätzbarem Wert.\index{Computeralgebrasystem} Aber sie haben keine Möglichkeiten mit Beweisen umzugehen, und können keine Aussagen verstehen, die mit "`Es gibt solche und solche..."' beginnen.

Softwareprogramme wie Mathematica\cite{Wolfram}\index{Mathematica} beschäftigen sich nicht mit Beweisen, sondern arbeiten direkt mit bekannten Ergebnissen.
Diese Programme setzen vor allem auf heuristische Regeln wie die Ersetzung von Gleichen für Gleiches, um einfachere Ausdrücke oder Ausdrücke in einer anderen Form zu erhalten.  Ausgehend von einer reichhaltigen Sammlung eingebauter Regeln und Algorithmen können die Benutzer mit Hilfe einer leistungsfähigen Programmiersprache weitere solche ergänzen.
Allerdings können Ergebnisse wie z. B. die Existenz eines bestimmten abstrakten Objekts ohne dass das tatsächliche Objekt angegeben wird in ihren Sprachen nicht (direkt) ausgedrückt werden.
Die Möglichkeit, einen Beweis aus einer kleinen Menge von Axiomen zu erstellen, fehlt.
Stattdessen geht diese Software einfach davon aus, dass jedes Faktum oder jede Regel, die Sie der eingebauten Sammlung von Algorithmen hinzufügen, gültig ist.  Somit stellt solch eine Software eine große Sammlung von Axiomen dar, aus der die Software unter gegebenen Zielsetzungen versucht, neue Theoreme abzuleiten, z. B. die Gleichheit eines komplexen Ausdrucks mit einem einfacheren Äquivalent. Aber die Begriffe "`Theorem"'\index{Theorem} und "`Beweis"'\index{Beweis} werden zum Beispiel nicht einmal im Index des Benutzerhandbuchs für Mathematica erwähnt.\index{Mathematica und Beweise}
Aus philosophischer Sicht unbefriedigend ist auch, dass es keine Möglichkeit gibt, die Gültigkeit der Ergebnisse zu gewährleisten, als dem Autor jedes einzelnen Anwendungsmoduls zu vertrauen oder jedes Modul mühsam von Hand zu überprüfen, ähnlich wie ein Computerprogramm auf Fehler zu überprüfen.\index{Programmfehler}\index{Bug}
\footnote{Zwei Beispiele verdeutlichen, warum die Wissensdatenbasis von Computeralgebrasystemen manchmal mit einer gewissen Vorsicht zu betrachten ist.  Wenn Sie Mathematica (Version 3.0) auffordern: \texttt{Solve[x\^{ }n + y\^{ }n == z\^{ }n , n]}, dann wird es antworten: \texttt{\{\{n-\char`\>-2\}, \{n-\char`\>-1\}, \{n-\char`\>1\}, \{n-\char`\>2\}\}}. Mit anderen Worten, Mathematica scheint zu "`wissen"', dass der Große Fermatsche Satz\index{Großer Fermatscher Satz} wahr ist!  Zum Zeitpunkt als diese Version von Mathematica veröffentlicht wurde, war diese Tatsache jedoch noch nicht bekannt.
Wenn Sie Maple\index{Maple} auffordern: \texttt{solve(x\^{ }2 = 2\^{ }x)}, danach: \texttt{simplify(\{"{}\})}, gibt es die Lösungsmenge \texttt{\{2, 4\}} zurück, offenbar nicht wissend, dass $-0.7666647$\ldots auch eine Lösung ist.}
Obwohl sie in der angewandten Mathematik natürlich äußerst hilfreich sind, sind Computeralgebrasysteme für den theoretischen Mathematiker eher von geringem Interesse, außer als Hilfsmittel zur Erforschung bestimmter spezifischer Probleme.

Wegen möglicher Fehler würde ein bloßes Vertrauen in die Ausgabe eines Computeralgebrasystems zur Verwendung als Theorem in einem Beweisverifizierer dessen Ziel der Strenge verfehlen.
Andererseits ist zwar eine Tatsache, dass eine bestimmte relativ große Zahl eine Primzahl ist, für ein Computeralgebrasystem leicht herzuleiten, könnte aber einen langen, mühsamen Beweis haben, der einen Beweisverifizierer überfordern könnte. Ein Ansatz zur Verknüpfung von
Computeralgebrasystemen mit einem Beweisverifizierer unter Beibehaltung der Vorteile beider Systeme besteht darin, jedem dieser Theoreme eine Hypothese hinzuzufügen, die seine Quelle angibt.
Zum Beispiel könnte eine Konstante {\sc maple} anzeigen, dass das Theorem aus dem Maple
Paket stammt, und würde bedeuten: "`Angenommen Maple ist konsistent, dann\ldots"' Dieses und
viele andere Themen, welche die Formalisierung der Mathematik betreffen, werden in John Harrisons\index{Harrison, John} sehr interessanter Dissertation~\cite{Harrison-thesis} diskutiert.

\subsection{Automatische Theorembeweiser}\label{theoremprovers}\index{automatisches Theorembeweisen} 

Eine mathematische Theorie ist "`entscheidbar"'\index{entscheidbare Theorie}, wenn eine mechanische Methode oder ein Algorithmus existiert, der garantiert feststellen kann, ob eine bestimmte Formel ein Theorem ist.  Zu den wenigen Theorien, die entscheidbar sind, gehört die Elementargeometrie, wie ein klassisches Ergebnis des Logikers Alfred Tarski\index{Tarski, Alfred} im Jahr 1948
\cite{Tarski} zeigt.
\footnote{Tarskis Ergebnis gilt eigentlich für eine Teilmenge der Geometrie, die in elementaren Lehrbüchern behandelt wird.  Diese Untermenge umfasst das meiste von dem, was man als elementare Geometrie bezeichnen würde, aber sie ist nicht stark genug, um unter anderem die Begriffe Umfang und Fläche eines Kreises auszudrücken.  Die Theorie so zu erweitern, dass sie Begriffe wie diese enthält, macht die Theorie unentscheidbar, wie auch von Tarski gezeigt wurde.  Tarskis Algorithmus ist viel zu ineffizient, um ihn praktisch auf einem Computer zu implementieren.  Ein praktischer Algorithmus zum Beweisen einer kleineren Untermenge von Geometrie-Theoremen (die nicht die Konzepte der "`Ordnung"' oder "`Kontinuität"' beinhalten) wurde von dem chinesischen Mathematiker Wu Wen-ts\"{u}n im Jahr 1977 \cite{Chou}\index{Chou,
Shang-Ching} entdeckt.}\index{Wen-ts{\"{u}}n, Wu} 
Aber die meisten Theorien, einschließlich der elementaren Arithmetik, sind unentscheidbar.  Diese Tatsache trägt dazu bei, die Mathematik am Leben zu erhalten, da viele Mathematiker glauben, dass sie niemals
durch Computer ersetzt werden (wenn sie Roger Penroses Argument glauben, dass ein Computer niemals das Gehirn ersetzen kann \cite{Penrose}\index{Penrose, Roger}).
In der Tat wird die Elementargeometrie oft als "`toter"' Bereich betrachtet, und zwar aus dem einfachen Grund, dass sie entscheidbar ist.

Andererseits bedeutet die Unentscheidbarkeit einer Theorie nicht, dass man nicht einen Computer für die Suche nach Beweisen verwenden kann. Man muss jedoch bereit sein, die Suche nach einer angemessenen Zeitspanne abzubrechen, wenn bis dahin kein Beweis gefunden wurde.  Das Gebiet des automatischen Theorembeweisens\index{automatisches Theorembeweisen} ist spezialisiert auf die Durchführung solcher Suchen mittels Computern.  Zu den bisher erfolgreichsten Ergebnissen gehören diejenigen, die auf einem Algorithmus, der als Robinsons Resolutionsprinzip bekannt ist\cite{Robinson}\index{Robinsons Resolutionsprinzip} basieren.

Automatische Theorembeweiser können hervorragende Werkzeuge sein, wenn man bereit ist zu lernen, wie man sie benutzt.  Aber sie sind in der reinen Mathematik nicht weit verbreitet, obwohl sie wahrscheinlich in vielen Bereichen nützlich sein könnten.  Es gibt dafür mehrere Gründe.  Der wohl wichtigste ist, dass das Hauptziel in der reinen Mathematik ist, zu Ergebnissen zu gelangen, die als tiefgründig oder wichtig wahrgenommen werden; sie zu beweisen ist zwar wichtig, aber zweitrangig.  Normalerweise kann ein automatischer Theorembeweiser bei diesem Hauptziel nicht helfen, und wenn das Hauptziel erreicht ist, hat der Mathematiker vielleicht schon den Beweis als Nebenprodukt.  Außerdem gibt es ein Problem mit der Notation.  Mathematiker sind daran gewöhnt eine sehr kompakte Syntax zu verwenden, bei der ein oder zwei Symbole (die stark vom Kontext abhängen) sehr komplexe Konzepte darstellen können; dies ist Teil der
Hierarchie\index{Hierarchie}, die sie aufgebaut haben, um schwierige Probleme zu bewältigen.  Ein Theorembeweiser hingegen könnte voraussetzen, dass ein Theorem in "`Logik erster Ordnung"'\index{Logik erster Ordnung} ausgedrückt wird, der Logik, auf die der größte Teil der Mathematik beruht, die aber normalerweise nicht direkt verwendet wird, da die Ausdrücke sehr lang werden können.  Einige automatische Theorembeweiser sind experimentelle Programme, die in ihrer Anwendung auf sehr spezielle Bereiche beschränkt sind, und das Ziel vieler Programme ist einfach die Erforschung der Natur des automatischen Theorembeweisens selbst.  Schließlich muss noch viel Forschung betrieben werden, um sehr tiefgreifende Theoreme zu beweisen.  Ein wichtiges Ergebnis war ein Computerbeweis von Larry Wos\index{Wos, Larry} und Kollegen, dass jede Robbins-Algebra\index{Robbins-Algebra} eine Boolesche Algebra\index{Boolesche Algebra} ist ({\em New York Times}, Dec. 10, 1996).
\footnote{Im Jahr 1933 präsentierte, E.~V.\
Huntington\index{Huntington, E. V.}  das folgende Axiomensystem für die Boolesche Algebra mit einer unären Operation $n$ und einer binären Operation $+$:
\begin{center}
    $x + y = y + x$ \\
    $(x + y) + z = x + (y + z)$ \\
    $n(n(x) + y) + n(n(x) + n(y)) = x$
\end{center}
Herbert Robbins\index{Robbins, Herbert}, ein Schüler von Huntington, vermutete, dass die letzte Gleichung durch eine einfachere Gleichung ersetzt werden kann:
\begin{center}
    $n(n(x + y) + n(x + n(y))) = x$
\end{center}
Robbins und Huntington konnten keinen Beweis finden.  Das Problem wurde später erfolglos von Tarski\index{Tarski, Alfred} und seinen Schülern untersucht, und es blieb ein ungelöstes Problem, bis ein
Computer im Jahr 1996 den Beweis fand.  Weitere Informationen zum Robbins-Algebra-Problem finden Sie unter \cite{Wos}.}

Wie verhält sich Metamath\index{Metamath} zu automatischen Theorembeweisern?  Ein Theorembeweiser befasst sich in erster Linie mit jeweils einem Theorem (vielleicht einer kleinen Datenbasis mit bekannten Theoremen), während Metamath eher wie ein Theoremarchivierungssystem, das sowohl das Theorem als auch seinen Beweis in einer Datenbasis für den Zugriff und die Überprüfung speichert.  Metamath ist eine Antwort auf die Frage "`Was macht man mit der Ausgabe eines Theorembeweisers?"' und könnte als der nächste Schritt in diesem Prozess betrachtet werden.  Automatische Theorembeweiser könnten nützliche Werkzeuge sein, um bei der Entwicklung seiner Datenbasis zu helfen.
Beachten Sie, dass sehr lange, automatisch generierte Beweise die Datenbasis fett und hässlich machen und dazu führen, dass Metamaths Beweisverifikation sehr viel Zeit in Anspruch nimmt.  Wenn Sie nicht ein besonders gutes Programm haben, das sehr prägnante Beweise erzeugt, ist es vielleicht am besten, die Verwendung automatisch generierter Beweise als eine unsaubere Schnelllösung zu betrachten, die zu einem späteren Zeitpunkt manuell neu zu schreiben wäre.

Das Programm {\sc otter}\index{otter@{\sc otter}}\footnote{\url{http://www.cs.unm.edu/\~mccune/otter/}.}, später ersetzt durch prover9\index{prover9}\footnote{\url{https://www.cs.unm.edu/~mccune/mace4/}.}, hat einen historischen Einfluss gehabt.
Der E-Prover\index{E-Prover}\footnote{\url{https://github.com/eprover/eprover}.} ist ein immer noch gepflegter automatischer Theorembeweiser für vollständige Logik erster Ordnung mit Gleichheit.
DAneben gibt es noch viele andere automatische Theorembeweiser.

Wenn Sie automatische Theorembeweiser mit Metamath kombinieren wollen, sollten Sie sich mit dem Buch {\em Automated Reasoning:  Introduction and Applications}\cite{Wos}\index{Wos, Larry} beschäftigen.  In diesem Buch geht es darum wie man {\sc otter} in einer solchen Weise einsetzt, dass es nicht nur in der Lage ist relativ effiziente Beweise zu erzeugen, sondern sogar angewiesen werden kann nach kürzeren Beweisen zu suchen.  Die effektive Verwendung von {\sc otter} (und ähnlicher Werkzeuge) erfordert jedoch ein gewisses Maß an Erfahrung, Sachkenntnis und Geduld.  Das Axiomensystem, das in der \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} Mengenlehre-Datenbasis verwendet wird, kann mit Hilfe einer Methode für {\sc otter} ausgedrückt werden, die in \cite{Megill}\index{Megill, Norman}
\footnote{Um diese Axiome mit {\sc otter} zu verwenden, müssen sie in einer Weise umformuliert werden, die die Notwendigkeit von "`Dummy Variablen"' beseitigt.\index{Dummy-Variable!eliminieren} Siehe den Kommentar
auf S.~\pageref{nodd}.}
beschrieben wird. Bei Erfolg neigt diese Methode in der Regel dazu, kurze und clevere Beweise zu generieren, aber meine Experimente mit ihr zeigen, dass die Methode in angemessener Zeit Beweise nur für relativ einfache Theoreme findet.  Es macht trotzdem Spaß, damit zu experimentieren.

Referenz \cite{Bledsoe}\index{Bledsoe, W. W.} gibt einen Überblick über eine Reihe von Ansätzen,
die auf dem Gebiet des automatischen Theorembeweisens\index{automatisches Theorembeweisen} erforscht wurden.

\subsection{Interaktive Theorembeweiser}\label{interactivetheoremprovers}

Das vollautomatische Finden von Beweisen ist schwierig, daher gibt es einige interaktive Theorembeweiser, bei denen ein Mensch den Computer bei der Suche nach einem Beweis anleitet.
Beispiele hierfür sind HOL Light\index{HOL light}%
\footnote{\url{https://www.cl.cam.ac.uk/~jrh13/hol-light/}.},
Isabelle\index{Isabelle}%
\footnote{\url{http://www.cl.cam.ac.uk/Research/HVG/Isabelle}.},
{\sc hol}\index{hol@{\sc hol}}%
\footnote{\url{https://hol-theorem-prover.org/}.},
und
Coq\index{Coq}\footnote{\url{https://coq.inria.fr/}.}.

Ein wesentlicher Unterschied zwischen den meisten dieser Werkzeuge und Metamath ist, dass die "`Beweise"' eigentlich Programme sind, die das Programm anleiten, einen Beweis zu finden, und nicht der Beweis selbst.
Zum Beispiel könnte ein Isabelle/HOL-Beweis einen Schritt \texttt{apply (blast dest: rearrange reduction)} anwenden. Die \texttt{blast} Anweisung verwendet einen automatischen Tableaux-Beweiser und wird beendet, wenn eine Folge von gültigen Beweisschritten gefunden wurde... aber diese Folge wird nicht als Teil des Beweises betrachtet.

Ein guter Überblick zu übergeordneten Sprachen für Beweisverifikationen (wie {\sc lcf}\index{lcf@{\sc lcf}} und {\sc hol}\index{hol@{\sc hol}}) ist in \cite{Harrison} angegeben.  Alle diese Sprachen unterscheiden sich grundlegend von Metamath dadurch, dass ein Großteil des mathematischen Grundwissens in das zugrundeliegende Beweisprogramm und nicht direkt in die zu prüfende Datenbasis eingebettet ist.
Diese Sprachen können eine steile Lernkurve für diejenigen erfordern, die keinen mathematischen Hintergrund haben.  Zum Beispiel muss man in der Regel ein gewisses Verständnis für mathematische Logik haben, um ihren Beweisen folgen zu können.

\subsection{Beweisverifizierer}\label{proofverifiers}

Ein Beweisverifizierer ist ein Programm, das keine Beweise erzeugt, sondern Beweise die im vorgegeben werden verifiziert.  Viele Beweisverifizierer haben eingeschränkte eingebaute automatisierte Beweisfähigkeiten, wie z. B. das Herausfinden einfacher logischer Schlüsse (wobei sie immer noch von einer Person angeleitet werden, die den Gesamtbeweis liefert).  Metamath hat keine eingebauten automatischen Beweisfähigkeiten, außer der begrenzten Fähigkeit seines Beweis-Assistenten.

Sprachen zur Beweisverifikation werden nicht so häufig verwendet, wie sie es könnten.
Reine Mathematiker sind mehr damit beschäftigt, neue Ergebnisse zu erzielen, und solche Detailgenauigkeit und Strenge würden diesem Ziel im Wege stehen.  
Der Einsatz von Computern in der reinen Mathematik konzentriert sich in erster Linie auf automatische Theorembeweiser (nicht auf Verifizierer), wiederum mit dem Ziel, die Schaffung neuer Mathematik zu unterstützen.
Automatische Theorembeweiser befassen sich in der Regel damit, jeweils ein Theorem anzugehen, anstatt dem Benutzer eine große, organisierte Datenbasis zur Verfügung zu stellen.  Metamath ist eine Möglichkeit, diese Lücke zu schließen.

An sich ist Metamath hauptsächlich ein Beweisverifizierer.
Das bedeutet nicht, dass andere Ansätze nicht verwendet werden können; der Unterschied ist, dass in Metamath die Ergebnisse der verschiedenen Beweise Schritt für Schritt aufgezeichnet werden müssen, damit sie verifiziert werden können.

Eine weitere Sprache zur Überprüfung von Beweisen ist Mizar,\index{Mizar}, die ihre Beweise in der informellen Sprache darstellen kann, an die Mathematiker gewöhnt sind. Informationen über die Mizar-Sprache finden Sie unter \url{http://mizar.org}.

Für den tätigen Mathematiker ist Mizar ein ausgezeichnetes Werkzeug um Beweise streng zu dokumentieren. Mizar stellt seine Beweise in dem informellen Englisch dar, das von Mathematikern verwendet wird (und, obwohl sie für diese ausreichen, für Laien genauso unverständlich sind!). Der Preis für Mizar ist eine relativ steile Lernkurve von einigen Wochen.  Mehrere Mathematiker arbeiten aktiv an der Formalisierung verschiedener Bereiche der Mathematik mit Mizar und veröffentlichen die Beweise in einer speziellen Zeitschrift. Leider wird die Aufgabe, Mathematik zu formalisieren, immer noch in gewissem Maße geringgeschätzt, da sie keine "`neue"' Mathematik hervorbringt.

Das System, das Metamath am nächsten kommt, ist die {\em Ghilbert}\index{Ghilbert}-Beweis\-spra\-che (\url{http://ghilbert.org}), entwickelt von Raph Levien\index{Levien, Raph}.
Ghilbert ist ein formaler Beweisprüfer, der stark von Metamath inspiriert ist.
Ghilbert-Anweisungen sind s-Ausdrücke (à la Lisp), die für Computer leicht zu analysieren sind, aber viele Menschen finden sie schwer zu lesen.
Es gibt eine Reihe von Unterschieden in ihren spezifischen Konstrukten, aber es gibt zumindest ein Werkzeug, um einige Metamath-Daten in Ghilbert zu übersetzen.
Nach dem Stand von 2019 ist die Ghilbert-Gemeinschaft kleiner und weniger aktiv als die Metamath-Gemeinschaft.
Dennoch gibt es Überschneidungen zwischen der Metamath- und der Ghilbert-Gemeinschaft, und im Laufe der Jahre haben viele Male fruchtbare Gespräche zwischen ihnen  stattgefunden.

\subsection{Erstellung einer Datenbasis für formalisierte\\ Mathematik}\label{mathdatabase}

Neben Metamath gibt es mehrere andere laufende Projekte mit dem Ziel, die Mathematik in durch Computer verifizierbare Datenbasen zu formalisieren.  Um sie zu verstehen hilft ein Rückblick auf deren Historie.

Das {\sc qed}\index{qed project@{\sc qed} Projekt}%
\footnote{\url{http://www-unix.mcs.anl.gov/qed}.}
Projekt wurde 1993 ins Leben gerufen und seine Ziele wurden in dem {\sc qed} Manifest umrissen.
Das {\sc qed} Manifest war ein Vorschlag für eine computergestützte Datenbasis für das gesamte mathematische Wissen, streng formalisiert und mit allen Beweisen, die automatisch überprüft wurden.
Zu diesem Projekt fand eine Konferenz im Jahr 1994 und eine weitere im Jahr 1995 statt. Außerdem gab es einen Workshop "`twenty years of the {\sc qed} manifesto"' im Jahr 2014.
Seine Ideale werden regelmäßig wieder aufgegriffen.

In einem Papier aus dem Jahr 2007 nennt Freek Wiedijk zwei Gründe für das Scheitern des {\sc qed} Projekts in der ursprünglich geplanten Form:%
\cite{Wiedijk-revisited}\index{Wiedijk, Freek}

\begin{itemize}
\item Nur sehr wenige Menschen arbeiten an der Formalisierung der Mathematik. Es gibt keine zwingende Anwendung für vollständig mechanisierte Mathematik.
\item Formalisierte Mathematik entspricht noch nicht der traditionellen Mathematik. Das liegt zum einen an der Komplexität der mathematischen Notation und zum anderen an den Grenzen der vorhandenen Theorembeweiser und Beweis-Assistenten.
\end{itemize}

Doch damit war der Traum von der Formalisierung der Mathematik in durch Computer verifizierbaren Datenbasen noch nicht beendet.
Die Probleme, die zum {\sc qed} Manifest führten, sind immer noch aktuell, auch wenn die Herausforderungen schwieriger waren als ursprünglich angenommen.
Stattdessen sind verschiedene unabhängige Projekte entstanden, die an der Formalisierung der Mathematik in durch Computer verifizierbaren Datenbasen gearbeitet haben, die gleichzeitig miteinander konkurrieren und kooperieren.

Eine konkrete Möglichkeit, diese Projekte zu vergleichen, ist
Freek Wiedijks Liste "`Formalisierung von 100 Theoremen"',%
\footnote{\url{http://www.cs.ru.nl/\%7Efreek/100/}.}
die zeigt, welche Fortschritte verschiedene Systeme beim Finden von Beweisen für eine Liste von 100 mathematischen Theoremen gemacht haben.%
\footnote{ Dies ist nicht die einzige Liste von "`interessanten"' Theoremen. Eine weitere interessante Liste wurde von Oliver Knill veröffentlicht \cite{Knill}\index{Knill, Oliver}.}
Die Top-Systeme im Februar 2019 (in der Reihenfolge der Anzahl der abgeschlossenen Beweise) sind HOL Light, Isabelle, Metamath, Coq und Mizar\footnote{Stand 16.10.2023: Isabelle(89), HOL Light(87), Coq(79), Lean(76), Metamath(74) und Mizar(69)}.

Die Metamath 100%
\footnote{\url{http://us.metamath.org/mm\_100.html}} Seite (betreut von David A. Wheeler\index{Wheeler, David A.})
zeigt den Fortschritt von Metamath (insbesondere der \texttt{set.mm} Datenbasis) im Vergleich zu dieser von Freek Wiedijk geführten Challenge-Liste.
Die Metamath-\texttt{set.mm}Datenbasis hat im Laufe der Jahre große Fortschritte gemacht, zum Teil deshalb, weil die Arbeit an den Beweisen dieser Theoreme
die Definition verschiedener Begriffe und die Beweise ihrer Eigenschaften als Voraussetzung erforderlich machten.
Hier sind nur einige der vielen Sätze, die formal mit Metamath bewiesen wurden\footnote{Anm. der Übersetzer: Eine vollständige Liste befindet sich in Anhang \ref{Metamath100}}:

% The entries of this cause the narrow display to break poorly,
% since the short amount of text means LaTeX doesn't get a lot to work with
% and the itemize format gives it even *less* margin than usual.
% No one will mind if we make just this list flushleft, since this list
% will be internally consistent.
\begin{flushleft}
\begin{itemize}
\item 1. Die Irrationalität der Quadratwurzel aus 2
  (\texttt{sqr2irr}, von Norman Megill, 20. August 2001)
\item 2. Der Fundamentalsatz der Algebra
  (\texttt{fta}, von Mario Carneiro, 15. September 2014)
\item 22. Die Nicht-Abzählbarkeit des Kontinuums
  (\texttt{ruc}, von Norman Megill, 13. August 2004)
\item 54. Das Königsberger Brückenproblem
  (\texttt{konigsberg}, von Mario Carneiro, 16. April 2015)
\item 83. Der Freundschaftssatz
  (\texttt{friendship}, von Alexander W. van der Vekens, 9. Oktober 2018)
\end{itemize}
\end{flushleft}

Wir danken all denen, die mindestens einen der Metamath 100-Beweise entwickelt haben, und wir danken insbesondere Mario Carneiro\index{Carneiro, Mario}, der im Jahr 2019 die meisten Metamath 100-Beweise beigesteuert hat.
Die Metamath 100-Seite zeigt die Liste aller Personen, die einen Beweis beigetragen haben, sowie Links zu Grafiken und Diagrammen, die den Fortschritt im Laufe der Zeit zeigen.
Wir ermutigen andere, an Beweisen für Theoreme zu arbeiten, die noch nicht in Metamath bewiesen wurden, da dies das Werk insgesamt verbessert.

Jedes der mathematischen Formalisierungssysteme (einschließlich Metamath) hat unterschiedliche Stärken und Schwächen, je nachdem, worauf Sie Wert legen.
Die wichtigsten Aspekte, die Metamath von den anderen Top-Systemen unterscheiden, sind:

\begin{itemize}
\item Metamath ist nicht an einen bestimmten Satz von Axiomen gebunden.
\item Metamath kann jeden Schritt von jedem Beweis anzeigen, ohne Ausnahmen.
  Die meisten anderen Beweiser behaupten nur, dass ein Beweis gefunden werden kann, und zeigen nicht jeden Schritt. Das macht auch die Verifikation schnell, da
  das System die Details eines Beweises nicht neu ermitteln muss.
\item Der Metamath-Prüfer wurde in vielen verschiedenen Programmiersprachen erneut implementiert, so dass die Verifikation durch mehrere Implementierungen durchgeführt werden kann.  Insbesondere die
  \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}%
  \index{Metamath Proof Explorer} Datenbasis wird von
  vier verschiedenen Verifizierern verifiziert, die in vier verschiedenen Sprachen von vier verschiedenen Autoren geschrieben wurden\footnote{Anm. der Übersetzer: Damit sind die vier Verifizierer gemeint, die bei jedem Git-Merge für Änderungen an \texttt{set.mm} durchgeführt werden: der originale C-Verifizierer von Norman Megill, der Rust-Verifizierer von Stefan O'Rear, der Java-Verifizierer von Mel L. O'Cat und Mario Carneiro und der Python-Verifizierer von Raph Levin. Es gibt daneben noch viele andere Verifizierer, siehe \url{http://us.metamath.org/other.html}.} .
  Dadurch wird das Risiko der Annahme eines ungültigen Beweises aufgrund eines Fehlers im Verifizierer reduziert.
\item Beweise bleiben bewiesen.  In einigen Systemen können Änderungen an der Syntax des Systems oder an der Funktionsweise einer Taktik dazu führen, dass Beweise in späteren Versionen nicht mehr funktionieren, wodurch ältere Arbeiten im Grunde verloren gehen.
  Die Metamath-Sprache ist extrem klein und stabil, so dass sobald ein Beweis einmal zu einer Datenbasis hinzugefügt wurde,
  kann die Datenbasis mit späteren Versionen des Metamath-Programms und mit anderen Verifizierern von Metamath-Datenbasen überprüft werden.
  Wenn ein Axiom oder eine Schlüsseldefinition geändert werden muss, ist es einfach, die Datenbasis als Ganzes zu manipulieren, um die Änderung zu verarbeiten ohne den zugrunde liegenden Verifizierer zu verändern.
  Da die erneute Verifizierung einer gesamten Datenbasis nur Sekunden dauert, gibt es nie einen Grund, die vollständige Überprüfung hinauszuzögern.
  Dieser Aspekt ist besonders überzeugend, wenn man eine langfristig nutzbare Datenbasis mit Beweisen haben möchte.
\item Die Lizenzierung ist großzügig.  Die wichtigsten Metamath-Datenbasen sind öffentlich verfügbar, und das Metamath-Hauptprogramm ist Open-Source-Software unter einer standardisierten, weit verbreiteten Lizenz.
\item Substitutionen sind leicht zu verstehen, auch für diejenigen, die keine
  professionellen Mathematiker sind.
\end{itemize}

Natürlich können andere Systeme Vorteile gegenüber Metamath haben, die geeigneter sind, je nachdem, worauf Sie Wert legen.
In jedem Fall hoffen wir, dass Ihnen diese Ausführungen helfen, Metamath in einem größeren Kontext zu verstehen.

\subsection{Zusammenfassung}\label{computers-summary}

Unsere Diskussion über Computer und Mathematik kann wie folgt zusammengefasst werden: Computeralgebrasysteme können als Theoremgeneratoren betrachtet werden, die sich auf einen eingeschränkten Bereich der Mathematik (Zahlen und ihre Eigenschaften) konzentrieren, automatische Theorembeweiser als Beweisgeneratoren für spezifische Theoreme in einem viel breiteren Bereich, der durch ein eingebautes formales System wie die Logik erster Ordnung abgedeckt wird, interaktive Theorembeweiser erfordern menschliche Anleitung, Beweisverifizierer verifizieren Beweise, aber historisch gesehen waren sie auf die Logik erster Ordnung beschränkt.
Im Gegensatz dazu ist Metamath ein Beweisverifizierer und Dokumentierer, dessen Anwendungsbereich im Wesentlichen unbegrenzt ist.

\section{Die Mathematik und Metamath}

\subsection{Standardmathematik}

Es gibt eine Reihe von Möglichkeiten, Metamath\index{Metamath} für die Standardmathematik zu benutzen.  Der philosophisch befriedigendste Weg ist, ganz am Anfang zu beginnen und die gewünschte Mathematik aus den Axiomen der Logik und Mengenlehre zu entwickeln.  Dies ist der Ansatz, der in der
\texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}%
\index{Metamath Proof Explorer}
Datenbasis (auch bekannt als Metamath Proof Explorer) angewandt wird.
Diese Datenbasis baut unter anderem auch auf den Axiomen der reellen und komplexen Zahlen\index{Analysis}\index{reelle Zahl}\index{komplexe Zahl} auf (siehe Abschnitt~\ref{real}), und eine Standardentwicklung der Analysis könnte beispielsweise an diesem Punkt ansetzen, basierend auf den übrigen Theoremen und Sätzen dieser Datenbasis.
Neben diesem philosophischen Vorteil gibt es auch praktische Vorteile, alle Werkzeuge der Mengenlehre in der unterstützenden Infrastruktur zur Verfügung zu haben.

Andererseits möchte man vielleicht mit den Standardaxiomen einer mathematischen Theorie beginnen, ohne die mengentheoretischen Beweise dieser Axiome berücksichtigen zu müssen.  Sie werden die mathematische Logik benötigen, um Schlussfolgerungen zu ziehen, aber wenn Sie möchten können Sie einfach die Theoreme der Logik\index{Theorem} wo immer man sie braucht als "`Axiome"'\index{Axiom} einführen, unter der impliziten Annahme, dass sie im Prinzip bewiesen werden können, wenn sie für Sie offensichtlich sind.  Wenn Sie diesen Ansatz wählen, werden Sie wahrscheinlich die in
\texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} verwendete Notation überprüfen, damit sie mit Ihrer eigenen Notation zusammenpasst.

\subsection{Andere formale Systeme}
\index{formales System}

Im Gegensatz zu anderen Programmen ist Metamath\index{Metamath} weder auf einen bestimmten Bereich der Mathematik beschränkt, noch einer bestimmten mathematischen Philosophie verpflichtet wie z.B. der klassischen oder intuitionistischer Logik, noch beschränkt auf Ausdrücke der Logik erster Ordnung.  Obwohl die Datenbasis \texttt{set.mm} die Standardlogik und Mengenlehre beschreibt, ist Metamath eigentlich eine Allzwecksprache zur Beschreibung einer Vielzahl formaler Systeme.\index{formales System}  Nicht-Standard-Systeme wie die modale Logik\index{modale Logik}, intuitionistische Logik\index{Intuitionismus}, Logik höherer Ordnung\index{Logik höherer Ordnung (HOL)}, Quantenlogik\index{Quantenlogik}, und Kategorientheorie\index{Kategorientheorie} können alle mit der Metamath-Sprache beschrieben werden.  Sie definieren die von Ihnen bevorzugten Symbole und teilen Metamath die Axiome und Regeln mit, von denen Sie ausgehen wollen, und Metamath verifiziert alle Schlüsse, die Sie aus diesen Axiomen und Regeln ziehen.
Ein einfaches Beispiel für ein nicht standardisiertes formales System ist Hofstadters\index{Hofstadter, Douglas R.} MIU-System,\index{MIU-System} dessen Metamath-Version im Anhang~\ref{MIU} dargestellt wird.

Diese Nutzungsmöglichkeiten von Metamatrh sind nicht nur hypothetisch.
Die größte Metamath-Datenbasis ist
\texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}%
\index{Metamath Proof Explorer}, auch bekannt als der Metamath Proof Explorer, der die gebräuchlichsten Axiome für mathematische Grundlagen verwendet
(insbesondere die klassische Logik kombiniert mit der Zermelo--Fraenkel
Mengenlehre\index{Zermelo--Fraenkel-Mengenlehre} zusammen mit dem Auswahlaxiom).
Es sind aber auch andere Metamath-Datenbasen verfügbar:

\begin{itemize}
\item Die Datenbasis
  \texttt{iset.mm}\index{intuitionistische Logik-Datenbasis (\texttt{iset.mm})},
  auch bekannt als Intuitionistic Logic Explorer\index{Intuitionistic Logic Explorer},
  verwendet intuitionistische Logik (eine konstruktivistische Sichtweise)
  anstelle der klassischen Logik.
\item Die Datenbasis
  \texttt{nf.mm}\index{New Foundations Datenbasis (\texttt{nf.mm})},
  auch bekannt als New Foundations Explorer\index{New Foundations Explorer},
  konstruiert die Mathematik von Grund auf neu,
  ausgehend von Quines New Foundations (NF) Axiomen der Mengenlehre.
\item Die Datenbasis
  \texttt{hol.mm}\index{Datenbasis für Logik höherer Ordnung (\texttt{hol.mm})},
  auch bekannt als Higher-Order Logic (HOL) Explorer\index{Higher-Order Logic (HOL) Explorer},
  beginnt mit HOL (auch einfache Typentheorie genannt), leitet daraus
  Äquivalente zu den ZFC-Axiomen ab und verbindet so die beiden Ansätze.
\end{itemize}

Seit der Zeit von David Hilbert haben sich die Mathematiker darüber Gedanken gemacht, ob die Metasprache, die zur Beschreibung der Mathematik verwendet wird, mächtiger sein muss als die Mathematik, die beschrieben wird.
Die finitistische\index{finitistischer Beweis}, konstruktive Natur von Metamath\index{Metamath}  bietet eine gute philosophische Grundlage für das Studium selbst der schwächsten Logiken.\index{schwache Logik}

Die Beschreibung von vielen, nicht-standardisierten formaler Systeme\index{formales System} wird die Modelltheorie\index{Modelltheorie} oder die Beweistheorie\index{Beweistheorie} verwendet; diese Theorien basieren ihrerseits auf der Standard-Mengentheorie.  Mit anderen Worten: Ein nicht-standardisiertes formales System ist definiert als eine Menge mit bestimmten Eigenschaften, und die Standard-Mengentheorie wird zur Herleitung zusätzliche Eigenschaften dieser Menge genutzt.  Die Datenbasis der Standard-Mengentheorie, die mit Metamath zur Verfügung gestellt wird, kann für diesen Zweck verwendet werden. Und wenn sie auf diese Weise genutzt wird, ist die Entwicklung eines speziellen Axiomensystems für das nicht-standardisierte formale System überflüssig.  Der modell- oder beweistheoretische Ansatz erlaubt es oft, viel tiefgreifendere Ergebnisse mit weniger Aufwand zu beweisen.

Metamath unterstützt beide Ansätze.  Sie können das nicht-standardisierte formale System direkt definieren, oder das nicht-standardisierte formale System als eine Menge mit bestimmten Eigenschaften definieren, je nachdem, was Sie am geeignetsten finden.

%\section{Additional Remarks}

\subsection{Metamath und seine Philosophie}

Metamath steht im Zusammenhang mit einer bestimmten Philosophie oder Betrachtungsweise
der Mathematik. Diese Philosophie ist verwandt mit der formalistischen
Philosophie\index{Formalismus} von Hilbert\index{Hilbert, David} und seinen Anhängern
\cite[S.~1203--1208]{Kline}\index{Kline, Morris}
\cite[S.~6]{Behnke}\index{Behnke, H.}. In dieser Philosophie ist die Mathematik nichts weiter als eine Reihe von Regeln zur Handhabung von Symbolen, zusammen mit den Folgerungen aus der Anwendung dieser Regeln.  Während die beschriebene Mathematik komplex sein kann, sollten die Regeln, mit denen sie beschrieben wird (die "`Metamathematik"'\index{Metamathematik}) so einfach wie möglich sein.
Insbesondere sollten sich die Beweise auf konkrete Objekte beziehen (die Symbole, die wir auf Papier schreiben, und nicht die abstrakten Konzepte, die sie repräsentieren) und mit ihnen in einer konstruktiven Weise umgehen; solche Beweise werden "`finitistisch"' genannt\index{finitistischer Beweis} \cite[S.~2--3]{Shoenfield}\index{Shoenfield,
Joseph R.}.

Ob Sie Metamath interessant oder nützlich finden, hängt zum Teil von der Anziehungskraft ab, die seine Philosophie auf Sie ausübt, und diese Anziehungskraft hängt wahrscheinlich von Ihren besonderen Zielen in Bezug auf die Mathematik ab.  Wenn Sie zum Beispiel ein reiner Mathematiker sind, der an vorderster Front bei der Entdeckung neuer mathematischer Erkenntnisse steht, werden Sie wahrscheinlich Ihre
Kreativität durch den starren Formalismus von Metamath als einschränkt erachten.  Andererseits würden wir argumentieren, dass es vorteilhaft ist, solches Wissen in einem Standardformat zu dokumentieren, sobald es entdeckt ist, damit es daurch für andere zugänglich ist.  In sechzig Jahren mag Ihr Wissensgebiet vielleicht eingeschlafen sein, und dann würden Ihre "`Schriften noch schwieriger übersetzbar sein als die der Maya"', wie Davis und Hersh es ausdrücken\cite[S.~37]{Davis}\index{Davis, Phillip J.}.

\subsection{Die Hintergründe des Metamath-Ansatzes}

Den wahrscheinlich stärksten Einfluss auf Metamath\index{Metamath} hatte Whiteheads und Russells monumentales Werk {\em Principia Mathematica} \cite{PM}\index{Whitehead, Alfred North}\index{Russell, Bertrand}\index{principia mathematica@{\em Principia Mathematica}}, dessen Ziel es war, die gesamte Mathematik aus einer kleinen Anzahl von primitiven Konzepten abzuleiten, und zwar auf eine sehr expliziten Weise, die im Prinzip jeder verstehen und nachvollziehen konnte.  Während dieses Werk zu seiner Zeit sehr einflussreich war, hat es aus heutiger Sicht mehrere Nachteile.  Sowohl die Notation als auch die zugrunde liegenden Axiome gelten heute als veraltet und werden nicht mehr verwendet.  Von unserem Standpunkt aus ist ihre Entwicklung nicht wirklich so zugänglich, wie wir es gerne hätten; aus praktischen Gründen werden die Beweise mit fortschreitender mathematischer Tiefe immer skizzenhafter, und ihre Ausarbeitung im Detail erfordert ein Maß an mathematischem Geschick und Geduld, über die viele Menschen nicht verfügen.  Es gibt zahlreiche kleine Fehler, was angesichts der langwierigen, technischen Natur der Beweise und dem Fehlen eines Computers zur Überprüfung der Details verständlich ist.
Dennoch ist {\em Principia Mathematica} auch heute noch das Werk, das dem Geist von Metamath am nächsten kommt.  Es bleibt ein verblüffendes Werk, und man kann nicht anders als staunen, wenn man sieht, dass "`$1+1=2$"' schließlich auf Seite 83 von Band II erscheint (Theorem *110.643).

Der Ursprung der von Metamath verwendeten Beweisnotation geht auf die 1950er Jahre zurück, als der Logiker C.~A.~Meredith seine Beweise in einer kompakten Notation ausdrückte, die "`kondensierte Ablösung"'\index{kondensierte Ablösung} (engl. "`condensed detachment"`)
\cite{Hindley}\index{Hindley, J. Roger} \cite{Kalman}\index{Kalman, J. A.}
\cite{Meredith}\index{Meredith, C. A.} \cite{Peterson}\index{Peterson, Jeremy
George} genannt wird.  Diese Notation ermöglicht die eindeutige Wiedergabe von Beweisen durch bloße Bezugnahme auf das Axiom\index{Axiom}, die Regel\index{Regel} oder das Theorem\index{Theorem}, das bei jedem Schritt verwendet wird, ohne eine explizite Angabe der Substitutionen\index{Substitution!Variable}\index{Variablensubstitution}, die für die Variablen in diesem Axiom, dieser Regel oder diesem Theorem vorgenommen werden müssen.  Gewöhnlich ist die kondensierte Ablösung mehr oder weniger auf die Aussagenlogik\index{Aussagenlogik} beschränkt.  Das Konzept ist in \cite{Megill}\index{Megill, Norman} auf Logik erster Ordnung\index{Logik erster Ordnung} erweitert worden, wodurch das Schreiben eines kleinen Computerprogramms zur Überprüfung von Beweisen einfacher Theoreme der Logik erster Ordnung vereinfacht wird.\index{kondensierte Ablösung!und Logik erster Ordnung}

Ein Schlüsselkonzept hinter der Notation der kondensierte Ablösung ist die sogenannte "`Vereinheitlichung"' (engl. "`unification"'), ein Algorithmus zur Bestimmung der Substitutionen\index{Substitution!Variable}\index{Variablensubstitution}, die für Variablen vorgenommen werden müssen, damit zwei Ausdrücke miteinander übereinstimmen.
Die Vereinheitlichung wurde erstmals von dem Logiker J.~A.~Robinson genau definiert, der sie bei der Entwicklung einer leistungsfähigen Theorem-Beweis-Technik namens "`Auflösungsprinzip"' (engl. "`resolution principle"') verwendete\cite{Robinson}\index{Robinsons Resolutionsprinzip}. Metamath macht keinen Gebrauch von diesem Auflösungsprinzip, das für Systeme der Logik erster Ordnung\index{Logik erster Ordnung} gedacht ist.  Die Verwendung von Metamath ist nicht auf die Logik erster Ordnung beschränkt, und wie wir bereits erwähnt haben, findet es nicht automatisch Beweise.  Allerdings ist die Vereinheitlichung eine Schlüsselidee hinter Metamaths Beweisnotation, und Metamath macht von einer sehr einfachen Version davon Gebrauch (Abschnitt~\ref{unify}).

\subsection{Metamath und die Logik erster Ordnung}

Die Logik erster Ordnung\index{Logik erster Ordnung} ist die grundlegende Struktur für die Standardmathematik.  Darauf aufbauend gibt es die Mengenlehre mit den Axiomen, aus denen sich praktisch die gesamte Mathematik ableiten lässt --- eine bemerkenswerte Tatsache.\index{Kategorientheorie}\index{Kardinalzahl, unzugänglich}\label{categoryth}\footnote{Eine Ausnahme scheint die Kategorientheorie zu sein.  Es gibt verschiedene Denkschulen darüber, ob die Kategorientheorie aus der Mengenlehre ableitbar ist.  Zumindest scheint es so, dass ein zusätzliches Axiom erforderlich ist, das die Existenz eines "`unzugänglichen Kardinals"' (eine Art von Unendlichkeit, die so groß ist, dass die Standard-Mengenlehren-Theorie ihre Existenz weder beweisen noch leugnen kann).

%
%%%% (I took this out that was in previous editions:)
% But it is also argued that not just one but a "`proper class"' of them
% is needed, and the existence of proper classes is impossible in standard
% set theory.  (A proper class is a collection of sets so huge that no set
% can contain it as an element.  Proper classes can lead to
% inconsistencies such as "`Russell's paradox."'  The axioms of standard
% set theory are devised so as to deny the existence of proper classes.)
%
Für weitere Informationen siehe\cite[pp.~328--331]{Herrlich}\index{Herrlich, Horst} und
\cite{Blass}\index{Blass, Andrea}.}

Einer der Aspekte, die Metamath\index{Metamath} für Theorien erster Ordnung praktikabler machen, ist ein Satz von Axiomen für die Logik erster Ordnung, der speziell für den Metamath-Ansatz entwickelt wurde.  Diese sind enthalten in der Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}.
Siehe Kapitel~\ref{fol} für eine detaillierte Beschreibung; die Axiome sind in Abschnitt~\ref{metaaxioms} aufgeführt.  Während es logisch äquivalent zu Standard-Axiomensystemen ist, bricht unser Axiomensystem die Standardaxiome in kleinere Teile auf, so dass man aus ihnen direkt ableiten kann, was in anderen Systemen nur als übergeordnete "`Metatheoreme"'\index{Metatheorem} abgeleitet werden kann.
Mit anderen Worten, es ist mächtiger als die Standardaxiome vom metalogischen Standpunkt aus gesehen.  Eine strenge Rechtfertigung für dieses System und seine "`metalogische Vollständigkeit"'\index{metalogische Vollständigkeit} findet sich in
\cite{Megill}\index{Megill, Norman}.  Das System ist eng verwandt mit einem System, das von Monk\index{Monk, J. Donald} und Tarski\index{Tarski, Alfred} im Jahr 1965 \cite{Monks} entwickelt wurde.

Zum Beispiel ist die Formel $\exists x \, x = y $ (zu einem gegebenen $y$ existiert ein
$x$, das diesem gleicht) ist ein Satz der Logik,\footnote{Speziell ist es ein Satz
derjenigen Systeme der Logik, die nicht-leere Wertebereiche voraussetzen.  Es ist kein Theorem von allgemeineren Systemen, die den leeren Wertebereich einschließen, in dem nichts existiert, Punkt!  Solche Systeme nennt man "`freie Logiken."'\index{freie Logik} Für eine Diskussion dieser Systeme, siehe \cite{Leblanc}\index{Leblanc, Hugues}.  Da die Logik eine Grundlage für die Mengenlehre ist, die einen nicht leeren Wertebereich hat, ist es bequemer (und traditioneller), ein weniger allgemeines System zu verwenden.  Eine interessante Kuriosität bei der Verwendung einer freie Logik als Grundlage für die Zermelo--Fraenkel-Mengenlehre\index{Zermelo--Fraenkel-Mengenlehre} (wobei das redundante Axiom der Existenz einer leeren Menge weggelassen wird) ist, dass nicht einmal die Existenz einer einzigen Menge bewiesen werden kann, ohne das Axiom der Unendlichkeit anzunehmen!\index{Axiom der Unendlichkeit}}, egal ob $x$ und $y$ verschiedene Variablen\index{unterschiedliche Variablen} sind oder nicht.
In vielen Systemen der Logik müsste man zwei Theoreme beweisen, um zu diesem Ergebnis zu kommen.  Zuerst würden wir beweisen, dass "`$\exists x \, x = x $"', dann würden wir separat beweisen: "`$\exists x \, x = y $, wobei $x$ und $y$ verschiedene Variablen sind"'.  Wir würden dann diese beiden Spezialfälle "`außerhalb des Systems"' (d.h. in unseren Köpfen) kombinieren, um behaupten zu können: "`$\exists x \, x = y $, unabhängig davon, ob $x$ und $y$ verschieden sind"'.  Mit anderen Worten, die Kombination der beiden Spezialfälle ist ein Metatheorem.  In dem System der Logik, das in der Mengenlehre\index{Mengenlehre-Datenbasis (\texttt{set.mm})} von Metamath verwendet wird, sind die Axiome der Logik in kleine Teile zerlegt, die es erlauben, sie so zusammenzusetzen, dass Theoreme wie diese direkt bewiesen werden können.

Wenn man die Axiome auf diese Weise aufschlüsselt, sehen sie auf den ersten Blick seltsam und nicht sehr intuitiv aus, aber seien Sie versichert, dass sie korrekt und vollständig sind.  Ihre Korrektheit ist gewährleistet, weil es sich um Theoremschemata der Standardlogik erster Ordnung handelt (was Sie leicht überprüfen können, wenn Sie Logiker sind).  Ihre Vollständigkeit folgt aus der Tatsache, dass wir die Standardaxiome der Logik erster Ordnung explizit als Theoreme ableiten.  Die Ableitung der Standardaxiome ist etwas schwierig, aber wenn wir es geschafft haben, haben wir ein System zur Verfügung, das weniger unbequem für die Arbeit mit formalen Beweisen\index{formaler Beweis} ist.
Ausgedrückt in technischen Begriffen der Logiker eliminieren wir die umständlichen Konzepte der "`freien Variable"'\index{freie Variable}, der "`gebundenen Variable"'\index{gebundene Variable}, und der "`echten Substitution"'\index{echte Substitution}\index{Substitution!echte} als primitive Begriffe.  Diese Begriffe sind in unserem System vorhanden, werden aber durch konzeptionelle Begriffe definiert, die durch die Axiome ausgedrückt werden, und können im Prinzip eliminiert werden.  In Standardsystemen werden diese Begriffe tatsächlich wie zusätzliche, implizite Axiome\index{implizites Axiom} verwendet, die etwas komplex sind und nicht eliminiert werden können.

Die traditionelle Herangehensweise an die Logik, bei der freie Variable und die echte Substitution definiert ist, kann auch direkt in der Metamath-Sprache nachgebildet werden.
Allerdings ist die Notation eher umständlich, und es gibt Nachteile: zum Beispiel ist die Erweiterung der Definition einer wff mit einer Definition umständlich, weil die Definition der Konzepte der freien Variablen und der echten Substitution ebenfalls erweitert werden müssen.  Unsere Wahl der Axiome für \texttt{set.mm} ist bis zu einem gewissen Grad eine Frage des Stil bei dem Versuch, eine übergreifende Einfachheit zu gewährleisten mit dem Bewusstsein, dass auch der traditionelle Ansatz, falls gewünscht, möglich ist.

\chapter{Verwendung des Metamath-Programms}
\label{using}

\section{Installation}

Die Art und Weise, wie Sie Metamath auf Ihrem Computersystem installieren\index{Metamath!Installation}, ist von Computer zu Computer verschieden.  Aktuelle Anweisungen werden mit dem Download des Metamath-Programms bereitgestellt unter \url{http://metamath.org}.  Im Allgemeinen ist die Installation einfach.
Es gibt eine Datei, die das Metamath-Programm selbst enthält.  
Diese Datei heißt normalerweise \texttt{metamath} oder \texttt{metamath.}{\em xxx}, wobei {\em xxx} der Konvention (wie \texttt{exe}) für ein ausführbares Programm auf Ihrem Betriebssystem entspricht.  Es gibt mehrere zusätzliche Dateien mit Beispielen für die Metamath-Sprache, die alle mit \texttt{.mm} enden.  Die Datei \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} enthält Logik und Mengenlehre und kann als Ausgangspunkt für andere Bereiche der Mathematik verwendet werden.

Sie benötigen außerdem einen Texteditor\index{Texteditor}, mit dem Sie einfachen {\sc ascii}\footnote{American Standard Code for Information Interchange.} Text bearbeiten können, um Ihre Eingabedateien zu erzeugen.\index{ascii@{\sc ascii}}  Auf den meisten Computern stehen solche Texteditoren standardmäßig zur Verfügung.  Beachten Sie, dass einfacher Text nicht unbedingt der Standard für einige Textverarbeitungsprogramme ist, insbesondere wenn sie mit verschiedenen Schriftarten umgehen können; zum Beispiel müssen Sie bei Microsoft Word\index{Word (Microsoft)} die Datei im Format "`Nur Text"' abspeichern, um eine einfache Textdatei\index{einfacher Text} zu erhalten.\footnote{Es wird empfohlen, dass alle Zeilen in einer Metamath-Quelldatei eine Länge von höchstens 79 Zeichen haben, um die Kompatibilität zwischen verschiedenen Computerterminals zu gewährleisten.  Beim Erstellen einer Quelldatei in einem Editor wie Word, wählen Sie eine nichtproportionale Schriftart\index{nichtproportionale Schriftart} wie Courier\index{Courier Schriftart} oder Monaco\index{Monaco Schriftart}, um dies zu erleichtern.  Oder noch besser, verwenden Sie einfach einen einfachen Texteditor wie Notepad.}

Auf einigen Computersystemen kann Metamath seine Ausgaben nicht direkt ausdrucken; stattdessen senden Sie die Ausgabe in eine Datei (mit den \texttt{open}-Befehlen, die später beschrieben werden).  Die Art und Weise, wie Sie diese Ausgabedatei ausdrucken, hängt von Ihrem Computer ab.\index{Drucker} Einige Computer haben einen Druckbefehl, während Sie bei anderen Computern die Datei möglicherweise in einen Editor einlesen und von dort aus drucken müssen.

Wenn Sie Ihre Metamath-Quelldateien mit professionell formatierten Formeln, die mathematische Standardsymbole enthalten, drucken möchten, benötigen Sie das \LaTeX\
Satzprogramm\index{latex@{\LaTeX}}, das für die meisten Betriebssysteme frei verfügbar ist.  Es läuft von Haus aus auf Unix und Linux und kann unter Windows als Teil des freien Cygwin-Pakets installiert werden (\url{http://cygwin.com}).

Sie können auch {\sc html}-Webseiten\footnote{HyperText Markup Language.} erstellen.
Der Befehl {\tt help html} im Metamath-Programm unterstützt Sie bei dieser Funktion.

\section{Ihr erstes formales System}\label{start}
\subsection{Vom Nichts zur Zahl Null}\label{startf}

Um Ihnen ein Gefühl dafür zu vermitteln, wie die Metamath\index{Metamath}-Sprache aussieht, sehen wir uns ein sehr einfaches Beispiel aus der formalen Zahlentheorie\index{Zahlentheorie} an.  Dieses Beispiel stammt aus Mendelson\index{Mendelson, Elliot} \cite[S. 123]{Mendelson}.\footnote{Um das Beispiel einfach zu halten, haben wir den Formalismus leicht verändert, und was wir als
Axiome\index{Axiom} bezeichnen, sind streng genommen Theoreme\index{Theorem} in
\cite{Mendelson}.}  Wir werden eine kleine Teilmenge dieser Theorie betrachten, nämlich den Teil, der für den ersten in \cite{Mendelson} bewiesenen Satz der Zahlentheorie benötigt wird.

Zuerst werden wir uns einen standardmäßigen formalen Beweis\index{formaler Beweis} für das ausgewählte Beispiel anschauen, und dann einen Blick auf die Metamath-Version werfen.  Wenn Sie noch nie mit formalen Beweisen in Berührung gekommen sind, mag Ihnen die Notation als ein Overkill für die Darstellung so einfacher Begriffe vorkommen, so dass Sie sich vielleicht fragen, ob Sie etwas übersehen haben.  Das haben Sie nicht.  Die verwendeten Konzepte sind in der Tat sehr einfach, und eine detaillierte Aufschlüsselung auf diese Art ist notwendig, um den damit formulierten Beweis mechanisch verifizieren zu können.  Und wie Sie sehen werden, zerlegt Metamath den Beweis in noch feinere Teile, so dass der mechanische Verifikationsprozess so einfach wie möglich gehalten werden kann.

Bevor wir die Axiome\index{Axiom} der Theorie einführen können, müssen wir die Syntaxregeln\index{Syntax-Regeln} zur Bildung legaler Ausdrücke\index{Syntax-Regeln} (Kombinationen von Symbolen) definieren, mit denen diese Axiome verwendet werden können. Die Zahl 0 ist ein {\bf Term}\index{Term}; und wenn $ t$ und $r$ Terme sind, so ist auch $(t+r)$ ein solcher. Hier sind $ t$ und $r$ "`Metavariablen"'\index{Metavariable}, die sich über Terme erstrecken; sie selbst erscheinen nicht als Symbole in einem eigentlichen Term.  Einige Beispiele für konkrete Terme sind $(0 + 0)$ und $((0+0)+0)$. (Beachten Sie, dass unsere Theorie nur die Zahl Null und Summen von Nullen beschreiben kann.  Natürlich kann man mit einer so trivialen Theorie nicht viel anfangen, aber wir haben uns für unser Beispiel eine sehr kleine Teilmenge der kompletten Zahlentheorie ausgewählt.  Das Wichtigste, worauf Sie sich konzentrieren sollten, sind unsere Definitionen, die beschreiben, wie Symbole kombiniert werden, um gültige Ausdrücke zu bilden, und nicht auf den Inhalt oder die Bedeutung dieser Ausdrücke). Wenn $ t$ und $r$ Terme sind, ist ein Ausdruck der Form $ t=r$ eine {\bf wff} (wohlgeformte Formel)\index{wohlgeformte Formel (wff)}; und wenn $P$ und $Q$ wffs sind, so ist dies auch $(P\rightarrow Q)$ (was "`$P$ impliziert $Q$"'\index{Implikation ($\rightarrow$)} oder "`wenn $P$ dann $Q$"' bedeutet).
Hier sind $P$ und $Q$ Metavariablen, die sich über wffs erstrecken.  Beispiele für konkrete wffs sind $0=0$, $(0+0)=0$, $(0=0 \rightarrow (0+0)=0)$, und $(0=0\rightarrow
(0=0\rightarrow 0=(0+0)))$. (Unsere Notation verwendet mehr Klammern als üblich, aber die Verhinderung von Mehrdeutigkeiten auf diese Weise vereinfacht unser Beispiel, da die Notwendigkeit entfällt, die Vorrangigkeit von Operatoren\index{Vorrangigkeit eines Operators} zu definieren.)

Die {\bf Axiome}\index{Axiom} unserer Theorie sind alle wffs der folgenden Form, wobei $ t$, $r$ und $s$ beliebige Terme sind:

%Latex S. 92
\renewcommand{\theequation}{A\arabic{equation}}

\begin{equation}
(t=r\rightarrow (t=s\rightarrow r=s))
\end{equation}
\begin{equation}
(t+0)=t
\end{equation}

Man beachte, dass es eine unendliche Anzahl von Axiomen gibt, da es eine unendliche Anzahl von möglichen Termen gibt.  A1 und A2 müssten korrekterweise "`Axiomenschemata"'\index{Axiomenschema} genannt werden, aber der Kürze halber werden sie als "`Axiome"' bezeichnet.

Ein Axiom ist ein {\bf Theorem}; und wenn $P$ und $(P\rightarrow Q)$ Theoreme sind (wobei $P$ und $Q$ wffs sind), dann ist $Q$ auch ein Theorem.\index{Theorem} Der zweite Teil dieser Definition wird als Modus ponens-Schlussregel (MP)\index{Inferenzregel}\index{Modus ponens} bezeichnet.  Sie erlaubt es uns, neue Theoreme aus alten Theoremen zu gewinnen.

Der {\bf Beweis}\index{Beweis} eines Satzes ist eine Folge von einem oder mehreren
Theoremen, von denen jedes entweder ein Axiom oder das Ergebnis des Modus ponens ist, das auf zwei vorhergehende Theoreme in der Folge angewandt wird, und das letzte davon das zu beweisende Theorem ist.

Das Theorem, das wir für unser Beispiel beweisen wollen, ist sehr einfach: $ t=t$.  Der Beweis unseres Theorems folgt.  Studieren Sie ihn sorgfältig, bis Sie sicher sind, dass Sie ihn verstehen.\label{zeroproof}

% Use tabu so that lines will wrap automatically as needed.
\begin{tabu} { l X X }
1. & $(t+0)=t$ & (nach Axiom A2) \\
2. & $(t+0)=t$ & (nach Axiom A2) \\
3. & $((t+0)=t \rightarrow ((t+0)=t\rightarrow t=t))$ & (nach Axiom A1) \\
4. & $((t+0)=t\rightarrow t=t)$ & (nach MP angewandt auf Schritte 2 und 3) \\
5. & $t=t$ & (nach MP angewandt auf Schritte 1 und 4) \\
\end{tabu}

(Sie fragen sich vielleicht, warum Schritt 1 zweimal wiederholt wird.  Dies ist nicht notwendig in der formalen Sprache, die wir definiert haben. Aber wegen der in Metamath verwendeten "`umgekehrten polnischen Notation"' für Beweise kann auf einen vorherigen Schritt nur einmal verwiesen werden.  Die Wiederholung von Schritt~1 wird es Ihnen ermöglichen, diesen Beweis mit der Metamath\index{Metamath}-Version auf S.~\pageref{demoproof} besser abgleichen zu können).

Unser Theorem müsste richtigerweise  als "`Theoremschema"'\index{Theoremschema} bezeichnet werden, denn es stellt eine unendliche Anzahl von Theoremen dar, eines für jeden möglichen Term $ t$.  Zwei Beispiele für konkrete Theoreme wären $0=0$ und $(0+0)=(0+0)$.  Selten beweisen wir eigentliche Theoreme, da wir durch den Nachweis von Schemata eine unendliche Anzahl von Sätzen auf einen Schlag beweisen können.  In ähnlicher Weise sollte unser Beweis eigentlich als "`Beweisschema"'\index{Beweisschema} bezeichnet werden.  Um einen konkreten Beweis zu erhalten, wählen Sie einen konkreten Term, den Sie anstelle von $ t$ verwenden, und setzen ihn im gesamten Beweis für $ t$ ein.

Lassen Sie uns darüber diskutieren, was wir gerade getan haben.  Die Axiome\index{Axiom} unserer Theorie, A1 und A2, sind trivial und offensichtlich.  Jeder weiß, dass die Addition von Null zu etwas nichts verändert, und auch, dass, wenn zwei Dinge gleich einem dritten sind, sie einander gleichen. Die Feststellung des Trivialen und Offensichtlichen ist ein Ziel, das in jedem axiomatischen System angestrebt werden sollte.  Aus trivialen und offensichtlichen Wahrheiten, über die sich alle einig sind, können wir Ergebnisse beweisen, die nicht so offensichtlich sind, und dennoch absolutes Vertrauen in sie haben.  Wenn wir den Axiomen und den Regeln vertrauen, müssen wir per Definition auch den Konsequenzen dieser Axiome und Regeln vertrauen, wenn Logik überhaupt eine Bedeutung haben soll.

Unsere Schlussregel\index{Regel}, der Modus ponens\index{Modus ponens}, ist ebenfalls ziemlich offensichtlich, sobald man versteht, was sie bedeutet.  Wenn wir eine Tatsache $P$ beweisen, und wir auch beweisen, dass $P$ $Q$ impliziert, dann folgt $Q$ notwendigerweise als eine neue Tatsache.  Die Regel gibt uns ein Mittel an die Hand, um neue Fakten zu erhalten (d.h. Theoreme\index{Theorem}) aus alten Fakten zu gewinnen.

Das Theorem $ t=t$, das wir bewiesen haben, ist so grundlegend, dass man sich fragt warum es nicht zu den Axiomen gehört.  In einigen Axiomensystemen der Arithmetik {\em ist} es ein Axiom.  Die Wahl der Axiome in einer Theorie ist bis zu einem gewissen Grad willkürlich und sogar eine Art Kunst, die nur durch die Anforderung eingeschränkt wird, dass zwei gleichwertige Axiomensysteme in der Lage sein müssen, sich gegenseitig als Theoreme ableiten zu können.  Wir könnten uns vorstellen, dass der Erfinder unseres Axiomensystems ursprünglich $ t=t$ als Axiom aufnahm und dann entdeckte, dass es sich als Theorem aus den anderen Axiomen ableiten lässt.  Aus diesem Grund war es nicht notwendig, es als Axiom beizubehalten.  Durch die Streichung dieses Axioms wurde der endgültige Satz von Axiomen sehr viel einfacher.

Wenn Sie noch nie mit formalen Beweisen\index{formaler Beweis} gearbeitet haben, war es Ihnen wahrscheinlich nicht klar, dass $ t=t$ aus unseren beiden Axiomen abgeleitet werden kann, bis Sie den Beweis gesehen haben. Obwohl Sie sicherlich glauben, dass $ t=t$ wahr ist, könnten Sie einen imaginären Skeptiker, der nur an unsere beiden Axiome glaubt, nicht überzeugen, solange Sie nicht den Beweis erbringen.  Formale Beweise wie dieser sind schwer zu finden, wenn man anfängt, mit ihnen zu arbeiten. Aber wenn man sich an sie gewöhnt hat, können sie interessant werden und Spaß machen.  Sobald Sie die Idee hinter formalen Beweisen verstanden haben, haben Sie das grundlegende Prinzip, das der gesamten Mathematik zugrunde liegt, begriffen.  Je anspruchsvoller die Mathematik wird, desto anspruchsvoller werden auch die Beweise, aber letztlich lassen sie sich alle in einzelne Schritte zerlegen, die so einfach sind wie die in unserem obigen Beweis.

Das Buch von Mendelson\index{Mendelson, Elliot}, dem unser Beispiel entnommen wurde, enthält eine Reihe detaillierter formaler Beweise wie diese, und es könnte Sie interessieren, es dort nachzuschlagen.  Das Buch ist für Mathematiker gedacht, und das meiste davon hat ein ziemlich fortgeschrittenes Niveau.  Zur populären Literatur, die sich mit der Beschreibung von formalen Beweisen befasst, gehören unter anderem \cite[S.~296]{Rucker}\index{Rucker, Rudy} und \cite[S.~204--230]{Hofstadter}\index{Hofstadter, Douglas R.}.

\subsection{Konvertierung des Beweises nach Metamath}\label{convert}

Formale Beweise\index{formaler Beweis}, wie der in unserem Beispiel, zerlegen die logischen Schlussfolgerungen in kleine, präzise Schritte, die keinen Zweifel daran lassen, dass die ihre Ergebnisse aus den Axiomen\index{Axiom} folgen.  Man könnte meinen, dass dies die feinste Aufschlüsselung ist, die wir in der Mathematik erreichen können.  Es steckt jedoch mehr hinter dem Beweis, als man auf den ersten Blick vermuten würde. Obwohl unsere Axiome recht einfach waren, war eine Menge Wortklauberei nötig, bevor wir sie überhaupt formulieren konnten: Wir mussten Begriffe wie "`Term"', "`wff"' und so weiter definieren.  Darüber hinaus gibt es eine Reihe von impliziten Regeln, die wir noch nicht einmal erwähnt haben. Woher wissen wir zum Beispiel, dass Schritt 3 unseres Beweises aus dem Axiom A1 folgt? Es gibt einige versteckte Argumentationen, um dies zu bestimmt sagen zu können.  Axiom A1 hat zwei Vorkommen des Buchstabens $ t$.  Eine der impliziten Regeln besagt, dass alles, was wir für $ t$ ersetzen, ein legaler Term\index{Term}\footnote{Einige Autoren machen diese implizite Regel explizit, indem sie nach der Definition von "`Term"' sagen: "`Nur Ausdrücke der obigen Form sind Terme"'.} sein muss.  Der Ausdruck $ t+0$ ist ganz offensichtlich ein legaler Term, wenn $ t$ ein solcher ist. Aber nehmen wir an, wir wollten solche Ersetzungen in einem riesigen Term mit Tausenden von Symbolen durchführen?  Sicherlich wäre eine Menge Arbeit damit verbunden festzustellen, dass es sich wirklich bei dem Ergebnis um einen Term handelt, aber in gewöhnlichen formalen Beweisen würde man all diese Arbeit als einen einzigen "`Schritt"' betrachten.

Um unser Axiomensystem in der Metamath\index{Metamath}-Sprache auszudrücken, müssen wir diese Zusatzinformationen zusätzlich zu den eigentlichen Axiomen be\-schrei\-ben.
Metamath weiß nicht, was ein "`Term"' oder eine "`wff"'\index{wohlgeformte Formel (wff)} ist.  In Metamath ist die Spezifikation der Art und Weise, in der wir Symbole kombinieren können, um Terme und wffs zu erhalten, selbst wie kleine Axiome zu verstehen.  Diese Hilfsaxiome werden in der gleichen Notation ausgedrückt wie die "`echten"' Axiome\index{Axiom}, und Metamath unterscheidet nicht zwischen diesen beiden.  Die Unterscheidung wird von Ihnen getroffen, d.h. durch die Art und Weise, wie Sie die Notation interpretieren, die Sie gewählt haben, um diese beiden Arten von Axiomen auszudrücken.

Die Metamath-Sprache zerlegt mathematische Beweise in winzige Teile, viel mehr als in gewöhnlichen formalen Beweisen\index{formaler Beweis}.  Wenn ein einzelner Schritt\index{Beweisschritt} die Substitution\index{Substitution!Variable}\index{Variablensubstitution} eines
komplexen Terms für eine seiner Variablen beinhaltet, muss Metamath diesen einzelnen Schritt in viele kleine Schritte unterteilt behandeln.  Diese feinkörnige Aufschlüsselung ist es, die Metamath Allgemeingültigkeit und Flexibilität gibt, da es sich nicht auf eine bestimmte mathematische Notation beschränkt.

Die Beweisnotation von Metamath ist nicht dazu gedacht, von Menschen gelesen zu werden, sondern ihr kompaktes Format ist für eine Maschine gedacht.  Das Metamath-Programm konvertiert diese Notation in eine Form, die Sie verstehen können, indem es den \texttt{show proof}\index{\texttt{show proof}-Befehl} Befehl nutzt.  Sie können dem Programm mitteilen, wie detailliert Sie den Beweis betrachten möchten.  Vielleicht möchten Sie sich nur die logischen Folgerungsschritte ansehen, die den normalen formalen Beweisschritten entsprechen, oder Sie möchten die feingranularen Schritte sehen, die beweisen, dass ein Ausdruck ein Term ist.

Hier ist schließlich, ohne weitere Erläuterungen, unser Beispiel, das in die Metamath\index{Metamath}-Sprache konvertiert wurde:\index{Metavariable}\label{demo0}

\begin{verbatim}
$( Festlegen der konstanten Symbole, die wir nutzen wollen $)
    $c 0 + = -> ( ) term wff |- $.
$( Festlegen der Metavariablen, die wir nutzen wollen $)
    $v t r s P Q $.
$( Spezifizieren der Eigenschaften der Metavariablen $)
    tt $f term t $.
    tr $f term r $.
    ts $f term s $.
    wp $f wff P $.
    wq $f wff Q $.
$( Definieren von "Term" und "wff" $)
    tze $a term 0 $.
    tpl $a term ( t + r ) $.
    weq $a wff t = r $.
    wim $a wff ( P -> Q ) $.
$( Festlegen der Axiome $)
    a1 $a |- ( t = r -> ( t = s -> r = s ) ) $.
    a2 $a |- ( t + 0 ) = t $.
$( Definieren der Schlussregel Modus ponens $)
    ${
       min $e |- P $.
       maj $e |- ( P -> Q ) $.
       mp  $a |- Q $.
    $}
$( Beweisen eines Theorems $)
    th1 $p |- t = t $=
  $( Hier ist sein Beweis: $)
       tt tze tpl tt weq tt tt weq tt a2 tt tze tpl
       tt weq tt tze tpl tt weq tt tt weq wim tt a2
       tt tze tpl tt tt a1 mp mp
     $.
\end{verbatim}\index{Metavariable}

Eine "`Datenbasis"'\index{Datenbasis} ist ein Satz von einer oder mehreren {\sc ascii} Quelldateien.  Es folgt eine kurze Beschreibung solch einer Metamath\index{Metamath}-Datenbasis (die aus einer einzigen Quelldatei besteht), damit Sie allgemein verstehen können, was vor sich geht.  Um die Quelldatei im Detail zu verstehen, sollten Sie Kapitel~\ref{languagespec} lesen.

Die Datenbasis ist eine Folge von "`Token"'\index{Token}, die normalerweise durch Leerzeichen oder Zeilenumbrüche voneinander getrennt sind.  Die einzigen Token, die in der Metamath-Sprache fest vorgegeben sind, sind diejenigen die mit \texttt{\$} beginnen.  Diese Token werden "`Schlüsselwörter"'\index{Schlüsselwort} genannt.  Alle anderen Token sind benutzerdefiniert, und ihre Namen sind beliebig.

Wie Sie vielleicht schon vermutet haben, beginnt mit dem Metamath-Token \texttt{\$(}\index{\texttt{\$(} und
\texttt{\$)} Hilfsschlüsselwörter} ein Kommentar und wird mit \texttt{\$)} beendet.

Die Metamath-Token \texttt{\$c}\index{\texttt{\$c}-Anweisung},
\texttt{\$v}\index{\texttt{\$v}-Anweisung},
\texttt{\$e}\index{\texttt{\$e}-Anweisung},
\texttt{\$f}\index{\texttt{\$f}-Anweisung},
\texttt{\$a}\index{\texttt{\$a}-Anweisung} und
\texttt{\$p}\index{\texttt{\$p}-Anweisung} spezifizieren "`Anweisungen"', die
mit \texttt{\$.}\,\index{\texttt{\$.} Schlüsselwort} enden.

Die Metamath-Token \texttt{\$c} und \texttt{\$v} deklarieren\index{Konstantendeklaration}\index{Variablendeklaration} jeweils eine Liste von benutzerdefinierten Token, genannt "`Mathematische Symbole"',\index{mathematisches Symbol} die später in der Datenbasis verwendet werden.  Alle mathematischen Symbole für unser Beispiel werden so definiert, außer dem Drehkreuzsymbol \texttt{|-} ($\vdash$)\index{Drehkreuz ({$\,\vdash$})}, das von Logikern üblicherweise verwendet wird um zu sagen: "`Ein Beweis existiert für"'.  Für uns ist das Drehkreuz nur ein praktisches Symbol zur Unterscheidung zwischen Ausdrücken, die Axiome\index{Axiom} oder Theoreme\index{Theorem} darstellen, und Ausdrücken, die Terme oder wffs sind.

Die Anweisung \texttt{\$c} deklariert "`Konstanten"'\index{Konstante}\index{Konstantendeklaration}, und die Anweisung \texttt{\$v} deklariert "`Variablen"'\index{Variable}\index{Variablendeklaration} (oder genauer gesagt, Metavariablen\index{Metavariable}).
Eine Variable kann durch Folgen von mathematischen Symbolen ersetzt\index{Substitution!Variable}\index{Variablensubstitution} werden, während eine Konstante nicht ersetzt werden kann.

Es mag redundant erscheinen, dass sowohl \texttt{\$c}\index{\texttt{\$c}-Anweisung} als auch \texttt{\$v}\index{\texttt{\$v}-Anweisung} erforderlich sind (da jedes mathematische Symbol, das nicht mit einer \texttt{\$c}-Anweisung spezifiziert wurde, als Variable angesehen werden könnte). Aber dies ermöglicht eine bessere Prüfung auf Fehler und erlaubt es auch, mathematische Symbole neu zu  deklarieren\index{Umdeklarierung von Symbolen} (Abschnitt~\ref{scoping}).

Das Token \texttt{\$f}\index{\texttt{\$f}-Anweisung} spezifiziert eine Anweisung, die als "`Hypothese vom Variablentyp"' (auch als "`fließende Hypothese"' bekannt) und \texttt{\$e}\index{\texttt{\$e}-Anweisung} spezifiziert eine "`logische Hypothese"' (auch "`essentielle Hypothese"').\index{Hypothese}\index{Variablentyp-Hypothese}\index{logische Hypothese}\index{fließende Hypothese}\index{essentielle Hypothese}
Das Token \texttt{\$a}\index{\texttt{\$a}-Anweisung} spezifiziert eine "`axiomatische
Behauptung"'\index{axiomatische Behauptung}, und \texttt{\$p}\index{\texttt{\$p}-Anweisung} spezifiziert eine "`beweisbare Behauptung"'\index{beweisbare Behauptung}. Links von jedem Vorkommen dieser vier Token befindet sich ein "`Label"' \index{Label}, das die Hypothese oder Behauptung für eine spätere Bezugnahme identifiziert.  Zum Beispiel ist das Label der ersten axiomatischen Behauptung \texttt{tze}.  Eine \texttt{\$f}-Anweisung muss genau zwei mathematische Symbole enthalten, eine Konstante gefolgt von einer Variable.  Die Anweisungen \texttt{\$e}, \texttt{\$a}, und \texttt{\$p} beginnen jeweils mit einer Konstanten, auf die im Allgemeinen eine beliebige Folge von mathematischen Symbolen folgt.

Jeder Behauptung\index{Behauptung} ist ein Satz von Hypothesen zugeordnet die erfüllt sein müssen, damit die Behauptung in einem Beweis verwendet werden kann.
Diese werden "`obligatorische Hypothesen"' \index{obligatorische Hypothese} der Behauptung genannt.  Zu den Hypothesen, deren "`Gültigkeitsbereich"' (siehe unten) die Behauptung umfasst, sind \texttt{\$e} Hypothesen immer obligatorisch und \texttt{\$f}\index{\texttt{\$f}-Anweisung} Hypothesen sind obligatorisch, wenn sie ihre Variable mit der Behauptung oder ihren \texttt{\$e}-Hypothesen teilen.  Die genauen Regeln zur Bestimmung, welche Hypothesen obligatorisch sind, werden in den Abschnitten~\\ref{frames} und \ref{scoping} im Detail beschrieben.  Zum Beispiel sind \texttt{tt} und \texttt{tr} die obligatorischen Hypothesen der Behauptung \texttt{tpl}, während die Behauptung \texttt{tze} keine obligatorischen Hypothesen hat, weil sie keine Variablen enthält und keine \texttt{\$e}\index{\texttt{\$e}-Anweisung} Hypothese hat.  Metamaths \texttt{show statement}-Befehl\index{\texttt{show statement}-Befehl}, der im nächsten Abschnitt beschrieben wird, zeigt Ihnen die obligatorischen Hypothesen einer Behauptung.

Manchmal soll eine Hypothese nur für bestimmte Behauptungen relevant sein.
Die Menge der Behauptungen, für die eine Hypothese relevant ist, wird ihr "`Gültigkeitsbereich"' genannt.  Die Metamath-Klammern, \texttt{\$\char`\{}\index{\texttt{\$\char`\{} und \texttt{\$\char`\}} Schlüsselwörter} und \texttt{\$char`\}}, definieren einen "`Block"'\index{Block}, der den Gültigkeitsbereich jeder dazwischen liegenden Hypothese abgrenzt.  Die Behauptung \texttt{mp} hat obligatorische Hypothesen \texttt{wp}, \texttt{wq}, \texttt{min} und \texttt{maj}.  Die einzige obligatorische Hypothese von \texttt{th1} ist dagegen \texttt{tt}, da \texttt{th1} außerhalb des Blocks auftritt, der \texttt{min} und \texttt{maj} enthält.

Beachten Sie, dass \texttt{\$\char`\{} und \texttt{\$\char`\}} keine Auswirkungen auf den Gültigkeitsbereich von Behauptungen (\texttt{\$a} und \texttt{\$p}) haben.  Behauptung sind immer verfügbar, um von jedem späteren Beweis in der Quelldatei referenziert zu werden.

Jede beweisbare Behauptung (\texttt{\$p}\index{\texttt{\$p}-Anweisung} Behauptung) besteht aus zwei Teilen.  Der erste Teil ist die Behauptung\index{Behauptung} selbst: eine Folge von mathematischen Symbolen\index{mathematisches Symbol}, die zwischen dem \texttt{\$p}-Token und einem \texttt{\$=}\index{\texttt{\$=} Schlüsselwort}-Token platziert ist.  Der zweite Teil ist ein "`Beweis"': eine Liste von Label-Token, die zwischen dem \texttt{\$=}-Token und dem \texttt{\$.}-Token\index{\texttt{\$.} Schlüsselwort}, das die Behauptung beendet, liegt.\footnote{Wenn Sie die \texttt{set.mm}-Datenbasis angesehen haben, ist Ihnen vielleicht eine andere Notation aufgefallen, die für
Beweise genutzt wird.  Die andere Notation wird "`komprimiert"'\index{komprimierter Beweis}\index{Beweis!komprimiert} genannt. Sie reduziert den Platzbedarf zur effizienten Speicherung eines Beweises in der Datenbasis, und wird in Anhang~\ref{compressed} beschrieben.  In dem obigen Beispiel verwenden wir die "`normale"'\index{normaler Beweis}\index{Beweis!normal} Notation.} 
Der Beweis fungiert als eine Reihe von Anweisungen für das Metamath-Programm, die ihm sagen, wie die Abfolge der mathematischen Symbole, die im Behauptungsteil der Anweisung enthalten ist, unter Verwendung der Hypothesen der \texttt{\$p}-Anweisung und der vorherigen Behauptungen.  Die Konstruktion erfolgt nach genauen Regeln.  Wenn die Liste der Label im Beweis gegen diese Regeln verstößt oder wenn die sich ergebende Endsequenz nicht mit der Behauptung übereinstimmt, gibt das Metamath-Programm eine Fehlermeldung aus.

Wenn Sie mit der umgekehrten polnischen Notation (engl. "`reverse Polish notation"'; RPN) vertraut sind, die manchmal auf Taschenrechnern verwendet wird, wissen Sie, wie ein Beweis in Kurzform funktioniert.  Jedes Hypothesenlabel\index{Hypothesenlabel} im Beweis wird auf den RPN-Stapel\index{Stapel}\index{RPN-Stapel} geschoben\index{schieben} sobald es auftaucht. Jedes Label einer Behauptung\index{Behauptungslabel} entfernt\index{entfernen} so viele
Einträge vom Stapel, wie die referenzierte Behauptung zwingende Hypothesen hat.  Variablenersetzungen\index{Substitution!Variable}\index{Variablensubstitution} werden
aus den obligatorischen Hypothesen der referenzierten Behauptung so berechnet, dass diese Hypothesen mit den Stack-Einträgen übereinstimmen. Die gleichen Substitutionen
werden dann an den Variablen in der referenzierten Aussage selbst vorgenommen, die dann auf den Stapel abgelegt wird.  Am Ende des Beweises sollte es nur noch einen Eintrag im Stapel geben, nämlich die zu beweisende Behauptung.  Dieser Vorgang wird im Abschnitt~\ref{proof} ausführlich erläutert.

Die Beweisnotation von Metamath ist für Menschen nicht einfach lesbar, aber sie erlaubt es, den Beweis kompakt in einer Datei zu speichern.  Das Programm Metamath\index{Metamath} hat Funktionen zur Anzeige von Beweisen in einer lesbareren Art, mit der man besser sehen kann, was vor sich geht, wie Sie im nächsten Abschnitt sehen werden.

Die Regeln, die bei der Überprüfung eines Beweises verwendet werden, basieren weder auf einer eingebauten Syntax der Symbolsequenz in einer Behauptung noch auf irgendwelchen eingebauten Bedeutungen, die mit bestimmten Symbolnamen verbunden sind.  Sie basieren ausschließlich auf Symbolübereinstimmungen: Konstanten\index{Konstante} müssen mit sich selbst übereinstimmen, und Variablen\index{Variable} können durch alles ersetzt werden, was eine Übereinstimmung ermöglicht.  Anstelle von \texttt{term}, \texttt{0} und \verb$|-$ könnten wir zum Beispiel ebenso gut \texttt{gelb}, \texttt{Null} und \texttt{beweisbar} verwenden, solange wir dies in der gesamten Datenbasis einheitlich tun.  Wir hätten auch \texttt{ist beweisbar} (zwei Token) anstelle von \verb$|-$ (ein Token) in der gesamten Datenbasis verwenden können.  In jedem dieser Fälle wäre der Beweis genau derselbe.  Die Unabhängigkeit von Beweisen und Notation bedeutet, dass Sie viele Möglichkeiten haben die verwendete Notation zu ändern, ohne die Beweise ändern zu müssen.

\section{Ein Probelauf}\label{trialrun}

Jetzt sind Sie bereit, das Metamath\index{Metamath}-Programm auszuprobieren.

Metamath verfügt auf allen Computersystemen über eine standardmäßige "`Befehlszeilen Schnittstelle"' (command line interface; CLI)\index{Befehlszeilenschnittstelle (CLI)}, die es Ihnen ermöglicht, mit dem Programm zu interagieren.
Sie geben Befehle in die CLI ein, indem Sie sie auf der Tastatur eintippen und nach jeder Zeile die {\em Eingabe}-Taste Ihrer Tastatur drücken.
Die CLI ist einfach zu bedienen und verfügt über integrierte Hilfe-Funktionen.

Als erstes sollten Sie einen Texteditor verwenden, um eine Datei mit dem Namen \texttt{demo0.mm} zu erstellen und in diese den Metamath-Quelltext einzugeben, der auf S.~\pageref{demo0} gezeigt wird.  Eigentlich ist diese Datei im Metamath Software-Paket enthalten, also überprüfen Sie das zuerst.  Wenn Sie den Quelltext eintippen, stellen Sie sicher, dass Sie ihn in Form von "`reinem {\sc ascii} Text mit Zeilenumbrüchen"' speichern.  Die meisten Textverarbeitungsprogramme verfügen über diese Funktion.

Als nächstes müssen Sie das Metamath-Programm ausführen.  Abhängig von Ihrem Computer
System und der Art der Installation von Metamath kann dies von einem Mausklick auf das Metamath-Symbol, die Eingabe von \texttt{run metamath} oder durch die einfache Eingabe von \texttt{metamath} reichen.  (Der Befehl {\tt help invoke} von Metamath beschreibt
alternative Möglichkeiten, das Metamath-Programm aufzurufen.)

Wenn Sie Metamath\index{Metamath} zum ersten Mal eingeben, befindet es sich in der CLI und wartet auf Ihre Eingabe. Auf Ihrem Bildschirm sehen Sie dann etwas wie das Folgende:
\begin{verbatim}
Metamath - Version 0.177 27-Apr-2019
Type HELP for help, EXIT to exit.
MM>
\end{verbatim}
Die Eingabeaufforderung \texttt{MM>} bedeutet, dass Metamath auf einen Befehl wartet.
Bei Befehlsschlüsselwörtern wird nicht zwischen Groß- und Kleinschreibung unterschieden; wir werden in unseren Beispielen Befehle in Kleinbuchstaben verwenden.
Die Versionsnummer und das Veröffentlichungsdatum werden auf Ihrem System wahrscheinlich von der oben gezeigten Version abweichen.

Als erstes müssen Sie Ihre Datenbasis einlesen:\index{\texttt{read}-Befehl}\footnote{Wenn in Unix\index{Unix-Dateinamen}\index{Dateinamen!Unix} ein Verzeichnispfad benötigt wird, sollten Sie den Pfad/Dateinamen in Anführungszeichen setzen, damit Metamath nicht denkt, dass das \texttt{/} im Pfadnamen ein Befehlszeilenparameter ist, z.B., \texttt{read \char`\"`db/set.mm\char`\"'}.  Anführungszeichen sind optional, wenn keine Zweideutigkeit besteht.}
\begin{verbatim}
MM> read demo0.mm
\end{verbatim}
Denken Sie daran, nach der Eingabe dieses Befehls die {\em Eingabe}taste zu drücken.  Wenn Sie den Dateinamen weglassen, wird Metamath Sie nach einem Namen fragen.   Die Syntax für die Angabe eines Macintosh-Dateipfades ist in einer Fußnote auf
S.~\pageref{includef}.\index{Macintosh-Dateinamen}\index{Dateinamen!Macintosh} zu finden.

Wenn es in der Datenbasis Syntaxfehler gibt, wird Metamath Sie beim Einlesen der Datei darauf hinweisen.  Das Einzige, was Metamath beim Einlesen einer Datenbasis nicht prüft, ist die Korrektheit aller Beweise, denn das würde es zu sehr verlangsamen.
Es ist jedoch ratsam, die Beweise in einer Datenbasis, an der Sie Änderungen vornehmen, regelmäßig zu überprüfen.
Verwenden Sie dazu den folgenden Befehl (und führen Sie ihn jetzt für Ihre Datei \texttt{demo0.mm} aus).  Beachten Sie, dass \texttt{*} ein `Platzhalter"' ist, der alle Beweise in der Datei repräsentiert.\index{\texttt{verify proof}-Befehl}
\begin{verbatim}
MM> verify proof *
\end{verbatim}
Metamath meldet alle ungültigen Beweise.

Es ist oft nützlich, die Informationen zu speichern, die das Metamath-Programm auf dem Bildschirm anzeigt. Sie können alles speichern, was auf dem Bildschirm passiert, indem Sie eine Protokolldatei öffnen. Sie sollten dies tun, bevor Sie eine Datenbasis einlesen, damit Sie später eventuelle Fehler untersuchen können.  Um eine Protokolldatei zu öffnen, geben Sie Folgendes ein:
\begin{verbatim}
MM> open log abc.log
\end{verbatim}
Dadurch wird eine Datei namens \texttt{abc.log} geöffnet, und alles, was ab diesem Zeitpunkt auf dem Bildschirm erscheint, wird in dieser Datei gespeichert.  Der Name der Protokolldatei ist frei wählbar. Um die Protokolldatei zu schließen, geben Sie Folgendes ein:
\begin{verbatim}
MM> close log
\end{verbatim}

Sie können mit mehreren Befehlen untersuchen, was in Ihrer Datenbasis enthalten ist.
Abschnitt~\ref{exploring} enthält eine Übersicht über einige nützliche Befehle.  Der Befehl \texttt{show labels} lässt Sie sehen, welche Label\index{Label} vorhanden sind.  Ein \texttt{*} entspricht einer beliebigen Kombination von Zeichen, und \texttt{t*} bezieht sich auf alle Labels, die mit dem Buchstaben \texttt{t}\index{\texttt{show labels}-Befehl} beginnen. Das \texttt{/all} ist ein "`Befehlszeilenparameter"' \index{Befehlszeilenparameter}, der Metamath anweist, die Beschriftungen der Hypothesen einzuschließen.  (Um die Syntax erklärt zu bekommen, geben Sie\texttt{help show labels} ein .)  

Geben Sie Folgendes ein:
\begin{verbatim}
MM> show labels t* /all
\end{verbatim}

Metamath antwortet mit
\begin{verbatim}
The statement number, label, and type are shown.
3 tt $f       4 tr $f       5 ts $f       8 tze $a
9 tpl $a      19 th1 $p
\end{verbatim}

Sie können den Befehl \texttt{show statement} verwenden, um Informationen über eine bestimmte Anweisung\index{\texttt{show statement}-Befehl} zu erhalten.
Sie können zum Beispiel Informationen über die Anweisung mit der Bezeichnung \texttt{mp} bekommen, wenn Sie Folgendes eingeben:
\begin{verbatim}
MM> show statement mp /full
\end{verbatim}
Metamath antwortet mit
\begin{verbatim}
  Statement 17 is located on line 43 of the file
  "demo0.mm".
  "Define the modus ponens inference rule"
  17 mp $a |- Q $.
  Its mandatory hypotheses in RPN order are:
    wp $f wff P $.
    wq $f wff Q $.
    min $e |- P $.
    maj $e |- ( P -> Q ) $.
  The statement and its hypotheses require the
        variables:  Q P
  The variables it contains are:  Q P
\end{verbatim}
Die obligatorischen Hypothesen\index{obligatorische Hypothese} und ihre Reihenfolge\index{RPN-Reihenfolge} sind nützliche Informationen, wenn Sie versuchen, einen Beweis zu verstehen oder zu debuggen.

Jetzt sind Sie bereit, sich anzusehen, was wirklich in unserem Beweis enthalten ist.  Zunächst wird hier gezeigt, wie man sich jeden Schritt des Beweises ansieht - nicht nur die Schritte eines gewöhnlichen formalen Beweises\index{formaler Beweis}, sondern auch diejenigen, die die Formeln aufbauen, die in jedem Schritt eines gewöhnlichen formalen Beweises auftauchen.\index{\texttt{show proof}-Befehl}
\begin{verbatim}
MM> show proof th1 /lemmon /all
\end{verbatim}

Dadurch wird der Beweis in folgendem Format auf dem Bildschirm angezeigt:
\begin{verbatim}
 1 tt            $f term t
 2 tze           $a term 0
 3 1,2 tpl       $a term ( t + 0 )
 4 tt            $f term t
 5 3,4 weq       $a wff ( t + 0 ) = t
 6 tt            $f term t
 7 tt            $f term t
 8 6,7 weq       $a wff t = t
 9 tt            $f term t
10 9 a2          $a |- ( t + 0 ) = t
11 tt            $f term t
12 tze           $a term 0
13 11,12 tpl     $a term ( t + 0 )
14 tt            $f term t
15 13,14 weq     $a wff ( t + 0 ) = t
16 tt            $f term t
17 tze           $a term 0
18 16,17 tpl     $a term ( t + 0 )
19 tt            $f term t
20 18,19 weq     $a wff ( t + 0 ) = t
21 tt            $f term t
22 tt            $f term t
23 21,22 weq     $a wff t = t
24 20,23 wim     $a wff ( ( t + 0 ) = t -> t = t )
25 tt            $f term t
26 25 a2         $a |- ( t + 0 ) = t
27 tt            $f term t
28 tze           $a term 0
29 27,28 tpl     $a term ( t + 0 )
30 tt            $f term t
31 tt            $f term t
32 29,30,31 a1   $a |- ( ( t + 0 ) = t -> ( ( t + 0 )
                                     = t -> t = t ) )
33 15,24,26,32 mp  $a |- ( ( t + 0 ) = t -> t = t )
34 5,8,10,33 mp  $a |- t = t
\end{verbatim}

Der Befehlszeilenparameter \texttt{/lemmon} spezifiziert eine Anzeige im sogenannten Lemmon-Stil\index{Lemmon-Stil Beweis}\index{Beweis!Lemmon-Stil}.  Das Weglassen der Option \texttt{/lemmon} führt zu einer Baumdarstellung des Beweises (siehe S.~\pageref{treeproof} für ein Beispiel), der etwas weniger eindeutig ist, aber leichter zu folgen ist, wenn man sich daran gewöhnt hat.\index{Baumdarstellung eines Beweises}\index{Beweis!Baumdarstellung}

Die erste Zahl in jeder Zeile ist die Schrittnummer des Beweises.  Alle folgenden Zahlen sind Schrittnummern, die den Hypothesen der Aussage zugeordnet sind, auf die dieser Schritt verweist.  Die nächste Zahl ist die Bezeichnung der, auf die der Schritt verweist.  Der Typ der Aussage, auf die verwiesen wird, kommt als nächstes, gefolgt von der Folge mathematischer Symbole\index{mathematisches Symbol}, die durch den Beweis bis zu diesem Schritt konstruiert wurde.

Der letzte Schritt, 34, enthält die Aussage, die bewiesen wird.

Betrachtet man einen kleinen Teil des Beweises, so stellt man fest, dass die Schritte 3 und 4 aussagen, dass \texttt{( t + 0 )} und \texttt{t} \texttt{term}\,e sind, und Schritt 5 nutzt die Schritte 3 und 4, um festzustellen, dass \texttt{( t + 0 ) = t} eine \texttt{wff} ist.  Lassen Sie Metamath selbst im Detail erklären, was in Schritt 5 geschieht.  Beachten Sie, dass die "`Zielhypothese"' sich darauf bezieht, wo Schritt 5 letztendlich verwendet wird, d.h. in Schritt 34.
\begin{verbatim}
MM> show proof th1 /detailed_step 5
Proof step 5:  wp=weq $a wff ( t + 0 ) = t
This step assigns source "weq" ($a) to target "wp"
($f).  The source assertion requires the hypotheses
"tt" ($f, step 3) and "tr" ($f, step 4).  The parent
assertion of the target hypothesis is "mp" ($a,
step 34).
The source assertion before substitution was:
    weq $a wff t = r
The following substitutions were made to the source
assertion:
    Variable  Substituted with
     t         ( t + 0 )
     r         t
The target hypothesis before substitution was:
    wp $f wff P
The following substitution was made to the target
hypothesis:
    Variable  Substituted with
     P         ( t + 0 ) = t
\end{verbatim}

Der soeben gezeigte vollständige Beweis ist nützlich für das Verständnis, was im Detail vor sich geht.
Die meiste Zeit werden Sie jedoch nur an den "`wesentlichen"' oder logischen Schritten eines Beweises, d.h. die Schritte, die einem gewöhnlichen formalen Beweisindex\index{formaler Beweis} entsprechen, interessiert sein.  Wenn Sie Folgendes eingeben
\begin{verbatim}
MM> show proof th1 /lemmon /renumber
\end{verbatim}
dann sehen Sie\label{demoproof}
\begin{verbatim}
1 a2             $a |- ( t + 0 ) = t
2 a2             $a |- ( t + 0 ) = t
3 a1             $a |- ( ( t + 0 ) = t -> ( ( t + 0 )
                                     = t -> t = t ) )
4 2,3 mp         $a |- ( ( t + 0 ) = t -> t = t )
5 1,4 mp         $a |- t = t
\end{verbatim}
Vergleichen Sie dies mit dem formalen Beweis auf S.~\pageref{zeroproof} und beachten Sie die Ähnlichkeit.
Standardmäßig zeigt Metamath für einen Beweis nicht \texttt{\$f}\index{\texttt{\$f}-Anweisung}-Hypothesen und alles, was von ihnen im Beweisbaum abzweigt; dadurch sieht der Beweis eher wie ein gewöhnlicher mathematischen Beweis aus, der normalerweise keine explizite Konstruktion von Ausdrücken beinhaltet.
Dies wird die "`essentielle"' Ansicht genannt (früher musste man den Parameter \texttt{/essential} im Befehl \texttt{show proof} hinzufügen, um diese Ansicht zu erhalten, aber das ist jetzt die Standardeinstellung).
Sie können den Parameter \texttt{/all} im Befehl \texttt{show proof} verwenden, um auch die explizite Konstruktion von Ausdrücken anzuzeigen.
Durch den Parameter \texttt{/renumber} werden die Schritte neu nummeriert, damit sie dem entsprechen, was angezeigt wird.\index{\texttt{show proof}-Befehl}

Um Metamath zu verlassen, geben Sie Folgendes ein:\index{\texttt{exit}-Befehl}
\begin{verbatim}
MM> exit
\end{verbatim}

\subsection{Einige Hinweise zur Verwendung der Befehlszeilenschnittstelle}

Wir schließen diese kurze Einführung in Metamath\index{Metamath} mit einigen hilfreichen Hinweisen, wie Sie sich durch die Befehle navigieren können.
\index{Befehlszeilenschnittstelle (CLI)}

Wenn Sie Befehle in Metamaths CLI eingeben, müssen Sie nur so viele Zei\-chen eines Befehlsschlüsselworts\index{Befehlsschlüsselwort} eingeben, die für die Eindeutigkeit notwendig sind.  Wenn Sie zu wenige Zeichen eingeben, wird Metamath Ihnen mitteilen, welche die Auswahlmöglichkeiten sind.  Im Fall des Befehls \texttt{read} ist nur das \texttt{r} nötigt, um ihn eindeutig zu spezifizieren. Sie hätten also Folgendes eingeben können\index{\texttt{read}-Befehl}

\begin{verbatim}
MM> r demo0.mm
\end{verbatim}

anstelle von

\begin{verbatim}
MM> read demo0.mm
\end{verbatim}

In unserer Beschreibung geben wir immer die vollständigen Befehlswörter an.  Bei Verwendung der Metamath CLI-Befehle in einer Befehlsdatei (zum Einlesen mit dem Befehl \texttt{submit})\index{\texttt{submit}-Befehl}, ist es ratsam, den ungekürzten Befehl zu verwenden, um sicherzustellen, dass Ihre Anweisungen nicht mehrdeutig werden, wenn dem Metamath-Programm in Zukunft weitere Befehle hinzugefügt werden.

Die Befehlsschlüsselwörter\index{Befehlsschlüsselwort} unterscheiden nicht zwischen Groß- und Kleinschreibung; Sie können entweder \texttt{read} oder \texttt{ReAd} eingeben.  Bei Dateinamen wird je nach Betriebssystem Ihres Computers zwischen Groß- und Kleinschreibung unterschieden.
Metamath Label\index{Label} und mathematische Symbole\index{mathematisches Symbol}-Tokens\index{Token} unterscheiden zwischen Groß- und Kleinschreibung.

Der Befehl \texttt{help}\index{\texttt{help}-Befehl} bietet Ihnen eine Liste der Themen, zu denen Sie Hilfe erhalten können.  Sie können dann \texttt{help} {\em topic} eingeben, um Hilfe zu diesem Thema zu erhalten.

Wenn Sie sich über die Schreibweise eines Befehls nicht sicher sind, geben Sie einfach die Zeichen des Befehls ein, an die Sie sich erinnern.
Wenn Sie nicht genug Zeichen eingetippt haben, um ihn eindeutig zu spezifizieren, wird Metamath Ihnen sagen, welche Auswahlmöglichkeiten Sie haben.

\begin{verbatim}
MM> show s
         ^
?Ambiguous keyword - please specify SETTINGS,
STATEMENT, or SOURCE.
\end{verbatim}

Wenn Sie nicht wissen, welches Argument Sie als Teil eines Befehls verwenden sollen, geben Sie ein \texttt{?}\index{\texttt{]}@\texttt{?}\ in Befehlszeilen}\ an der
Position des Arguments ein.  Metamath wird Ihnen sagen, was es dort erwartet.

\begin{verbatim}
MM> show ?
         ^
?Expected SETTINGS, LABELS, STATEMENT, SOURCE, PROOF,
MEMORY, TRACE_BACK, or USAGE.
\end{verbatim}

Schließlich können Sie auch nur das erste Wort oder die ersten Wörter eines Befehls eingeben, gefolgt von {\em return}.  Metamath fragt Sie nach dem restlichen Teil des Befehls und zeigt Ihnen bei jedem Schritt die Auswahlmöglichkeiten an. Sie könnten anstelle der Eingabe von \texttt{show statement th1 /full} beispielsweise folgendermaßen vorgehen:
\begin{verbatim}
MM> show
SETTINGS, LABELS, STATEMENT, SOURCE, PROOF,
MEMORY, TRACE_BACK, or USAGE <SETTINGS>? st
What is the statement label <th1>?
/ or nothing <nothing>? /
TEX, COMMENT_ONLY, or FULL <TEX>? f
/ or nothing <nothing>?
19 th1 $p |- t = t $= ... $.
\end{verbatim}

Nach jedem \texttt{?}\ in diesem Modus müssen Sie Metamath die Informationen geben, die es anfordert.  Manchmal gibt Metamath Ihnen eine Liste von Auswahlmöglichkeiten an, wobei die Standardauswahl durch Klammern \texttt{< > } angezeigt wird. Durch das Drücken von {\em return} nach dem \texttt{?}\, wird die Standardauswahl ausgewählt.
Wenn Sie eine andere Antwort geben, wird die Standardauswahl außer Kraft gesetzt.  Beachten Sie, dass der \texttt{/} in Befehlszeilenparametern als ein separates Token\index{Token} betrachtet wird und deshalb separat abgefragt wird.

\section{Ihr erster Beweis}\label{frstprf}

Beweise werden mit Hilfe des Beweis-Assistenten\index{Beweis-Assistent} erstellt.
Wir werden Ihnen nun zeigen, wie der Beweis des Satzes \texttt{th1} aufgebaut wurde.  Damit Sie diese Schritte selbst nachvollziehen können, lassen wir zunächst den Beweis-Assistenten den Beweis im Quellpuffer\index{Quellpuffer} von Metamath löschen und ihn dann rekonstruieren.  (Der Quellpuffer ist die Stelle im Speicher wo Metamath die Informationen aus der Datenbasis speichert, wenn sie eingelesen werden (mit dem \texttt{read} Befehl\index{\texttt{read}-Befehl}).  Neue oder geänderte Beweise
werden im Quellpuffer gehalten, bis ein \texttt{write source} Befehl\index{\texttt{write source}-Befehl} erteilt wird).  In der Praxis würde man ein \texttt{?}\index{\texttt{]}@\texttt{?}\ innerhalb von Beweisen} zwischen \texttt{\$=}\index{\texttt{\$=} Schlüsselwort} und
\texttt{\$.}\index{\texttt{\$.} Schlüsselwort}\ in der Datenbasis platzieren, um Metamath\index{Metamath} mitzuteilen, dass der Beweis unbekannt ist, und das wäre Ihr Ausgangspunkt.  Wann immer der Befehl \texttt{verify proof} auf einen Beweis mit einem \texttt{?}\ anstelle eines Beweisschritts trifft, wird die Aussage als nicht bewiesen gekennzeichnet.

Als ich anfing, Metamath-Beweise zu erstellen, habe ich mir auf ein Stück Papier den vollständigen formalen Beweis, wie er mit einem \texttt{show proof} Befehl\index{\texttt{show proof}-Befehl} ausgegeben würde (siehe die Anzeige von \texttt{show proof th1 /lemmon /re\-num\-ber} oben als ein Beispiel).  Nachdem Sie sich an den Umgang mit dem Beweis-Assistenten\index{Beweis-Assistent} gewöhnt haben, können Sie den Beweis in Ihrem Kopf "`sehen"' und sich beim Ausfüllen der Details vom Beweis-Assistenten leiten lassen, zumindest bei einfacheren Beweisen. Aber bis Sie diese Erfahrung gesammelt haben, können es für die sehr hilfreich sein alle Details vorher aufzuschreiben.
Andernfalls könnten viel Zeit verschwendet werden, wenn Sie sich vom Assistenten auf einen falschen Weg führen lassen.
Andere finden diesen Ansatz jedoch nicht so hilfreich.
Zum Beispiel findet Thomas Brendan Leahy\index{Leahy, Thomas Brendan}, dass es für ihn hilfreicher ist, interaktiv rückwärts von einer maschinenlesbaren Aussage zu arbeiten.
David A. Wheeler\index{Wheeler, David A.} schreibt sich zuerst einen allgemeinen Ansatz auf, entwickelt den Beweis aber interaktiv durch Umschalten zwischen
vorwärts (ausgehend von Hypothesen und Fakten, die nützlich sein könnten) und rückwärts (vom Ziel ausgehend), bis sich die vorwärts- und rückwärtsgerichteten Ansätze treffen.
Am Ende sollten Sie den Ansatz wählen, der für Sie am besten geeignet ist.

Ein Beweis wird mit dem Beweis-Assistenten entwickelt, indem rückwärts gearbeitet wird, beginnend mit dem zu beweisenden Theorem\index{Theorem}. Danach wird jeder unbekannte Schritt einem Theorem oder einer Hypothese zugeordnet, bis keine unbekannten Schritte mehr übrig bleiben.  Der Beweis-Assistent lässt Sie nur dann eine Zuordnung vornehmen, wenn diese mit dem unbekannten Schritt "`vereinheitlicht"' werden kann.  Das bedeutet, dass eine Substitution\index{Substitution!Variable}\index{Variablensubstitution} von Variablen existiert, die die Zuordnung mit dem unbekannten Schritt übereinstimmen lässt.  Andererseits ist in der Mitte eines Beweises, wenn man rückwärts arbeitet, oft mehr als eine Vereinheitlichung\index{Vereinheitlichung} (Menge von Substitutionen) möglich, da zu diesem Zeitpunkt nicht genügend Informationen vorhanden sind, um sie eindeutig zu bestimmen.  In diesem Fall kann man Metamath mitteilen, welche Vereinheitlichung zu wählen ist, oder man kann weiterhin unbekannte Schritte zuweisen, bis genügend Informationen verfügbar sind, um die Vereinheitlichung eindeutig zu machen.

Wir gehen davon aus, dass Sie Metamath gestartet und die Datenbasis wie oben beschrieben eingelesen haben.  Der folgende Dialog zeigt, wie der Beweis erstellt wird.  Weitere Einzelheiten zu den Funktionen einiger Befehle finden Sie in Abschnitt~\ref{pfcommands}. \index{\texttt{prove}-Befehl}

\begin{verbatim}
MM> prove th1
Entering the Proof Assistant.  Type HELP for help, EXIT
to exit.  You will be working on the proof of statement th1:
  $p |- t = t
Note:  The proof you are starting with is already complete.
MM-PA>
\end{verbatim}

Die Eingabeaufforderung \verb/MM-PA>/ bedeutet, dass wir uns innerhalb des Beweis-Assistenten\index{Beweis-Assistent} befinden. Die meisten der regulären Metamath-Befehle (\texttt{show statement}, etc.) sind weiterhin verfügbar, falls Sie sie benötigen.

\begin{verbatim}
MM-PA> delete all
The entire proof was deleted.
\end{verbatim}

Wir haben den gesamten Beweis gelöscht, damit wir von vorne beginnen können.

\begin{verbatim}
MM-PA> show new_proof/lemmon/all
1 ?              $? |- t = t
\end{verbatim}

Der Befehl \texttt{show new{\char`\_}proof}\index{\texttt{show new{\char`\_}proof}-Befehl} verhält sich wie \texttt{show proof}, außer dass wir keine Aussage angeben; stattdessen wird der Beweis, an dem wir gerade arbeiten, angezeigt.

\begin{verbatim}
MM-PA> assign 1 mp
To undo the assignment, DELETE STEP 5 and INITIALIZE, UNIFY
if needed.
3   min=?  $? |- $2
4   maj=?  $? |- ( $2 -> t = t )
\end{verbatim}

Der obige \texttt{assign}-Befehl\index{\texttt{assign}-Befehl} bedeutet "`Weise die Aussage mit der Bezeichnung \texttt{mp} dem Schritt 1 zu."'  Beachten Sie, dass die Schritte ständig neu nummeriert werden, wenn Sie Schritte in der Mitte eines Beweises zuweisen; im Allgemeinen werden alle Schritte von dem Schritt, den Sie zuweisen, bis zum Ende des Beweises nach oben verschoben.  In diesem Fall ist der frühere Schritt 1 jetzt Schritt 5, weil der (Teil-)Beweis jetzt fünf Schritte hat: die vier Hypothesen der \texttt{mp}-Aussage und die \texttt{mp} Aussage selbst.  Schauen wir uns alle Schritte in unserem Teilbeweis an:

\begin{verbatim}
MM-PA> show new_proof/lemmon/all
1 ?              $? wff $2
2 ?              $? wff t = t
3 ?              $? |- $2
4 ?              $? |- ( $2 -> t = t )
5 1,2,3,4 mp     $a |- t = t
\end{verbatim}

Das Symbol \texttt{\$2} ist eine temporäre Variable\index{temporäre Variable}, die eine noch nicht bekannte Symbolfolge darstellt.  In dem endgültigen Beweis müssen alle temporären Variablen eliminiert sein.  Das allgemeine Format für eine temporäre Variable ist \texttt{\$} gefolgt von einer ganzen Zahl.  Beachten Sie, dass \texttt{\$} kein zulässiges Zeichen in einem mathematischen Symbol ist (siehe Abschnitt~\ref{dollardollar}, S.~\pageref{dollardollar}), also wird es niemals einen Namenskonflikt zwischen realen Symbolen und temporären Variablen geben.

Die unbekannten Schritte 1 und 2 sind Konstruktionen der beiden wffs, die von dem Modus ponens verwendet werden.  Wie Sie am Ende dieses Abschnitts sehen werden, kann der Beweis-Assistent\index{Beweis-Assistent} diese Schritte normalerweise selbst herausfinden, und wir müssen uns nicht um sie kümmern.  Deshalb werden wir von hier an nur noch die "`essentiellen"' Hypothesen anzeigen, d.h. die Schritte, die den traditionellen formalen Beweisen\index{formaler Beweis} entsprechen.

\begin{verbatim}
MM-PA> show new_proof/lemmon
3 ?              $? |- $2
4 ?              $? |- ( $2 -> t = t )
5 3,4 mp         $a |- t = t
\end{verbatim}

Die unbekannten Schritte 3 und 4 sind die, auf die wir uns konzentrieren müssen.  Sie entsprechen den Neben- und Hauptprämissen des Modus ponens.  Wir werden sie wie folgt zuordnen.  Beachten Sie, dass es wegen der Neunummerierung der Schritte nach einer Zuordnung vorteilhaft ist, die unbekannten Schritte in umgekehrter Reihenfolge zuzuordnen, da frühere Schritte nicht neu nummeriert werden.

\begin{verbatim}
MM-PA> assign 4 mp
To undo the assignment, DELETE STEP 8 and INITIALIZE, UNIFY
if needed.
3   min=?  $? |- $2
6     min=?  $? |- $4
7     maj=?  $? |- ( $4 -> ( $2 -> t = t ) )
\end{verbatim}

Wir werden jetzt eine obskure Funktionalität beschreiben, die Sie wahr\-schein\-lich nie benutzen werden, die Sie aber kennen sollten.  Die Metamath-Sprache erlaubt es, dass Variable durch leere Symbolsequenzen ersetzt werden können, aber in den meisten formalen Systemen wird dies nie eingesetzt.  Eines der wenigen Beispiele, in denen sie verwendet wird, ist das MIU-System\index{MIU-System}, das in Anhang~\ref{MIU} beschrieben wird.  Aber solche Systeme sind selten, und standardmäßig ist diese Funktion im Beweis-Assistenten ausgeschaltet (sie ist immer erlaubt für {\tt verify proof}).  Schalten wir sie ein und schauen, was was passiert.\index{\texttt{set empty{\char`\_}substitution}-Befehl}

\begin{verbatim}
MM-PA> set empty_substitution on
Substitutions with empty symbol sequences is now allowed.
\end{verbatim}

Wenn diese Funktionalität aktiviert ist, werden mehr Vereinheitlichungen in der Mitte eines Beweises mehrdeutig\index{mehrdeutige Vereinheitlichung}\index{Vereinheitlichung!mehrdeutig} sein, weil die Substitution\index{Substitution!Variable}\index{Variablensubstitution} von Variablen mit leeren Symbolfolgen eine zusätzliche Möglichkeit darstellt.  Schauen wir uns an, was passiert, wenn wir unsere nächste Zuweisung vornehmen.

\begin{verbatim}
MM-PA> assign 3 a2
There are 2 possible unifications.  Please select the correct
    one or Q if you want to UNIFY later.
Unify:  |- $6
 with:  |- ( $9 + 0 ) = $9
Unification #1 of 2 (weight = 7):
  Replace "$6" with "( + 0 ) ="
  Replace "$9" with ""
  Accept (A), reject (R), or quit (Q) <A>? r
\end{verbatim}

Die erste der vorgestellten Möglichkeiten ist die falsche.  Hätten wir sie gewählt, wäre der temporären Variablen \texttt{\$6} eine abgeschnittene wff, und der temporären Variablen \texttt{\$9} eine leere Folge zugewiesen worden (was in unserem System nicht zulässig ist).  Bei dieser Wahl kämen wir irgendwann an einen Punkt, an dem wir nicht mehr weiterkämen, weil wir mit Schritten enden würden, die nicht mehr zu beweisen sind.  (Probieren Sie es aus.) Wir haben \texttt{r} eingegeben, um die Wahl zu verwerfen.

\begin{verbatim}
Unification #2 of 2 (weight = 21):
  Replace "$6" with "( $9 + 0 ) = $9"
  Accept (A), reject (R), or quit (Q) <A>? q
To undo the assignment, DELETE STEP 4 and INITIALIZE, UNIFY
if needed.
 7     min=?  $? |- $8
 8     maj=?  $? |- ( $8 -> ( $6 -> t = t ) )
\end{verbatim}

Die zweite Wahlmöglichkeit ist richtig, und normalerweise würden wir \texttt{a} eingeben, um sie zu akzeptieren.  Stattdessen haben wir \texttt{q} eingegeben, um zu zeigen, was passieren wird: Der Schritt wird mit einer unbekannten Vereinheitlichung verlassen, die wie folgt aussehen kann:

\begin{verbatim}
MM-PA> show new_proof/not_unified
 4   min    $a |- $6
        =a2  = |- ( $9 + 0 ) = $9
\end{verbatim}

Später können wir diesen Schritt mit dem Befehl \texttt{unify} \texttt{all/interactive} vereinheitlichen.

Es ist wichtig, sich daran zu erinnern, dass Ihnen bei der Eingabe eines Beweises gelegentlich mehrere Vereinheitlichungsmöglichkeiten angeboten werden, wenn das Programm feststellt, dass noch nicht genügend Informationen vorhanden sind, um automatisch eine eindeutige Wahl zu treffen (und das kann sogar bei ausgeschalteter \texttt{set empty{\char`\_}substitution} passieren).  Normalerweise ist es während der Inspektion der Auswahlmöglichkeiten offensichtlich, welche Wahl die richtige ist, da die falsche Wahl zu sinnlosen Fragmenten von wffs führt.  Außerdem ist die richtige Wahl normalerweise die erste, die präsentiert wird, im Gegensatz zu unserem obigen Beispiel.

Genug der Abschweifung.  Kehren wir zur Standardeinstellung zurück.

\begin{verbatim}
MM-PA> set empty_substitution off
The ability to substitute empty expressions for variables
has been turned off.  Note that this may make the Proof
Assistant too restrictive in some cases.
\end{verbatim}

Wenn wir den Beweis löschen, neu beginnen und zu dem Punkt gelangen, an dem wir oben abgeschweift sind, gibt es keine mehrdeutige Vereinheitlichung mehr.

\begin{verbatim}
MM-PA> assign 3 a2
To undo the assignment, DELETE STEP 4 and INITIALIZE, UNIFY
if needed.
 7     min=?  $? |- $4
 8     maj=?  $? |- ( $4 -> ( ( $5 + 0 ) = $5 -> t = t ) )
\end{verbatim}

Schauen wir uns unseren bisherigen Beweis an und fahren wir fort.

\begin{verbatim}
MM-PA> show new_proof/lemmon
 4 a2            $a |- ( $5 + 0 ) = $5
 7 ?             $? |- $4
 8 ?             $? |- ( $4 -> ( ( $5 + 0 ) = $5 -> t = t ) )
 9 7,8 mp        $a |- ( ( $5 + 0 ) = $5 -> t = t )
10 4,9 mp        $a |- t = t
MM-PA> assign 8 a1
To undo the assignment, DELETE STEP 11 and INITIALIZE, UNIFY
if needed.
 7     min=?  $? |- ( t + 0 ) = t
MM-PA> assign 7 a2
To undo the assignment, DELETE STEP 8 and INITIALIZE, UNIFY
if needed.
MM-PA> show new_proof/lemmon
 4 a2            $a |- ( t + 0 ) = t
 8 a2            $a |- ( t + 0 ) = t
12 a1            $a |- ( ( t + 0 ) = t -> ( ( t + 0 ) = t ->
                                                    t = t ) )
13 8,12 mp       $a |- ( ( t + 0 ) = t -> t = t )
14 4,13 mp       $a |- t = t
\end{verbatim}

Nun sind alle temporären Variablen und unbekannten Schritte aus dem "`wesentlichen"' Teil des Beweises entfernt worden.  Wenn dieser Zustand erreicht ist, kann der Beweis-Assistent\index{Beweis-Assistent} den Rest des Beweises in der Regel automatisch bestimmen (angestoßen durch den Befehl \texttt{improve} - beachten Sie, dass der Befehl \texttt{improve} gelegentlich auch zum Ausfüllen wesentlicher Schritte genutzt werden kann. Es wird dabei aber nur versucht Aussagen zu verwenden, die keine neuen Variablen in ihren Hypothesen einführen, was bei \texttt{mp} nicht der Fall ist. Es wird auch nicht versucht, Schritte zu verbessern, die temporäre Variablen enthalten).  Schauen wir uns den vollständigen Beweis nochmals an, führen dann den Befehl \texttt{improve} aus und sehen ihn uns dann noch einmal an.

\begin{verbatim}
MM-PA> show new_proof/lemmon/all
 1 ?             $? wff ( t + 0 ) = t
 2 ?             $? wff t = t
 3 ?             $? term t
 4 3 a2          $a |- ( t + 0 ) = t
 5 ?             $? wff ( t + 0 ) = t
 6 ?             $? wff ( ( t + 0 ) = t -> t = t )
 7 ?             $? term t
 8 7 a2          $a |- ( t + 0 ) = t
 9 ?             $? term ( t + 0 )
10 ?             $? term t
11 ?             $? term t
12 9,10,11 a1    $a |- ( ( t + 0 ) = t -> ( ( t + 0 ) = t ->
                                                    t = t ) )
13 5,6,8,12 mp   $a |- ( ( t + 0 ) = t -> t = t )
14 1,2,4,13 mp   $a |- t = t
\end{verbatim}

\begin{verbatim}
MM-PA> improve all
A proof of length 1 was found for step 11.
A proof of length 1 was found for step 10.
A proof of length 3 was found for step 9.
A proof of length 1 was found for step 7.
A proof of length 9 was found for step 6.
A proof of length 5 was found for step 5.
A proof of length 1 was found for step 3.
A proof of length 3 was found for step 2.
A proof of length 5 was found for step 1.
Steps 1 and above have been renumbered.
CONGRATULATIONS!  The proof is complete.  Use SAVE
NEW_PROOF to save it.  Note:  The Proof Assistant does
not detect $d violations.  After saving the proof, you
should verify it with VERIFY PROOF.
\end{verbatim}

Der \texttt{save new{\char`\_}proof}\index{\texttt{save new{\char`\_}proof}-Befehl} speichert den Beweis in der Datenbasis.  Hier wird er nur in einer Form angezeigt, die aus einer Protokolldatei ausgeschnitten und mit einem Texteditor manuell in die Quelldatei der Datenbasis eingefügt werden kann.\index{normaler Beweis}\index{Beweis!normal}

\begin{verbatim}
MM-PA> show new_proof/normal
---------Clip out the proof below this line:
      tt tze tpl tt weq tt tt weq tt a2 tt tze tpl tt weq
      tt tze tpl tt weq tt tt weq wim tt a2 tt tze tpl tt
      tt a1 mp mp $.
---------The proof of 'th1' to clip out ends above this line.
\end{verbatim}

Es gibt ein weiteres Beweis-Format, der "`komprimierte"' Beweis\index{komprimierter Beweis}\index{Beweis!komprimiert}, das Sie in Datenbasen sehen werden.  Es ist nicht wichtig zu verstehen, wie es kodiert ist, sondern nur es zu erkennen, wenn Sie es sehen.  Sein einziger Zweck ist es, den Speicherbedarf für große Beweise zu verringern.  Ein komprimierter Beweis kann immer in einen normalen umgewandelt werden und umgekehrt, und der Metamath-Befehl \texttt{show proof} funktioniert genauso gut mit komprimierten Beweisen.  Das komprimierte Beweisformat wird im Anhang~\ref{compressed} beschrieben.

\begin{verbatim}
MM-PA> show new_proof/compressed
---------Clip out the proof below this line:
      ( tze tpl weq a2 wim a1 mp ) ABCZADZAADZAEZJJKFLIA
      AGHH $.
---------The proof of 'th1' to clip out ends above this line.
\end{verbatim}

Nun beenden wir den Beweis-Assistenten.  Da wir Änderungen an dem Beweis vorgenommen haben, werden wir gewarnt, dass wir ihn nicht gespeichert haben.  In diesem Fall ist uns das egal.

\begin{verbatim}
MM-PA> exit
Warning:  You have not saved changes to the proof.
Do you want to EXIT anyway (Y, N) <N>? y
Exiting the Proof Assistant.
Type EXIT again to exit Metamath.
\end{verbatim}

Der Beweis-Assistent verfügt über verschiedene andere Befehle, die Ihnen bei der Erstellung von Beweisen helfen können.  Siehe Abschnitt~\ref{pfcommands} für eine Liste dieser Befehle.

Ein oft nützlicher Befehl ist \texttt{minimize{\char`\_}with*/brief}, der versucht, den Beweis zu verkürzen.  Er kann den Prozess des Beweisens effizienter machen, indem er Sie einen etwas "`schlampigen"' Beweis schreiben lässt und ihn dann durch einige feine Optimierungsdetails für Sie bereinigt (obwohl er keine Wunder vollbringen kann, wie z.B. die Umstrukturierung des gesamten Beweises).

\section{\sloppy Hinweise zur Bearbeitung einer Daten\-basis}

Sobald die Quelldatei ihrer Datenbasis Beweise enthält, gibt es einige Einschränkungen für deren Bearbeitung, damit die Beweise gültig bleiben.
Diese Regeln sollten Sie besonders beachten, da Sie sonst mühsam erzielte Ergebnisse verlieren können. Es ist sinnvoll, alle Beweise regelmäßig mit \texttt{verify proof *} zu überprüfen, um ihre Integrität sicherzustellen.

Wenn Ihre Datei nur normale (im Gegensatz zu komprimierten) Beweise enthält, besteht die Hauptregel darin, dass Sie die Reihenfolge der obligatorischen Hypothesen\index{obligatorische Hypothese} im Index einer Aussage, auf die in einem späteren Beweis verwiesen wird, nicht ändern dürfen.  Wenn Sie zum Beispiel die Reihenfolge der Haupt- und Nebenhypothese in dem Modus ponens vertauschen, werden alle Beweise, die diese Regel verwenden, falsch.  Der Befehl \texttt{show statement} \index{\texttt{show statement}-Befehl} zeigt Ihnen die obligatorischen Hypothesen einer Aussage und ihre Reihenfolge.

Wenn eine Aussage einen komprimierten Beweis hat, dürfen Sie auch nicht die Reihenfolge {\em ihrer} obligatorischen Hypothesen ändern.
Das komprimierte Beweisformat verwendet diese Information als Teil der Komprimierungstechnik. Beachten Sie, dass das Vertauschen der Namen zweier Variablen in einem Theorem die Reihenfolge der zwingenden Hypothesen ändert.

Der sicherste Weg, eine Aussage, z. B. \texttt{mytheorem}, zu bearbeiten besteht darin, sie zu duplizieren und das Original in der gesamten Datenbasis in \texttt{mytheoremOLD} umzubenennen.
Sobald die bearbeitete Version erneut bewiesen ist, können alle Aussagen, die auf \texttt{mytheoremOLD} verweisen, im Beweis-Assistenten mit dem Befehl \texttt{minimize{\char`\_}with mytheorem/allow{\char`\_}growth}\index{\texttt{minimize{\char`\_}with}-Befehl} aktualisiert werden.
% 3/10/07 Note: line-breaking the above results in duplicate index entries

\chapter{Abstrakte Mathematik enthüllt}\label{fol}

\section{Logik und Mengenlehre}\label{logicandsettheory}

\begin{quote}
  {\em Die Mengenlehre kann als eine Form einer exakten Theologie betrachtet werden.}
  \flushright\sc  Rudy Rucker\footnote{Frei übersetzt nach \cite{Barrow}, S.~31.}\\
\end{quote}\index{Rucker, Rudy}

Trotz ihrer vermeintlichen Komplexität lässt sich die gesamte Standardmathematik, egal wie tief oder abstrakt sie ist, erstaunlicherweise aus einem relativ kleinen Satz von Axiomen\index{Axiom} oder ersten Prinzipien ableiten. Die Entwicklung dieser Axiome gehört zu den beeindruckendsten und wichtigsten Errungenschaften der Mathematik im 20. Jahrhundert. Letztlich lassen sich diese Axiome in eine Reihe von Regeln für die Handhabung von Symbolen herunterbrechen, denen jeder technisch orientierte Mensch folgen kann.

Wir werden nicht viel Zeit darauf verwenden, ein tiefes, übergeordnetes Verständnis der Bedeutung der Axiome zu vermitteln. Diese Art von Verständnis erfordert ein gewisses Maß an mathematischer Raffinesse sowie ein Verständnis der Philosophie, die den Grundlagen der Mathematik zugrunde liegt, und entwickelt sich in der Regel im Laufe der Zeit, wenn Sie mit Mathematik arbeiten.  Unser Ziel ist es stattdessen, Ihnen die unmittelbare Fähigkeit zu vermitteln zu verstehen, wie Theoreme\index{Theorem} aus den Axiomen und aus anderen Theoremen abgeleitet werden.  Dies ist vergleichbar mit dem Erlernen der Syntax einer Computersprache, die es Ihnen ermöglicht, die Details eines Programms zu verstehen, Ihnen aber nicht unbedingt die Fähigkeit verleiht, nicht-triviale Programme selbst zu schreiben - eine Fähigkeit, die sich erst mit der Zeit entwickelt. Lassen Sie sich vorerst nicht von den abstrakt klingenden Namen der Axiome beunruhigen, sondern konzentrieren Sie sich auf die Regeln zur Manipulation der Symbole, die den einfachen Konventionen der Metamath\index{Metamath}-Sprache folgen.

Die Axiome, die der gesamten Standardmathematik zugrunde liegen, bestehen aus Axiomen der Logik und Axiomen der Mengenlehre. Die Axiome der Logik sind in zwei Unterkategorien unterteilt, die Aussagenlogik\index{Aussagenlogik} (manchmal auch Satzlogik\index{Satzlogik} genannt) und die Prädikatenlogik (manchmal auch Logik erster Ordnung\index{Logik erster Ordnung}\index{Quantifizierungstheorie}\index{Prädikatenlogik} oder Quantentheorie genannt).  Die Aussagenlogik ist eine Voraussetzung für die Prädikatenlogik, und die Prädikatenlogik ist eine Voraussetzung für die Mengenlehre.  Die am häufigsten verwendete Version der Mengenlehre ist die Zermelo--Fraenkel-Mengenlehre\index{Zermelo--Fraenkel-Mengenlehre}\index{Mengenlehre} mit dem Auswahlaxiom (engl. "`axiom of choice"'), oft abgekürzt als ZFC\index{ZFC}.

Hier ist in aller Kürze dargestellt, worum es bei den Axiomen geht, und zwar auf informelle Art und Weise. Die Verbindung zwischen dieser Beschreibung und den Symbolen, die wir Ihnen zeigen werden, wird nicht sofort offensichtlich sein und muss es im Prinzip auch nicht.  Unsere Beschreibung versucht lediglich zusammenzufassen, worüber Mathematiker nachdenken, wenn sie mit den Axiomen arbeiten.

Logik ist eine Reihe von Regeln, die es uns ermöglichen, Wahrheiten aus anderen Wahrheiten abzuleiten. Anders ausgedrückt, ist Logik mehr oder weniger die Übersetzung dessen, was wir als gesunden Menschenverstand betrachten würden, in einen strengen Satz von Axiomen.\index{Axiome der Logik}  Angenommen, $\varphi$, $\psi$ und $\chi$ (die griechischen Buchstaben phi, psi und chi) stehen für Aussagen, die entweder wahr oder falsch sind, und $x$ ist eine Variable\index{Variable!in der Prädikatenlogik}, die sich über eine Gruppe mathematischer Objekte (Mengen, ganze Zahlen, reelle Zahlen usw.) erstreckt. In der Mathematik ist eine "`Aussage"' eigentlich eine Formel, und $\psi$ könnte z.B. "`$x = 2$"' sein. Die Aussagenlogik\index{Aussagenlogik} erlaubt uns, Variablen zu verwenden, die entweder wahr oder falsch sind, und Schlüsse zu ziehen wie:
"`Wenn $\psi$ aus $\varphi$ und $\chi$  aus $\psi$ folgt, dann folgt $\chi$ aus $\varphi$."' Die Prädikatenlogik\index{Prädikatenlogik} erweitert die Aussagenlogik, indem sie auch Aussagen über Objekte (nicht nur über Wahrheitswerte) erlaubt, einschließlich Aussagen über "`alle"' Objekte oder "`wenigstens ein"' Objekt. Die Prädikatenlogik erlaubt es zum Beispiel zu sagen: "`Wenn $\varphi$ für alle $x$ wahr ist, dann ist $\varphi$ für einige $x$ wahr."' Die in \texttt{set.mm} verwendete Logik ist die klassische Standardlogik (im Gegensatz zu anderen Logiksystemen wie der intuitionistischen Logik).

Die Mengenlehre\index{Mengenlehre} befasst sich mit der Handhabung von Objekten und Sammlungen von Objekten, insbesondere mit den abstrakten, imaginären Objekten, mit denen sich die Mathematik beschäftigt, wie z. B. Zahlen. Alles, was es in der Mathematik geben soll, wird als Menge betrachtet.  Eine Menge, die als leere Menge\index{leere Menge} bezeichnet wird, enthält nichts.  Wir stellen die leere Menge durch $\varnothing$ dar.  Viele Mengen können aus der leeren Menge aufgebaut werden.  Es gibt eine durch $\{\varnothing\}$ dargestellte Menge, die die leere Menge enthält, eine weitere durch $\{\varnothing,\{\varnothing\}\}$ dargestellte Menge, die diese Menge sowie die leere Menge enthält, eine weitere durch $\{\{\varnothing\}\}$ dargestellte Menge, die nur die Menge enthält, die die leere Menge enthält, und so weiter ad infinitum. Alle mathematischen Objekte, egal wie komplex sie sind, werden als identisch mit bestimmten Mengen definiert: Die ganze Zahl\index{ganze Zahl} 0 ist definiert als die leere Menge, die ganze Zahl 1 ist definiert als $\{\varnothing\}$, die ganze Zahl 2 ist definiert als $\{\varnothing,\{\varnothing\}\}$.  (Wie diese Definitionen gewählt wurden, spielt jetzt keine Rolle: die Idee dahinter ist, dass diese Mengen die Eigenschaften haben, die wir von ganzen Zahlen erwarten, sobald geeignete Operationen definiert sind.)  Mathematische Operationen, wie z. B. die Addition, werden in Form von Operationen auf Mengen definiert - ihre Vereinigung\index{Vereinigungsmenge}, ihre Schnittmenge\index{Schnittmenge} usw. - Operationen, die Sie vielleicht schon in der Grundschule verwendet haben, als Sie mit Gruppen von Äpfeln und Orangen gearbeitet haben.

Die Axiome postulieren auch die Existenz unendlicher Mengen\index{unendliche Menge}, wie z.B. die Menge aller nichtnegativen ganzen Zahlen ($0, 1,2,\ldots$, auch "`natürliche Zahlen"'\index{natürliche Zahlen} genannt).  Diese Menge kann nicht mit der soeben gezeigten Klammerschreibweise\index{Klammerschreibweise} dargestellt werden, sondern erfordert eine kompliziertere Schreibweise, die "`Klassenabstraktion"'\index{Klassenabstraktion}\index{Abstraktionsklasse}.  Zum Beispiel bedeutet die unendliche Menge $\{ x |\mbox{"`$x$ ist eine natürliche Zahl"'} \} $ die "`Menge aller Objekte $x$, so dass $x$ eine natürliche Zahl ist"', d.h. die Menge der natürlichen Zahlen; dabei ist "`$x$ eine natürliche Zahl"' eine ziemlich komplizierte Formel, wenn man sie mit den primitiven Symbole ausdrückt. \label{expandom}\footnote{Die Aussage "`$x$ ist eine natürliche Zahl"' wird formal ausgedrückt als "`$x \in \omega$"', wobei $\in$ (stilisiertes Epsilon) bedeutet "`ist in"' oder "`ist ein Element von"' und $\omega$ (omega) bedeutet "`die Menge der natürlichen Zahlen"'.  Wenn "`$x\in\omega$"' vollständig durch die primitiven Symbole der Mengenlehre ausgedrückt wird, ist das Ergebnis $\lnot$ $($ $\lnot$ $($ $\forall$ $z$ $($ $\lnot$ $\forall$ $w$ $($$z$ $\in$ $w$ $\rightarrow$ $\lnot$ $w$ $\in$ $x$ $)$ $\rightarrow$ $z$ $\in$$x$ $)$ $\rightarrow$ $($ $\forall$ $z$ $($ $\lnot$ $($ $\forall$ $w$ $($ $w$$\in$ $z$ $\rightarrow$ $w$ $\in$ $x$ $)$ $\rightarrow$ $\forall$ $w$ $\lnot$$w$ $\in$ $z$ $)$ $\rightarrow$ $\lnot$ $\forall$ $w$ $($ $w$ $\in$ $z$$\rightarrow$ $\lnot$ $\forall$ $v$ $($ $v$ $\in$ $z$ $\rightarrow$ $\lnot$$v$ $\in$ $w$ $)$ $)$ $)$ $\rightarrow$ $\lnot$ $\forall$ $z$ $\forall$ $w$$($ $\lnot$ $($ $z$ $\in$ $x$ $\rightarrow$ $\lnot$ $w$ $\in$ $x$ $)$$\rightarrow$ $($ $\lnot$ $z$ $\in$ $w$ $\rightarrow$ $($ $\lnot$ $z$ $=$ $w$$\rightarrow$ $w$ $\in$ $z$ $)$ $)$ $)$ $)$ $)$ $\rightarrow$ $\lnot$$\forall$ $y$ $($ $\lnot$ $($ $\lnot$ $($ $\forall$ $z$ $($ $\lnot$ $\forall$$w$ $($ $z$ $\in$ $w$ $\rightarrow$ $\lnot$ $w$ $\in$ $y$ $)$ $\rightarrow$$z$ $\in$ $y$ $)$ $\rightarrow$ $($ $\forall$ $z$ $($ $\lnot$ $($ $\forall$$w$ $($ $w$ $\in$ $z$ $\rightarrow$ $w$ $\in$ $y$ $)$ $\rightarrow$ $\forall$$w$ $\lnot$ $w$ $\in$ $z$ $)$ $\rightarrow$ $\lnot$ $\forall$ $w$ $($ $w$$\in$ $z$ $\rightarrow$ $\lnot$ $\forall$ $v$ $($ $v$ $\in$ $z$ $\rightarrow$$\lnot$ $v$ $\in$ $w$ $)$ $)$ $)$ $\rightarrow$ $\lnot$ $\forall$ $z$$\forall$ $w$ $($ $\lnot$ $($ $z$ $\in$ $y$ $\rightarrow$ $\lnot$ $w$ $\in$$y$ $)$ $\rightarrow$ $($ $\lnot$ $z$ $\in$ $w$ $\rightarrow$ $($ $\lnot$ $z$$=$ $w$ $\rightarrow$ $w$ $\in$ $z$ $)$ $)$ $)$ $)$ $\rightarrow$ $($$\forall$ $z$ $\lnot$ $z$ $\in$ $y$ $\rightarrow$ $\lnot$ $\forall$ $w$ $($$\lnot$ $($ $w$ $\in$ $y$ $\rightarrow$ $\lnot$ $\forall$ $z$ $($ $w$ $\in$$z$ $\rightarrow$ $\lnot$ $z$ $\in$ $y$ $)$ $)$ $\rightarrow$ $\lnot$ $($$\lnot$ $\forall$ $z$ $($ $w$ $\in$ $z$ $\rightarrow$ $\lnot$ $z$ $\in$ $y$$)$ $\rightarrow$ $w$ $\in$ $y$ $)$ $)$ $)$ $)$ $\rightarrow$ $x$ $\in$ $y$$)$ $)$ $)$. Abschnitt~\ref{hierarchy} zeigt die Hierarchie der Definitionen, die zu diesem Ausdruck führt.}\index{stilisiertes Epsilon ($\in$)}\index{Omega ($\omega$)}  Die primitiven Symbole enthalten tatsächlich noch nicht einmal die Klammerschreibweise.  Die Klammerschreibweise ist eine übergeordnete Definition, die Sie im Abschnitt~\ref{hierarchy} finden können.

Interessanterweise können die Arithmetik der ganzen Zahlen\index{ganze Zahl} und die Arithmetik der rationalen Zahlen\index{rationale Zahl} entwickelt werden, ohne sich auf die Existenz einer unendlichen Menge zu berufen, während die Arithmetik der reellen Zahlen\index{reelle Zahl} dies erfordert.

Jede Variable\index{Variable!in der Mengenlehre} in den Axiomen der Mengenlehre stellt eine beliebige Menge dar, und die Axiome geben auf einer sehr primitiven Ebene die zulässigen Möglichkeiten an, die man mit diesen Variablen tun kann.

Sie denken jetzt vielleicht, dass Zahlen und Arithmetik viel intuitiver und grundlegender sind als Mengen und daher die Grundlage der Mathematik sein sollten. Aber in Wirklichkeit haben Sie Ihr ganzes Leben lang mit Zahlen zu tun gehabt und sind mit einigen Regeln für ihre Handhabung vertraut, wie z. B. Addition und Multiplikation.  Diese Regeln decken nur einen kleinen Teil dessen ab, was man mit Zahlen tun kann, und nur einen winzigen Teil der übrigen Mathematik.  Wenn Sie sich ein beliebiges Buch über Zahlentheorie ansehen, werden Sie schnell verloren sein, wenn dies die einzigen Regeln sind, die Sie kennen.  Auch wenn solche Bücher eine Liste von "`Axiomen"'\index{Axiom} für die Arithmetik enthalten, erfordert die Fähigkeit, die Axiome zu verwenden und Beweise von Theoremen\index{Theorem} (Fakten) über Zahlen zu verstehen - ein implizites mathematisches Talent, das viele Menschen davon abhält, abstrakte Mathematik zu studieren.  Die Art von Mathematik, die die meisten Menschen kennen, beschränkt sie auf den praktischen, alltäglichen Gebrauch der blinden Manipulation von Zahlen und Formeln, ohne dass sie verstehen, warum diese Regeln richtig sind, und ohne weiter darüber nachzudenken.  Wissen Sie zum Beispiel, warum die Multiplikation von zwei negativen Zahlen eine positive Zahl ergibt?  Wenn Sie mit der Mengenlehre beginnen, werden Sie ebenfalls damit beginnen, Symbole blind nach den von uns vorgegebenen Regeln zu manipulieren, allerdings mit dem Vorteil, dass diese Regeln Ihnen im Prinzip den Zugang zur {\em gesamten} Mathematik ermöglichen, nicht nur zu einem winzigen Teil davon.

Natürlich sind konkrete Beispiele oft hilfreich für den Lernprozess. So kann man zum Beispiel überprüfen, dass $2\cdot 3=3 \cdot 2$ ist, indem man Objekte gruppiert, und man kann leicht "`sehen"', wie dies zu $x\cdot y = y\cdot x$ verallgemeinert wird, auch wenn man nicht in der Lage ist, es rigoros zu beweisen.  In ähnlicher Weise kann es in der Mengenlehre hilfreich sein zu verstehen, wie die Axiome der Mengenlehre auf kleine endliche Sammlungen von Objekten anwendbar (und korrekt) sind.  Sie sollten sich darüber im Klaren sein, dass die Intuition in der Mengenlehre für unendliche Sammlungen irreführend sein kann, und dass deshalb strenge Beweise wichtiger werden.  Zum Beispiel ist $x\cdot y = y\cdot x$ zwar für endliche Ordinalzahlen (die natürlichen Zahlen) richtig, aber nicht für unendliche Ordinalzahlen.

\section{Die Axiome für die gesamte Mathematik}

In diesem Abschnitt\index{Axiome für die Mathematik} zeigen wir Ihnen die Axiome für die gesamte Standardmathematik (d.h.\ Logik und Mengenlehre), wie sie traditionell dargestellt werden.  Die traditionelle Darstellung ist nützlich für jemanden, der über die nötige mathematische Erfahrung verfügt, um abstrakte Konzepte auf hohem Niveau korrekt zu handhaben.  Für jemanden, der nicht über dieses Talent verfügt, kann es schwierig sein zu wissen, wie man diese Axiome tatsächlich anwendet.  Der Zweck dieses Abschnitts ist es, Ihnen zu zeigen, wie sich die Version der Axiome, die in der Standard-Metamath\index{Metamath}-Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} verwendet wird, zu der typischen Version in Lehrbüchern verhält, damit Sieein informelles Gespür dafür entwickeln.

\subsection{Aussagenlogik}

Die Aussagenlogik\index{Aussagenlogik} beschäftigt sich mit Aussagen, die entweder als wahr oder falsch interpretiert werden können.  Einige Beispiele für entweder wahre oder falsche Aussagen (außerhalb der Mathematik) sind "`Es regnet heute"' und "`Die Vereinigten Staaten haben einen weiblichen Präsidenten"'. In der Mathematik sind Aussagen, wie wir bereits erwähnt haben, eigentlich Formeln.

In der Aussagenlogik ist uns der Inhalt der Aussagen egal.  Auch eine logische Kombination von Aussagen, wie "`Es regnet heute und die Vereinigten Staaten haben eine weibliche Präsidentin"', wird nicht anders behandelt als eine Einzelaussage.  Aussagen und ihre Kombinationen werden wohlgeformte Formeln (wffs)\index{wohlgeformte Formel (wff)} genannt.  Wir definieren wffs nur in Bezug auf andere wffs und definieren nicht, was eine "`initiale"' wff ist.  Wie in der Literatur üblich, verwenden wir kleine  griechische Buchstaben zur Darstellung von wffs.

Nehmen wir konkret an, dass $\varphi$ und $\psi$ wffs sind.  Dann sind die Kombinationen $\varphi\rightarrow\psi$ ("`$\varphi$ impliziert $\psi$"', auch gelesen als "`wenn $\varphi$ dann $\psi$"' oder "`aus $\varphi$ folgt $\psi$"')\index{Implikation ($\rightarrow$)} und $\lnot\varphi$ ("`nicht $\varphi$"')\index{Negation ($\lnot$)} ebenfalls wffs.

Die drei Axiome der Aussagenlogik\index{Axiome der Aussagenlogik} sind alle wffs der folgenden Form:\footnote{Ein bemerkenswertes Ergebnis von C.~A.~Meredith\index{Meredith, C. A.} quetscht diese drei Axiome in ein einziges Axiom $((((\varphi\rightarrow \psi)\rightarrow(\neg \chi\rightarrow\neg\theta))\rightarrow \chi)\rightarrow \tau)\rightarrow((\tau\rightarrow\varphi)\rightarrow(\theta\rightarrow \varphi))$ \cite{CAMeredith}, das als das kürzest mögliche gilt. }
\begin{center}
     $\varphi\rightarrow(\psi\rightarrow \varphi)$\\

     $(\varphi\rightarrow (\psi\rightarrow \chi))\rightarrow
((\varphi\rightarrow  \psi)\rightarrow (\varphi\rightarrow \chi))$\\

     $(\neg \varphi\rightarrow \neg\psi)\rightarrow (\psi\rightarrow
\varphi)$
\end{center}

Diese drei Axiome sind weit verbreitet. Sie werden Jan {\L}ukasiewicz (sprich: wu-kah-schei-witsch) zugeschrieben und wurden von Alonzo Church veröffentlicht, der sie als System P2 bezeichnete. (Vielen Dank an Ted Ulrich für diese Information.)

Es gibt eine unendliche Anzahl von Axiomen, eines für jede mögliche wff\index{wohlgeformte Formel (wff)} der obigen Form.  (Aus diesem Grund werden Axiome wie die obigen oft als "`Axiomenschema"'\index{Axiomenschema}) bezeichnet.)  Jeder griechische Buchstabe in den Axiomen kann durch eine komplexeres wff ersetzt werden, um ein anderes Axiom zu erhalten.  Ersetzt man beispielsweise $\varphi$ im ersten Axiom durch $\neg(\varphi\rightarrow\chi)$, erhält man $\neg(\varphi\rightarrow\chi)\rightarrow(\psi\rightarrow\neg(\varphi\rightarrow\chi))$, was immer noch ein Axiom ist.

Um aus den Axiomen neue wahre Aussagen (Theoreme\index{Theorem}) abzuleiten, wird eine Schlussregel\index{Regel} namens "`Modus ponens"'\index{Modus ponens} verwendet.  Diese Regel besagt, dass, wenn die wff $\varphi$ ein Axiom oder ein Theorem ist, und die wff $\varphi\rightarrow\psi$ ein Axiom oder ein Theorem ist, dann ist die wff $\psi$ auch ein Theorem\index{Theorem}.

Ein nicht-mathematisches Beispiel für den Modus ponens: Nehmen wir an, wir haben bewiesen (oder als Axiom genommen): "`Bob ist ein Mann"', und haben separat bewiesen (oder als Axiom genommen): "`Wenn Bob ein Mann ist, dann ist Bob ein Mensch."'  Mit Hilfe des Modus ponens können wir logisch folgern: "`Bob ist ein Mensch."'

Aus der Sicht von Metamath\index{Metamath} definieren die Axiome und die Schlussregel Modus ponens lediglich ein mechanisches Mittel zur Ableitung neuer wahrer Aussagen aus bestehenden wahren Aussagen, und das ist der vollständige Inhalt der Aussagenlogik, soweit es Metamath betrifft.  Sie können ein Logik-Lehrbuch lesen, um ein besseres Verständnis ihrer Bedeutung zu erlangen, oder Sie können sich ihre Bedeutung einfach langsam erschließen, nachdem Sie sie eine Weile benutzt haben.

Es ist eigentlich recht einfach zu prüfen, ob eine Formel ein Satz (oder Theorem) der Aussagenlogik ist.  Theoreme der Aussagenlogik werden auch als "`Tautologien"'\index{Tautologie} bezeichnet.  Die Technik, mit der man überprüfen kann, ob eine Formel eine Tautologie ist, wird als "`Wahrheitstabellenmethode"'\index{Wahrheitstabelle} bezeichnet und funktioniert folgendermaßen.  Eine wff $\varphi\rightarrow\psi$ ist falsch, wenn $\varphi$ wahr und $\psi$ falsch ist.  Andernfalls ist sie wahr.  Eine wff $\lnot\varphi$ ist immer dann falsch, wenn $\varphi$ wahr ist und ansonsten falsch. Um eine Tautologie wie $\varphi\rightarrow(\psi\rightarrow \varphi)$ zu verifizieren, zerlegt man sie in Teil-wffs und konstruiert eine Wahrheitstabelle, die alle möglichen Kombinationen von wahr ($W$) und falsch ($F$) berücksichtigt, die den wff-Metavariablen zugeordnet sind:
\begin{center}\begin{tabular}{|c|c|c|c|}\hline
\mbox{$\varphi$} & \mbox{$\psi$} & \mbox{$\psi\rightarrow\varphi$}
    & \mbox{$\varphi\rightarrow(\psi\rightarrow \varphi)$} \\ \hline \hline
              W   &  W    &      W       &        W    \\ \hline
              W   &  F    &      W       &        W    \\ \hline
              F   &  W    &      F       &        W    \\ \hline
              F   &  F    &      W       &        W    \\ \hline
\end{tabular}\end{center}
Wenn alle Einträge in der letzten Spalte wahr ($W$) sind, ist die Formel eine Tautologie.

Die Wahrheitstabellen-Methode sagt Ihnen nicht, wie Sie die Tautologie aus den Axiomen beweisen können, sondern nur, dass ein Beweis existiert.  Einen tatsächlichen Beweis zu finden (insbesondere einen, der kurz und elegant ist), kann eine Herausforderung sein.  Es gibt zwar Methoden zur automatischen Generierung von Beweisen in der Aussagenlogik, aber die daraus resultierenden Beweise können manchmal sehr lang sein.  In der Metamath-Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} wurden die meisten oder sogar alle Beweise manuell erstellt. 

In Abschnitt \ref{metadefprop} werden verschiedene Definitionen erörtert, die die Verwendung der Aussagenlogik erleichtern. Wir definieren zum Beispiel:

\begin{itemize}
\item $\varphi \vee \psi$ ist wahr, wenn entweder $\varphi$ oder $\psi$ (oder beide) wahr sind (dies ist die Disjunktion\index{Disjunktion ($\vee$)} alias logisches {\sc oder}\index{logisches {\sc oder} ($\vee$)}).

\item $\varphi \wedge \psi$ ist wahr, wenn sowohl $\varphi$ als auch $\psi$ wahr sind (dies ist die Konjunktion\index{Konjunktion ($\wedge$)} alias logisches {\sc und}\index{logisches {\sc und} ($\wedge$)}).

\item $\varphi \leftrightarrow \psi$ ist wahr, wenn $\varphi$ und $\psi$ denselben Wert haben, d. h. beide wahr oder beide falsch sind (dies ist die Äquivalenz oder das Bikonditional\index{Bikonditional ($\leftrightarrow$)}).
\end{itemize}

\subsection{Prädikatenlogik}

Die Prädikatenlogik\index{Prädikatenlogik} führt das Konzept der "`individuellen Variablen"'\index{Variable!in der Prädikatenlogik}\index{individuelle Variable} ein, die wir in der Regel einfach "`Variablen"' nennen werden. Diese Variablen können etwas anderes als wahr oder falsch (wffs) darstellen und werden immer Mengen repräsentieren, sobald wir zur Mengenlehre kommen.  Es gibt auch drei neue Symbole $\forall$\index{Allquantor ($\forall$)}, $=$\index{Gleichheit ($=$)} und $\in$\index{stilisiertes Epsilon ($\in$)}, die jeweils "`für alle"', "`gleich"' und "`ist ein Element von"' bedeuten.  Wir werden Variablen mit lateinischen Kleinbuchstaben wie  $x$, $y$, $z$ und $w$ darstellen, wie es in der Literatur üblich ist. Zum Beispiel bedeutet $\forall x \varphi$: "`Für alle möglichen Werte von $x$ ist $\varphi$ wahr."'

In der Prädikatenlogik erweitern wir die Definition einer wff\index{wohlgeformte Formel (wff)}.  Wenn $\varphi$ eine wff ist und $x$ und $y$ Variablen sind, dann sind $\forall x \, \varphi$, $x=y$, und $x\in y$ wffs. Man beachte, dass diese drei neuen Arten von wffs als "`initiale wffs"' betrachtet werden können, aus denen man andere wffs mit $\rightarrow$ und $\neg$ aufbauen kann.  Das Konzept einer initialen wff war in der Aussagenlogik nicht vorhanden.  Aber egal ob initiale wff oder nicht, uns interessiert wirklich nur, ob unsere wffs korrekt nach diesen mechanischen Regeln konstruiert sind.

Eine kurze Anmerkung:
Um Verwirrung zu vermeiden, ist es an dieser Stelle vielleicht am besten, sich die Variablen von Metamath\index{Metamath} als "`Metavariablen"'\index{Metavariable} vorzustellen, weil sie nicht ganz dasselbe sind wie die Variablen, die wir hier vorstellen.  Eine (Meta-)Variable in Metamath kann ein wff oder eine individuelle Variable sein, sowie viele andere Dinge; im Allgemeinen stellt sie eine Art Platzhalter für eine nicht spezifizierte Folge von mathematischen Symbolen\index{mathematisches Symbol} dar.

Anders als in der Aussagenlogik gibt es kein Entscheidungsverfahren\index{Entscheidungsverfahren} analog zur Wahrheitstabellenmethode (und kann es theoretisch auch nicht geben), mit dem man sicher feststellen kann, ob eine Formel ein Satz der Prädikatenlogik ist.  Ein großer Teil der Arbeit auf dem Gebiet des automatischen Theorembeweisens\index{automatisches Theorembeweisen} wurde der Entwicklung cleverer Heuristiken zum Beweisen von Theoremen der Prädikatenlogik gewidmet, aber es kann nie garantiert werden, dass sie immer funktionieren.

In Abschnitt \ref{metadefpred} werden verschiedene Definitionen erörtert, die die Anwendung der Prädikatenlogik erleichtern. Zum Beispiel definieren wir $\exists x \varphi$ als "`Es gibt mindestens einen möglichen Wert von $x$, bei dem $\varphi$ wahr ist."'

Wir wenden uns nun der Frage zu, wie die Prädikatenklogik formal aufgebaut werden kann.

\subsubsection{Gängige Axiome}

Es gibt eine neue Schlussregel in der Prädikatenlogik: Wenn $\varphi$ ein Axiom oder ein Theorem ist, dann ist $\forall x \,\varphi$ auch ein Theorem\index{Theorem}.  Dies nennt man die "`Regel der Verallgemeinerung"'.\index{Regel der Verallgemeinerung} Dies lässt sich in Metamath leicht darstellen.

In Standardtexten der Logik gibt es oft zwei Axiome der Prädikatenlogik\index{Axiome der Prädikatenlogik}:
\begin{center}
    $\forall x \,\varphi ( x ) \rightarrow \varphi ( y )$, wobei "`$y$ echt durch $x$ ersetzt wird"'.\\\ $\forall x ( \varphi \rightarrow \psi )\rightarrow ( \varphi \rightarrow \forall x\, \psi )$, wobei "`$x$ in $\varphi$ nicht frei ist"'.
\end{center}

Auf den ersten Blick erscheint dies einfach: nur zwei Axiome.  Allerdings sind an jedes Axiom Bedingungsklauseln angehängt, die rätselhaft erscheinende Anforderungen beschreiben.  Außerdem setzt das erste Axiom nach jeder wff ein variables Symbol in Klammern, was offensichtlich gegen unsere Definition einer wff\index{wohlgeformte Formel (wff)} verstößt; dies ist nur eine informelle Art, auf eine beliebige Variable zu verweisen, die in der wff vorkommen kann.  Die Konditionalklauseln haben natürlich eine genaue Bedeutung, aber wie sich herausstellt, ist die genaue Bedeutung etwas kompliziert und schwer in einer Weise zu formalisieren, die ein Computer leicht handhaben kann.  Anders als bei der Aussagenlogik ist ein gewisses Maß an mathematischer Raffinesse und Übung erforderlich, um diese Konzepte leicht zu erfassen und korrekt zu handhaben.

Die Prädikatenlogik kann mit oder ohne Gleichheitsaxiome\index{Gleichheitsaxiome}\index{Gleichheit ($=$)} dargestellt werden. Wir werden die Gleichheitsaxiome als Voraussetzung für die von uns verwendete Version der Mengenlehre benötigen.  Die Gleichheitsaxiome werden, wenn sie enthalten sind, oft durch diese beiden Axiome dargestellt:
\begin{center}
$x=x$\\ \
$x=y\rightarrow (\varphi(x,x)\rightarrow\varphi(x,y))$,\\ wobei sich "`$\varphi(x,y)$ aus $\varphi(x,x)$ ergibt, indem einige, aber nicht notwendigerweise alle Vorkommen von $x$ durch $y$ ersetzt werden, vorausgesetzt, dass $y$ für $x$ in $\varphi(x,x)$ frei ist"'.
\end{center}
% (Mendelson p. 95)
Das erste Gleichheitsaxiom ist einfach, aber auch hier ist die Bedingung für das zweite Axiom etwas umständlich auf einem Computer umzusetzen.

\subsubsection{Tarski-System S2}

Natürlich sind wir nicht die Ersten, die die Komplikationen dieser Axiome der Prädikatenlogik bemerken, wenn man es genau nimmt.

Der bekannte Logiker Alfred Tarski veröffentlichte 1965 ein System, das er als System S2 bezeichnete \cite[S.~77]{Tarski1965}. Tarskis System ist \textit{exakt äquivalent} zu der traditionellen Lehrbuchformalisierung, aber (durch geschickten Gebrauch von Gleichheitsaxiomen) eliminiert es die primitiven Begriffe "`echte Substitution"' und "`freie Variable"' und ersetzt sie durch eine direkte Substitution und den Begriff einer Variable, die nicht in einer Formel vorkommt (was wir mit Nebenbedingungen für verschiedene Variablen ausdrücken).

Als er für sein System plädierte, schrieb Tarski: "`Der relativ komplizierte Charakter von [freien Variablen und echter Substitution] ist eine Quelle gewisser Unannehmlichkeiten sowohl praktischer als auch theoretischer Natur; dies zeigt sich deutlich sowohl beim Unterrichten eines Grundkurses der mathematischen Logik als auch bei der Formalisierung der Syntax der Prädikatenlogik für einige theoretische Zwecke"'\cite[S.~61]{Tarski1965}\index{Tarski, Alfred}.

\subsubsection{Entwicklung einer Metamath-Darstellung}

Die Standard-Lehrbuch-Axiome der Prädikatenlogik sind aufgrund der komplexen Begriffe der "`freien Variablen"'\index{freie Variable} und der "`echten Substitution"'\index{echte Substitution}\index{Substitution!echte} etwas umständlich auf einem Computer zu implementieren. Obwohl es möglich ist, diese Konzepte mit der Metamath\index{Metamath}-Sprache umzusetzen, haben wir uns dafür entschieden, sie nicht als primitive Konstrukte in der \texttt{set.mm}-Datenbasis der Mengenlehre zu implementieren.  Stattdessen haben wir sie aus den Axiomen eliminiert, indem wir, auf Tarskis System S2 aufbauend, die Axiome sorgfältig umformuliert haben, dass sie vermieden werden.  Dies macht es einem Anfänger leicht, den Schritten eines Beweises zu folgen, ohne irgendwelche fortgeschrittenen Konzepte zu kennen, außer dem einfachen Konzept der Ersetzung\index{Substitution!Variable}\index{Variablensubstitution} von Variablen durch Ausdrücke.

Um die Konzepte der freien Variablen und der echten Substitution aus den Axiomen zu entwickeln, verwenden wir einen zusätzlichen Metamath-Anweisungstyp namens "`disjunkte Variableneinschränkung"'\index{disjunkte Variablen}\index{disjunkte Variableneinschränkung}, der uns bisher noch nicht begegnet ist.  Im Zusammenhang mit den Axiomen bedeutet die Aussage \texttt{\$d} $ x\, y$\index{\texttt{\$d}-Anweisung} einfach, dass $x$ und $y$ verschiedene\index{verschiedene Variablen} sein müssen, d.h.\ sie dürfen nicht gleichzeitig durch dieselbe Variable substituiert werden\index{Substitution!Variable}\index{Variablensubstitution}.  Die Aussage \texttt{\$d} $ x\, \varphi$ bedeutet, dass die Variable $x$ nicht in der wff $\varphi$ vorkommen darf.  Für die genaue Definition von \texttt{\$d} siehe Abschnitt~\ref{dollard}.

\subsubsection{Metamath-Darstellung}

Das in set.mm definierte Metamath-Axiomensystem für die Prädikatenlogik verwendet das System S2 von Tarski. Wie oben erwähnt, hat dieses eine andere Darstellung als die traditionelle Lehrbuchformalisierung, aber es ist \textit{exakt äquivalent} zur Lehrbuchformalisierung, und es ist \textit{viel} einfacher damit zu arbeiten. Dies wird als System S3 in Abschnitt 6 von Megills Formalisierung \cite{Megill}\index{Megill, Norman} wiedergegeben.

Es gibt eine Ausnahme, nämlich Tarskis Axiom der Existenz, das wir als Axiom ax-6 bezeichnen. Im Fall von ax-6 ist Tarskis Version schwächer, weil sie eine disjunkte Variableneinschränkung enthält. Wenn wir wollen, können wir auch unsere Version auf diese Weise abschwächen und haben trotzdem ein metalogisch vollständiges System. Theorem ax-6 zeigt dies, indem es bei Vorhandensein der anderen Axiome unser ax-6 aus Tarskis schwächerer Version ax6v ableitet. Wir haben jedoch die stärkere Version für unser System gewählt, weil sie einfacher zu formulieren und leichter zu benutzen ist.

Tarskis System war eher für den Beweis spezifischer Theoreme als für allgemeinere Theoremschemata konzipiert. Theoremschemata sind jedoch sehr viel effizienter als spezifische Theoreme, wenn es darum geht, einen Bestand an mathematischem Wissen aufzubauen, da sie je nach Bedarf als verschiedene Instanzen wiederverwendet werden können. Tarski leitet zwar einige Theoremschemata aus seinen Axiomen ab, aber ihre Beweise erfordern Konzepte, die "`außerhalb"' des Systems liegen, wie z.B. die Induktion über die Länge von Formeln. Die Verifikation solcher Beweise lässt sich nur schwer mit einem Beweisverifizierer automatisieren. (Konkret behandelt Tarski die Formeln seines Systems als mengentheoretische Objekte. Um die Beweise seiner Theoremschemata zu verifizieren, müsste ein Beweisverifizierer eine beträchtliche Menge an Mengenlehre fest implementiert haben).

Das Metamath-Axiomensystem für die Prädikatenlogik erweitert Tarskis System, um diese Schwierigkeit zu beseitigen. Die zusätzlichen "`unter\-stüt\-zen\-den"' Axiomenschemata (wie wir sie in diesem Abschnitt nennen werden; siehe unten) verleihen Tarskis System eine nette Eigenschaft, die wir metalogische Vollständigkeit nennen \cite[Remark 9.6]{Megill}\index{Megill, Norman}. Infolgedessen können wir jedes Theoremschema beweisen, das in der "`einfachen Metalogik"' des Tarski-Systems ausgedrückt werden kann, indem wir nur die direkte Substitutionsregel von Metamath verwenden, die auf das Axiomensystem angewendet wird (und keine anderen metalogischen oder mengentheoretischen Begriffe "`außerhalb"' des Systems). Einfache Metalogik besteht aus Schemata, die wff-Metavariablen (ohne Argumente) und/oder Mengenmetavariablen (auch "`individuelle Variablen"' genannt) enthalten, begleitet von optionalen Vorschriften, die jeweils besagen, dass zwei spezifizierte Mengenmetavariablen verschieden sein müssen oder dass eine spezifizierte Mengenmetavariable nicht in einer spezifizierten wff-Metavariable vorkommen darf. Die Axiom- und Regelschemata der Metamath-Logik und der Mengenlehre sind allesamt Beispiele für eine einfache Metalogik. Die Schemata der traditionellen Prädikatenlogik mit Gleichheit sind Beispiele, die keine einfache Metalogik sind, weil sie wff-Metavariablen mit Argumenten verwenden und "`frei für"' und "`nicht frei in"' als Nebenbedingungen haben.

Eine strenge Begründung für dieses System, das einen älteren, aber genau gleichwertigen Satz von Axiomen verwendet, ist in \cite{Megill}\index{Megill, Norman} zu finden.

Dies ermöglicht es uns, in der Metamath\index{Metamath}-Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} einen anderen Ansatz zu wählen.  Wir verwenden keinen der primitiven Begriffe "`freie Variable"'\index{freie Variable} und "`echte Substitution"'\index{echte Substitution}\index{Substitution!echte} als primitive Konstrukte. Stattdessen verwenden wir eine Reihe von Axiomen, die fast so einfach zu handhaben sind wie die der Aussagenlogik.  Unser Axiomensystem vermeidet komplexe primitive Begriffe, indem es die Komplexität wirksam in die Axiome selbst einbettet.  Das Ergebnis ist eine größere Anzahl von Axiomen, die jedoch ideal für eine Computersprache wie Metamath geeignet sind. (Abschnitt~\ref{metaaxioms} zeigt diese Axiome.)

Wir werden hier nicht weiter auf die Begriffe "`freie Variable"' und "`echte Substitution"' eingehen.  Eine genaue Erklärung dieser Konzepte finden Sie in \cite[ch.\ 3--4]{Hamilton}\index{Hamilton, Alan G.} (sowie in vielen anderen Büchenr).  Wenn Sie beabsichtigen, ernsthaft mathematisch zu arbeiten, ist es ratsam, sich mit dem traditionellen Lehrbuchansatz vertraut zu machen; auch wenn die in den Axiomen enthaltenen Konzepte ein höheres Maß an Raffinesse erfordern, können diese für den täglichen, informellen Umgang praktikabler sein.  Selbst wenn Sie nur Metamath-Beweise entwickeln, kann Ihnen die Vertrautheit mit dem traditionellen Ansatz helfen, viel schneller zu einem Beweisentwurf zu gelangen, den Sie dann in die von Metamath geforderten Details umsetzen können.

Wir entwickeln später eigene Substitutionsregeln, aber in set.mm sind sie als abgeleitete Konstrukte definiert; sie sind keine Primitive.

Sie sollten auch beachten, dass unser System der Prädikatenlogik speziell auf die Mengenlehre zugeschnitten ist; daher gibt es nur zwei spezifische Prädikate $=$ und $\in$ und keine Funktionen\index{Funktion!in der Prädikatenlogik} oder Konstanten\index{Konstante!in der Prädikatenlogik} im Gegensatz zu allgemeineren Systemen. Wir fügen diese später hinzu.

\subsection{Mengenlehre}

Die traditionelle Zermelo--Fraenkel-Mengenlehre\index{Zermelo--Fraenkel-Mengenlehre}\index{Mengenlehre} mit dem Auswahlaxiom hat 10 Axiome, die in der Sprache der Prädikatenlogik ausgedrückt werden können.  In diesem Abschnitt werden wir nur die Namen und kurze deutsche (und englische) Beschreibungen dieser Axiome aufführen, da wir Ihnen später die genauen Formeln der Metamath\index{Metamath}-Mengenlehre-Datenbasis \texttt{set.mm} vorstellen werden.

In den Beschreibungen der Axiome gehen wir davon aus, dass $x$, $y$, $z$, $w$ und $v$ Mengen darstellen.  Dies sind die gleichen Variablen\index{Variable!in der Mengenlehre} wie in unserem obigen System der Prädikatenlogik mit dem Unterschied, dass wir uns die Variablen jetzt informell als Platzhalter für Mengen vorstellen.  Beachten Sie, dass die Begriffe "`Objekt"'\index{Objekt}, "`Menge"'\index{Menge}, "`Element"'\index{Element}, "`Sammlung"'\index{Sammlung} und "`Familie"'\index{Familie} synonym sind, ebenso wie "`ist ein Element von"', "`ist ein Mitglied von"'\index{Mitglied}, "`ist enthalten in"' und "`gehört zu"'.  Die verschiedenen Begriffe werden der Einfachheit halber verwendet; zum Beispiel ist "`eine Sammlung von Mengen"' weniger verwirrend als "`eine Menge von Mengen"'. Eine Menge $x$ ist eine "`Teilmenge"'\index{Teilmenge} von $y$, wenn jedes Element von $x$ auch ein Element von $y$ ist; wir sagen auch, dass $x$ "`in $y$ enthalten"' ist.

Die Axiome sind sehr allgemein und gelten für fast alle denkbaren mathematischen Objekte, und diese Abstraktionsebene kann zunächst erdrückend sein.  Um ein intuitives Gefühl für das Konzept zu bekommen, kann es hilfreich sein, ein Bild zu zeichnen, welches das Konzept veranschaulicht; ein Kreis mit Punkten könnte beispielsweise eine Sammlung von Mengen darstellen, und ein kleinerer Kreis, der innerhalb des Kreises gezeichnet wird, könnte eine Teilmenge darstellen. Sich überschneidende Kreise können Schnittmenge und Vereinigung veranschaulichen.  Kreise, die die Konzepte der Mengenlehre veranschaulichen, werden häufig in Grundschulbüchern verwendet und als Venn-Diagramme\index{Venn-Diagramm} bezeichnet.\index{Axiome der Mengenlehre}

1. Extensionalitätsaxiom (engl. Axiom of Extensionality):  Zwei Mengen sind identisch, wenn sie dieselben Elemente enthalten.\index{Extensionalitätsaxiom}

2. Paarmengenaxiom (engl. Axiom of Pairing):  Die Menge $\{ x , y \}$ existiert.\index{Paarmengenaxiom}

3. Potenzmengenaxiom (engl. Axiom of Power Sets):  Die Potenzmenge einer Menge (die Sammlung aller ihrer Teilmengen) existiert.  Zum Beispiel ist die Potenzmenge von $\{x,y\}$ $\{\varnothing,\{x\},\{y\},\{x,y\}\}$, und sie existiert.\index{Potenzmengenaxiom}

4. Leermengenaxiom (engl. Axiom of the Null Set):  Die leere Menge $\varnothing$ existiert.\index{Leermengenaxiom}

5. Vereinigungsaxiom (engl. Axiom of Union):  Die Vereinigung einer Menge (die Menge, welche die Elemente ihrer Mitglieder enthält) existiert.  Zum Beispiel ist die Vereinigung von $\{x,y\},\{z\}$ die existierende Menge $\{x,y,z\}$.\index{Vereinigungsaxiom}

6. Fundierungsaxiom (engl. Axiom of Regularity):  Grob gesagt kann keine Menge sich selbst enthalten, noch kann es zyklische Zugehörigkeiten geben, wie z.B. dass eine Menge ein Element eines ihrer Mitglieder ist.\index{Fundierungsaxiom}

7. Unendlichkeitsaxiom (engl. Axiom of Infinity):  Eine unendliche Menge existiert.  Ein Beispiel für eine unendliche Menge ist die Menge aller ganzen Zahlen.\index{Unendlichkeitsaxiom}

8. Aussonderungsaxiom (engl. Axiom of Separation):  Es existiert die Menge, die man erhält, wenn man $x$ mit einer bestimmten Eigenschaft einschränkt.  Wenn zum Beispiel die Menge aller ganzen Zahlen existiert, dann existiert auch die Menge aller geraden ganzen Zahlen.\index{Aussonderungsaxiom}

9. Ersetzungsaxiom (engl. Axiom of Replacement):  Der Wertebereich einer Funktion, deren Definitionsbereich auf die Elemente einer Menge $x$ beschränkt ist, ist ebenfalls eine Menge.  Zum Beispiel gibt es eine Funktion von den ganzen Zahlen (der Definitionsbereich der Funktion) zu ihren Quadraten (ihr Wertebereich).  Schränkt man den Definitionsbereich auf gerade Zahlen ein, so wird ihr Wertebereich zur Menge der Quadrate der geraden Zahlen, so dass dieses Axiom besagt, dass die Menge der Quadrate der geraden Zahlen existiert.  Technische Anmerkung: Im Allgemeinen muss die "`Funktion"' keine Menge sein, sondern kann eine echte Klasse sein.\index{Ersetzungsaxiom}

10. Auswahlaxiom:  Sei $x$ eine Menge, deren Mitglieder paarweise disjunkte Mengen\index{disjunkte Mengen} sind. (d.h. deren Mitglieder keine gemeinsamen Elemente enthalten).  Dann gibt es eine andere Menge, die ein Element von jedem Mitglied von $x$ enthält.  Wenn $x$ beispielsweise $\{\{y,z\},\{w,v\}\}$ ist, wobei $y$, $z$, $w$ und $v$ verschiedene Mengen sind, dann existiert eine Menge wie $\{z,w\}$ (das Axiom sagt uns aber nicht welche).  (Eigentlich ist das Auswahlaxiom überflüssig, wenn die Menge $x$, wie in diesem Beispiel, eine endliche Anzahl von Elementen hat.)\index{Auswahlaxiom}

Das Auswahlaxiom wird in der Regel als Erweiterung der ZF-Mengenlehre betrachtet und nicht als deren originärer Bestandteil.  Es wird manchmal als philosophisch umstritten angesehen, weil es die Existenz einer Menge festlegt, ohne sie zu spezifizieren. Konstruktive Logiken, einschließlich der intuitionistischen Logik, akzeptieren das Auswahlaxiom nicht. Da die Kontroverse darüber anhält, bevorzugen wir oft Beweise, die das Auswahlaxiom nicht verwenden (wenn es eine bekannte Alternative gibt), und in einigen Fällen werden wir schwächere Axiome als das vollständige Auswahlaxiom verwenden. Dennoch ist das Auswahlaxiom ein mächtiges und weithin akzeptiertes Werkzeug, so dass wir es bei Bedarf verwenden. Die ZF-Mengenlehre, die das Auswahlaxiom enthält, wird Zermelo--Fraenkel-Mengenlehre mit Auswahlaxiom (ZFC\index{ZFC-Mengenlehre}) genannt.

Symbolisch ausgedrückt enthalten das Aussonderungsaxiom und das Ersetzungsaxiom wff-Symbole und stellen daher jeweils unendlich viele Axiome dar, eines für jede mögliche wff. Aus diesem Grund werden sie oft als Axiomenschemata\index{Axiomenschema}\index{wohlgeformte Formel (wff)} bezeichnet.

Es stellt sich heraus, dass das Leermengenaxiom, das Paarmengenaxiom und das Aussonderungsaxiom aus den anderen Axiomen abgeleitet werden können und daher unnötig sind, obwohl sie aus verschiedenen Gründen (historisch, philosophisch und möglicherweise, weil einige Autoren dies nicht wissen) in Standardtexten enthalten sind.  In der Metamath\index{Metamath}-Mengenlehre-Datenbasis werden diese überflüssigen Axiome von den anderen abgeleitet, anstatt wirklich als Axiome betrachtet zu werden. Dies entspricht unserem allgemeinen Ziel, die Anzahl der Axiome, von denen wir abhängig sind, zu minimieren.

\subsection{Andere Axiome}

Oben haben wir die Formulierung "`die gesamte Mathematik"' mit "`im Wesentlichen"' relativiert. Das wichtigste fehlende Element ist die Fähigkeit zur Kategorientheorie, die riesige Mengen (unzugängliche Kardinalzahlen) erfordert, die größer sind als die, die von den ZFC-Axiomen abgeleitet werden können. Das Tarski--Grothendieck-Axiom postuliert die Existenz solcher Mengen. Man beachte, dass dies dasselbe Axiom ist, das von Mizar zur Unterstützung der Kategorientheorie verwendet wird. Das Tarski--Grothendieck-Axiom kann als ein sehr starker Ersatz für das Unendlichkeitsaxiom, das Auswahlaxiom und das Potenzmengenaxiom angesehen werden. Die Datenbasis \texttt{set.mm} enthält dieses Axiom; Einzelheiten dazu finden Sie in der Datenbasis. Auch dieses Axiom wird nur verwendet, wenn es absolut notwendig ist. Sie werden diesem Axiom wahrscheinlich nur begegnen oder es verwenden, wenn Sie sich mit der Kategorientheorie beschäftigen, da seine Verwendung hochspezialisiert ist. Daher werden wir das Tarski--Grothendieck-Axiom in der folgenden kurzen Liste von Axiomen nicht auf\-führen.

Kann es noch mehr Axiome geben? Ja, natürlich. G\"{o}del hat gezeigt, dass keine endliche Menge von Axiomen oder Axiomenschemata eine konsistente Theorie, die stark genug ist, um die Arithmetik einzuschließen, vollständig beschreiben kann. Aber praktisch gesehen sind die oben genannten Axiome die anerkannte Grundlage, auf der fast alle Mathematiker explizit oder implizit ihre Arbeit aufbauen.

\section{Die Axiome in der Metamath-Sprache}\label{metaaxioms}

Hier führen wir die Axiome so auf, wie sie in der Datenbasis der Mengenlehre \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} erscheinen, damit Sie diese dort leicht nachschlagen können.  Übrigens wurde der Befehl \texttt{show statement /tex}\index{\texttt{show statement}-Befehl} verwendet, um sie darzustellen.

%macros from show statement /tex
\newbox\mlinebox
\newbox\mtrialbox
\newbox\startprefix  % Prefix for first line of a formula
\newbox\contprefix  % Prefix for continuation line of a formula
\def\startm{  % Initialize formula line
  \setbox\mlinebox=\hbox{\unhcopy\startprefix}
}
\def\m#1{  % Add a symbol to the formula
  \setbox\mtrialbox=\hbox{\unhcopy\mlinebox $\,#1$}
  \ifdim\wd\mtrialbox>\hsize
    \box\mlinebox
    \setbox\mlinebox=\hbox{\unhcopy\contprefix $\,#1$}
  \else
    \setbox\mlinebox=\hbox{\unhbox\mtrialbox}
  \fi
}
\def\endm{  % Output the last line of a formula
  \box\mlinebox
}

% \SLASH for \ , \TOR for \/ (text OR), \TAND for /\ (text and)
% This embeds a following forced space to force the space.
\newcommand\SLASH{\char`\\~}
\newcommand\TOR{\char`\\/~}
\newcommand\TAND{/\char`\\~}
%
% Macro to output metamath raw text.
% This assumes \startprefix and \contprefix are set.
% NOTE: "\" is tricky to escape, use \SLASH, \TOR, and \TAND inside.
% Any use of "$ { ~ ^" must be escaped; ~ and ^ must be escaped specially.
% We escape { and } for consistency.
% For more about how this macro written, see:
% https://stackoverflow.com/questions/4073674/
% how-to-disable-indentation-in-particular-section-in-latex/4075706
% Use frenchspacing, or "e." will get an extra space after it.
\newlength\mystoreparindent
\newlength\mystorehangindent
\newenvironment{mmraw}{%
\setlength{\mystoreparindent}{\the\parindent}
\setlength{\mystorehangindent}{\the\hangindent}
\setlength{\parindent}{0pt} % TODO - we'll put in the \startprefix instead
\setlength{\hangindent}{\wd\the\contprefix}
\begin{flushleft}
\begin{frenchspacing}
\begin{tt}
{\unhcopy\startprefix}%
}{%
\end{tt}
\end{frenchspacing}
\end{flushleft}
\setlength{\parindent}{\mystoreparindent}
\setlength{\hangindent}{\mystorehangindent}
\vskip 1ex
}

\needspace{5\baselineskip}
\subsection{Aussagenlogik}\label{propcalc}\index{Axiome der Aussagenlogik}

\needspace{2\baselineskip}
Axiom der Vereinfachung.\label{ax1}

\setbox\startprefix=\hbox{\tt \ \ ax-1\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\varphi}\m{\rightarrow}\m{(}\m{\psi}\m{\rightarrow}\m{\varphi}\m{)}
\m{)}
\endm

\needspace{3\baselineskip}
\noindent Axiom der Verteilung.

\setbox\startprefix=\hbox{\tt \ \ ax-2\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\varphi}\m{\rightarrow}\m{(}\m{\psi}\m{\rightarrow}\m{\chi}
\m{)}\m{)}\m{\rightarrow}\m{(}\m{(}\m{\varphi}\m{\rightarrow}\m{\psi}\m{)}\m{
\rightarrow}\m{(}\m{\varphi}\m{\rightarrow}\m{\chi}\m{)}\m{)}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Axiom der Kontraposition.

\setbox\startprefix=\hbox{\tt \ \ ax-3\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\lnot}\m{\varphi}\m{\rightarrow}\m{\lnot}\m{\psi}\m{)}\m{
\rightarrow}\m{(}\m{\psi}\m{\rightarrow}\m{\varphi}\m{)}\m{)}
\endm


\needspace{4\baselineskip}
\noindent Die Schlussregel Modus ponens.\label{axmp}\index{Modus ponens}

\setbox\startprefix=\hbox{\tt \ \ min\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\varphi}
\endm

\setbox\startprefix=\hbox{\tt \ \ maj\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\varphi}\m{\rightarrow}\m{\psi}\m{)}
\endm

\setbox\startprefix=\hbox{\tt \ \ ax-mp\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\psi}
\endm


\needspace{7\baselineskip}
\subsection{Axiome der Prädikatenlogik mit Gleichheit\\--- Tarskis S2}\index{Axiome der Prädikatenlogik}

\needspace{3\baselineskip}
\noindent Regel der Verallgemeinerung.\index{Regel der Verallgemeinerung}

\setbox\startprefix=\hbox{\tt \ \ ax-g.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\varphi}
\endm

\setbox\startprefix=\hbox{\tt \ \ ax-gen\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\forall}\m{x}\m{\varphi}
\endm

\needspace{2\baselineskip}
\noindent Axiom der quantifizierten Implikation.

\setbox\startprefix=\hbox{\tt \ \ ax-4\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\forall}\m{x}\m{(}\m{\forall}\m{x}\m{\varphi}\m{\rightarrow}\m{
\psi}\m{)}\m{\rightarrow}\m{(}\m{\forall}\m{x}\m{\varphi}\m{\rightarrow}\m{
\forall}\m{x}\m{\psi}\m{)}\m{)}
\endm

\needspace{3\baselineskip}
\noindent Axiom der Unterscheidbarkeit.

% Aka: Add $d x ph $.
\setbox\startprefix=\hbox{\tt \ \ ax-5\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\varphi}\m{\rightarrow}\m{\forall}\m{x}\m{\varphi}\m{)}
\m{mit}\m{ }\m{\$d}\m{ }\m{x}\m{ }\m{\varphi}\m{ }\m{(}\m{x}\m{ }\m{kommt}\m{ }\m{in}\m{ }\m{\varphi}
\m{ }\m{nicht}\m{ }\m{vor}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Axiom der Existenz.

\setbox\startprefix=\hbox{\tt \ \ ax-6\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\forall}\m{x}\m{(}\m{x}\m{=}\m{y}\m{\rightarrow}\m{\forall}
\m{x}\m{\varphi}\m{)}\m{\rightarrow}\m{\varphi}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Axiom der Gleichheit.

\setbox\startprefix=\hbox{\tt \ \ ax-7\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{=}\m{y}\m{\rightarrow}\m{(}\m{x}\m{=}\m{z}\m{
\rightarrow}\m{y}\m{=}\m{z}\m{)}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Axiom der Linksgleichheit für binäre Prädikate.

\setbox\startprefix=\hbox{\tt \ \ ax-8\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{=}\m{y}\m{\rightarrow}\m{(}\m{x}\m{\in}\m{z}\m{
\rightarrow}\m{y}\m{\in}\m{z}\m{)}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Axiom der Rechtsgleichheit für binäre Prädikate.

\setbox\startprefix=\hbox{\tt \ \ ax-9\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{=}\m{y}\m{\rightarrow}\m{(}\m{z}\m{\in}\m{x}\m{
\rightarrow}\m{z}\m{\in}\m{y}\m{)}\m{)}
\endm


\needspace{4\baselineskip}
\subsection{Axiome der Prädikatenlogik mit Gleichheit\\--- Hilfsaxiome}\index{Axiome der Prädikatenlogik - Hilfsaxiome}

\needspace{2\baselineskip}
\noindent Axiom der quantifizierten Negation.

\setbox\startprefix=\hbox{\tt \ \ ax-10\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\lnot}\m{\forall}\m{x}\m{\lnot}\m{\forall}\m{x}\m{\varphi}\m{
\rightarrow}\m{\varphi}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Axiom der Quantifizierungskommutativität.

\setbox\startprefix=\hbox{\tt \ \ ax-11\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\forall}\m{x}\m{\forall}\m{y}\m{\varphi}\m{\rightarrow}\m{
\forall}\m{y}\m{\forall}\m{x}\m{\varphi}\m{)}
\endm

\needspace{3\baselineskip}
\noindent Axiom der Substitution.

\setbox\startprefix=\hbox{\tt \ \ ax-12\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\lnot}\m{\forall}\m{x}\m{\,x}\m{=}\m{y}\m{\rightarrow}\m{(}
\m{x}\m{=}\m{y}\m{\rightarrow}\m{(}\m{\varphi}\m{\rightarrow}\m{\forall}\m{x}\m{(}
\m{x}\m{=}\m{y}\m{\rightarrow}\m{\varphi}\m{)}\m{)}\m{)}\m{)}
\endm

\needspace{3\baselineskip}
\noindent Axiom der quantifizierten Gleichheit.

\setbox\startprefix=\hbox{\tt \ \ ax-13\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\lnot}\m{\forall}\m{z}\m{\,z}\m{=}\m{x}\m{\rightarrow}\m{(}
\m{\lnot}\m{\forall}\m{z}\m{\,z}\m{=}\m{y}\m{\rightarrow}\m{(}\m{x}\m{=}\m{y}
\m{\rightarrow}\m{\forall}\m{z}\m{\,x}\m{=}\m{y}\m{)}\m{)}\m{)}
\endm

% \noindent Axiom of Quantifier Substitution
%
% \setbox\startprefix=\hbox{\tt \ \ ax-c11n\ \$a\ }
% \setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
% \startm
% \m{\vdash}\m{(}\m{\forall}\m{x}\m{\,x}\m{=}\m{y}\m{\rightarrow}\m{(}\m{\forall}
% \m{x}\m{\varphi}\m{\rightarrow}\m{\forall}\m{y}\m{\varphi}\m{)}\m{)}
% \endm
%
% \noindent Axiom of Distinct Variables. (This axiom requires
% that two individual variables
% be distinct\index{\texttt{\$d}-Anweisung}\index{distinct
% variables}.)
%
% \setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \$d\ }
% \setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
% \startm
% \m{x}\m{\,}\m{y}
% \endm
%
% \setbox\startprefix=\hbox{\tt \ \ ax-c16\ \$a\ }
% \setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
% \startm
% \m{\vdash}\m{(}\m{\forall}\m{x}\m{\,x}\m{=}\m{y}\m{\rightarrow}\m{(}\m{\varphi}\m{
% \rightarrow}\m{\forall}\m{x}\m{\varphi}\m{)}\m{)}
% \endm

% \noindent Axiom of Quantifier Introduction (2).  (This axiom requires
% that the individual variable not occur in the
% wff\index{\texttt{\$d}-Anweisung}\index{unterschiedliche Variablen}.)
%
% \setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \$d\ }
% \setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
% \startm
% \m{x}\m{\,}\m{\varphi}
% \endm
% \setbox\startprefix=\hbox{\tt \ \ ax-5\ \$a\ }
% \setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
% \startm
% \m{\vdash}\m{(}\m{\varphi}\m{\rightarrow}\m{\forall}\m{x}\m{\varphi}\m{)}
% \endm

\subsection{Mengenlehre}\label{mmsettheoryaxioms}

Um die Axiome der Mengenlehre\index{Axiome der Mengenlehre} etwas kompakter zu gestalten, gibt es einige Definitionen aus der Logik, die wir implizit verwenden, nämlich "`logisches {\sc und}"', \index{Konjunktion ($\wedge$)}\index{logisches {\sc und} ($\wedge$)} "`logische Äquivalenz"',\index{logische Äquivalenz ($\leftrightarrow$)}\index{Bikonditional ($\leftrightarrow$)} und "`Es gibt"'\index{Existenzquantor ($\exists$)}.

\begin{center}\begin{tabular}{rcl}
  $( \varphi \wedge \psi )$ &\mbox{steht für}& $\neg ( \varphi
     \rightarrow \neg \psi )$\\
  $( \varphi \leftrightarrow \psi )$& \mbox{steht für}& $( ( \varphi \rightarrow \psi ) \wedge
     ( \psi \rightarrow \varphi ) )$\\
  $\exists x \,\varphi$ &\mbox{steht für}& $\neg \forall x \neg \varphi$
\end{tabular}\end{center}

Darüber hinaus verlangen die Axiome der Mengenlehre, dass alle Variablen unterscheidbar sind,\index{unterschiedliche Variablen}\footnote{Die Axiome der Mengenlehre können so entwickelt werden, dass {\em keine} Variablen unterscheidbar sein müssen, vorausgesetzt, wir ersetzen \texttt{ax-c16} durch ein Axiom, das besagt, dass "`mindestens zwei Dinge existieren"', wodurch \texttt{ax-5} das einzige andere Axiom wird, das die Anweisung \texttt{\$d} erfordert.  Diese Axiome sind unkonventionell und werden hier nicht vorgestellt, aber sie können auf der Website \url{http://metamath.org} gefunden werden.  Siehe auch den Kommentar zu S.~\pageref{nodd}.}\index{\texttt{\$d}-Anweisung} also nehmen wir auch an:
\begin{center}
  \texttt{\$d }$x\,y\,z\,w$
\end{center}

\needspace{2\baselineskip}
\noindent Extensionalitätsaxiom.\index{Extensionalitätsaxiom}

\setbox\startprefix=\hbox{\tt \ \ ax-ext\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\forall}\m{x}\m{(}\m{x}\m{\in}\m{y}\m{\leftrightarrow}\m{x}
\m{\in}\m{z}\m{)}\m{\rightarrow}\m{y}\m{=}\m{z}\m{)}
\endm

\needspace{3\baselineskip}
\noindent Ersetzungsaxiom.\index{Ersetzungsaxiom}

\setbox\startprefix=\hbox{\tt \ \ ax-rep\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\forall}\m{w}\m{\exists}\m{y}\m{\forall}\m{z}\m{(}\m{%
\forall}\m{y}\m{\varphi}\m{\rightarrow}\m{z}\m{=}\m{y}\m{)}\m{\rightarrow}\m{%
\exists}\m{y}\m{\forall}\m{z}\m{(}\m{z}\m{\in}\m{y}\m{\leftrightarrow}\m{%
\exists}\m{w}\m{(}\m{w}\m{\in}\m{x}\m{\wedge}\m{\forall}\m{y}\m{\varphi}\m{)}%
\m{)}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Vereinigungsaxiom.\index{Vereinigungsaxiom}

\setbox\startprefix=\hbox{\tt \ \ ax-un\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\exists}\m{x}\m{\forall}\m{y}\m{(}\m{\exists}\m{x}\m{(}\m{y}\m{
\in}\m{x}\m{\wedge}\m{x}\m{\in}\m{z}\m{)}\m{\rightarrow}\m{y}\m{\in}\m{x}\m{)}
\endm

\needspace{2\baselineskip}
\noindent Potenzmengenaxiom.\index{Potenzmengenaxiom}

\setbox\startprefix=\hbox{\tt \ \ ax-pow\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\exists}\m{x}\m{\forall}\m{y}\m{(}\m{\forall}\m{x}\m{(}\m{x}\m{
\in}\m{y}\m{\rightarrow}\m{x}\m{\in}\m{z}\m{)}\m{\rightarrow}\m{y}\m{\in}\m{x}
\m{)}
\endm

\needspace{3\baselineskip}
\noindent Fundierungsaxiom.\index{Fundierungsaxiom}

\setbox\startprefix=\hbox{\tt \ \ ax-reg\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\exists}\m{x}\m{\,x}\m{\in}\m{y}\m{\rightarrow}\m{\exists}
\m{x}\m{(}\m{x}\m{\in}\m{y}\m{\wedge}\m{\forall}\m{z}\m{(}\m{z}\m{\in}\m{x}\m{
\rightarrow}\m{\lnot}\m{z}\m{\in}\m{y}\m{)}\m{)}\m{)}
\endm

\needspace{3\baselineskip}
\noindent Unendlichkeitsaxiom.\index{Unendlichkeitsaxiom}

\setbox\startprefix=\hbox{\tt \ \ ax-inf\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\exists}\m{x}\m{(}\m{y}\m{\in}\m{x}\m{\wedge}\m{\forall}\m{y}%
\m{(}\m{y}\m{\in}\m{x}\m{\rightarrow}\m{\exists}\m{z}\m{(}\m{y}\m{\in}\m{z}\m{%
\wedge}\m{z}\m{\in}\m{x}\m{)}\m{)}\m{)}
\endm

\needspace{4\baselineskip}
\noindent Auswahlaxiom.\index{Auswahlaxiom}

\setbox\startprefix=\hbox{\tt \ \ ax-ac\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\exists}\m{x}\m{\forall}\m{y}\m{\forall}\m{z}\m{(}\m{(}\m{y}\m{%
\in}\m{z}\m{\wedge}\m{z}\m{\in}\m{w}\m{)}\m{\rightarrow}\m{\exists}\m{w}\m{%
\forall}\m{y}\m{(}\m{\exists}\m{w}\m{(}\m{(}\m{y}\m{\in}\m{z}\m{\wedge}\m{z}%
\m{\in}\m{w}\m{)}\m{\wedge}\m{(}\m{y}\m{\in}\m{w}\m{\wedge}\m{w}\m{\in}\m{x}%
\m{)}\m{)}\m{\leftrightarrow}\m{y}\m{=}\m{w}\m{)}\m{)}
\endm

\subsection{Das war's}

Das waren sie, die Axiome für (im Wesentlichen) die gesamte Mathematik! Bestaunen Sie sie und schauen Sie sie ehrfürchtig an.  Stecken Sie ein Exemplar in Ihre Brieftasche und Sie werden die Kodierung aller Theoreme, die jemals bewiesen wurden und die jemals bewiesen werden, in Ihrer Tasche tragen - von den banalsten bis zu den tiefgründigsten.

\section{Eine Hierarchie von Definitionen}\label{hierarchy}

Die Axiome im vorigen Abschnitt ermöglichen im Prinzip alles, was man in der Standardmathematik erreichen kann.  Allerdings ist es in den meisten Fällen unpraktisch, mit ihnen direkt zu arbeiten, da selbst einfache Konzepte (aus menschlicher Sicht) nur mit extrem langen, unverständlichen Formeln ausgedrückt werden können. Die Mathematik wird deshalb erst durch die Einführung von Definitionen\index{Definition} praktikabel. Definitionen führen in der Regel neue Symbole oder zumindest neue Beziehungen zwischen bestehenden Symbolen ein, um komplexere Formeln abzukürzen.  Eine wichtige Voraussetzung für eine Definition ist, dass es eine einfache (algorithmische) Methode gibt, um die Abkürzung zu eliminieren, indem sie durch die primitivere Symbolkette, die sie repräsentiert, ersetzt wird.  Einige wichtige Definitionen, die in der Datei \texttt{set.mm} enthalten sind, werden in diesem Abschnitt als Referenz aufgeführt, und auch, um Ihnen ein Gefühl dafür zu geben, warum etwas wie $\omega$\index{Omega ($\omega$)} (die Menge der natürlichen Zahlen\index{natürliche Zahlen} 0, 1, 2,\ldots) sehr kompliziert wird, wenn es vollständig in primitiven Symbolen ausgedrückt wird.

Was ist die Motivation für Definitionen, abgesehen davon, dass komplizierte Ausdrücke einfacher ausgedrückt werden können?  Im Falle von $\omega$ besteht ein Ziel darin, eine Grundlage für die Theorie der natürlichen Zahlen\index{natürliche Zahlen} zu schaffen. Vor der Erfindung der Mengenlehre wurde eine Reihe von Axiomen für die Arithmetik, die so genannten Peano-Postulate\ index{Peanos Postulate}, entwickelt und gezeigt, dass sie die erwarteten Eigenschaften für natürliche Zahlen haben.  Nun kann jeder einen Satz von Axiomen postulieren, aber wenn die Axiome inkonsistent sind, können daraus Widersprüche abgeleitet werden.  Sobald ein Widerspruch abgeleitet ist, kann alles trivialerweise bewiesen werden, einschließlich aller Fakten der Arithmetik und ihrer Negationen.  Um sicherzustellen, dass ein Axiomensystem mindestens so zuverlässig ist wie die Axiome der Mengenlehre, können wir Mengen und Operationen auf diesen Mengen definieren, die die neuen Axiome erfüllen. In der \texttt{set.mm} Metamath-Datenbasis beweisen wir, dass die Elemente von $\omega$ die Peano-Postulate erfüllen, und es ist ein langer und harter Weg, um von den Axiomen der Mengenlehre direkt dorthin zu gelangen.  Aber das Ergebnis ist das Vertrauen in die Grundlagen der Arithmetik.  Und es gibt noch einen weiteren Vorteil: Wir haben jetzt alle Werkzeuge der Mengenlehre zur Verfügung, um Objekte zu manipulieren, die den Axiomen der Arithmetik gehorchen.

Was sind die Kriterien für unsere Definitionen?  Erstens, und das ist von größter Bedeutung, sollte die Definition nicht {\em kreativ}\index{kreative Definition}\index{Definition!kreativ} sein, d.h. sie sollte nicht zulassen, dass ein Ausdruck, der als wff klassifiziert, aber nicht beweisbar war, beweisbar wird.   Zweitens sollte die Definition {\em eliminierbar}\index{Definition!Eliminierbarkeit} sein, d.h. es sollte eine algorithmische Methode geben, um jeden als wff klasifizierten Ausdruck, der die Definition verwendet, in einen logisch äquivalenten Ausdruck umzuwandeln.

In fast allen folgenden Fällen verbinden die Definitionen zwei Ausdrücke entweder mit $\leftrightarrow$ oder $=$.  Die Eliminierung\footnote{Hier ist die Eliminierung gemeint, die ein Mensch in seinem Kopf durchführen könnte.  Um sie als Teil eines Metamath-Beweises zu eliminieren, würden wir uns auf eines der Theoreme berufen, die sich mit der Transitivität von Äquivalenz oder Gleichheit befassen; es gibt viele solcher Beispiele in den Beweisen in \texttt{set.mm}.} einer solchen Definition ist ein einfaches Ersetzen des Ausdrucks auf der linken Seite ({\em Definiendum}\index{Definiendum} oder Sache, die definiert wird) durch den äquivalenten, primitiveren Ausdruck auf der rechten Seite ({\em Definiens}\index{Definiens} oder Definition).

Häufig enthält eine Definition auf der rechten Seite Variablen, die auf der linken Seite nicht vorkommen; diese werden als {\em Dummy-Variable} bezeichnet.\index{Dummy-Variable!in Definitionen}  In diesem Fall kann jede zulässige Substitution (z. B. eine neue, unterschiedliche Variable) verwendet werden, wenn die Definition eliminiert wird.  Dummy-Variablen dürfen nur verwendet werden, wenn sie {\em effektiv gebunden}\index{effektiv gebundene Variable} sind, was bedeutet, dass die Definition bei jeder Ersetzung einer Dummy-Variablen durch einen anderen {\em qualifizierenden Ausdruck}\index{qualifizierender Ausdruck} logisch äquivalent bleibt, d.h. eine beliebige Zeichenkette (z.B. eine andere Variable), die den Beschränkungen für die Dummy-Variable durch die Anweisungen \texttt{\$d} und \texttt{\$f} entspricht.  Wir könnten zum Beispiel eine Konstante $\perp$ (invertiertes T, d.h. logisch "`falsch"') als $( \varphi \wedge \lnot \varphi )$ definieren, d.h. \ "`phi und nicht phi"'.  Hier ist $\varphi$ effektiv gebunden, weil die Definition logisch äquivalent bleibt, wenn wir $\varphi$ durch irgendeine andere wff ersetzen.  (Eigentlich wird $\perp$ in \texttt{set.mm} durch \texttt{df-fal} definiert.)

Es gibt zwei Fälle, in denen die Eliminierung von Definitionen ein wenig komplexer ist.  Diese Fälle sind die Definitionen \texttt{df-bi} und \texttt{df-cleq}.  Der erste Fall fasst das Konzept einer Definition ein wenig weiter, da er in der Tat eine "`Definition definiert"'; diese Definition erfüllt jedoch unsere Anforderungen an eine Definition, da sie eliminierbar ist und die Mächtigkeit der Sprache nicht erhöht.  Theorem \texttt{bii} zeigt die notwendige Substitution, um das Symbol $\leftrightarrow$\index{logische Äquivalenz ($\leftrightarrow$)}\index{Bikonditional ($\leftrightarrow$)} zu eliminieren.

Definition \texttt{df-cleq}\index{Gleichheit ($=$)} erweitert die Verwendung des Gleichheitssymbols auf "`Klassen"'\index{Klasse} in der Mengenlehre.  Dies könnte potenziell problematisch sein, weil es zu Aussagen führen kann, die nicht allein aus der Logik folgen, sondern das Extensionalitätsaxiom\index{Extensionalitätsaxiom} voraussetzen. Deshalb nehmen wir dieses Axiom als Hypothese in die Definition mit auf.  Wir hätten \texttt{df-cleq} direkt eliminierbar machen können, indem wir ein neues Gleichheitssymbol eingeführt hätten. Wir haben uns aber entschieden, dies nicht zu tun, um der üblichen Lehrbuchpraxis zu entsprechen.  Definitionen wie \texttt{df-cleq}, die die Bedeutung bestehender Symbole erweitern, müssen sorgfältig eingeführt werden, damit sie nicht zu Widersprüchen führen.  Die Definition \texttt{df-clel} erweitert ebenfalls die Bedeutung eines bestehenden Symbols ($\in$); sie erhöht zwar nicht die Mächtigkeit der Sprache so wie \texttt{df-cleq}, aber das ist nicht offensichtlich, weshalb sie ebenfalls einer sorgfältigen Prüfung unterzogen werden muss.

Übung:  Untersuchen Sie, wie die wff $x\in\omega$, die besagt, dass "`$x$ eine natürliche Zahl ist"', in Form von primitiven Symbolen ausgedrückt werden könnte, indem Sie mit den Definitionen \texttt{df-clel} auf S.~\pageref{dfclel} und \texttt{df-om} auf S.~\pageref{dfom} beginnen und sich dann rückwärts vorarbeiten.  Machen Sie sich nicht die Mühe, die Details auszuarbeiten; stellen Sie nur sicher, dass Sie verstehen, wie Sie es im Prinzip tun könnten. Die Antwort finden Sie in der Fußnote auf S.~\pageref{expandom}.  Wenn Sie dies tatsächlich durchführen, werden Sie nicht genau die gleiche Antwort erhalten, weil wir einige Vereinfachungen verwendet haben, wie z.B. das Weglassen von $\lnot\lnot$ (doppelte Negation).

In den untenstehenden Definitionen haben wir die {\sc ascii} Metamath-Quelle unter jede der Formeln gesetzt, damit Sie sich mit der Notation in der Datenbasis vertraut machen können.  Der Einfachheit halber werden die notwendigen \texttt{\$f}- und \texttt{\$d}-Anweisungen nicht gezeigt.  Im Zweifelsfall sollten Sie den Befehl \texttt{show statement}\index{\texttt{show statement}-Befehl} im Metamath-Programm verwenden, um die vollständige Aussage zu sehen. Eine Auswahl dieser Notation ist im Anhang~\ref{ASCII} zusammengefasst.

Um die Motivation für diese Definitionen zu verstehen, sollten Sie die angegebenen Referenzen konsultieren:  Takeuti und Zaring \cite{Takeuti}\index{Takeuti, Gaisi}, Quine \cite{Quine}\index{Quine, Willard Van Orman}, Bell und Machover \cite{Bell}\index{Bell, J. L.}, und Enderton \cite{Enderton}\index{Enderton, Herbert B.}.  Unsere Liste der Definitionen dient eher als Referenz denn als Lernhilfe.  Anhand einiger Definitionen können Sie jedoch ein Gefühl dafür bekommen, wie die Hierarchie aufgebaut ist.  Die Definitionen sind eine repräsentative Auswahl der vielen Definitionen in \texttt{set.mm}, aber sie sind vollständig in Bezug auf die Beispieltheoreme, die wir in Abschnitt~\ref{sometheorems} vorstellen werden.  Außerdem unterscheiden sich einige Definitionen geringfügig von denen in \texttt{set.mm}, sind aber logisch äquivalent zu denen in \texttt{set.mm} (von denen einige im Laufe der Zeit überarbeitet wurden, um sie z. B. zu kürzen).

\subsection{Definitionen für die Aussagenlogik}\label{metadefprop}

Die Symbole $\varphi$, $\psi$ und $\chi$ stehen für wffs.

Unsere erste Definition führt den bikonditionalen Junktor ein\footnote{Der Begriff "`Junktor"' wird informell verwendet, um ein Symbol zu bezeichnen, das zwischen zwei Variablen oder neben einer Variable platziert ist, während eine mathematische "`Konstante"' normalerweise ein Symbol wie die Zahl 0 bezeichnet, das eine Variable oder Metavariable ersetzen kann.  Aus der Sicht von Metamath gibt es keine Unterscheidung zwischen einem Junktor und einer Konstante; beide sind in der Metamath-Sprache Konstanten.}\index{Junktor}\index{Konstante} (auch logische Äquivalenz genannt)\index{logische Äquivalenz ($\leftrightarrow$)}\index{Bikonditional ($\leftrightarrow$)}.  Im Gegensatz zu den meisten traditionellen Vorgehensweisen haben wir uns entschieden, kein separates Symbol wie "`Df."' für "`ist definiert als"' zu verwenden.  Stattdessen werden wir den bikonditionalen Junktor für diesen Zweck verwenden, da er uns erlaubt, Definitionen direkt mithilfe der Logik zu manipulieren.  Hier geben wir die Eigenschaften des bikonditionalen Junktors mit einer sorgfältig formulierten \texttt{\$a}-Anweisung an, die den bikonditionalen Junktor probat dazu verwendet, sich selbst zu definieren.  Das Symbol $\leftrightarrow$ kann mit Hilfe des Theorems \texttt{bii}, das später hergeleitet wird, aus einer Formel entfernt werden.

\vskip 2ex
\noindent Definition des {\bf bikonditionalen Junktors}.\label{df-bi}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-bi\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\lnot}\m{(}\m{(}\m{(}\m{\varphi}\m{\leftrightarrow}\m{\psi}\m{)}%
\m{\rightarrow}\m{\lnot}\m{(}\m{(}\m{\varphi}\m{\rightarrow}\m{\psi}\m{)}\m{%
\rightarrow}\m{\lnot}\m{(}\m{\psi}\m{\rightarrow}\m{\varphi}\m{)}\m{)}\m{)}\m{%
\rightarrow}\m{\lnot}\m{(}\m{\lnot}\m{(}\m{(}\m{\varphi}\m{\rightarrow}\m{%
\psi}\m{)}\m{\rightarrow}\m{\lnot}\m{(}\m{\psi}\m{\rightarrow}\m{\varphi}\m{)}%
\m{)}\m{\rightarrow}\m{(}\m{\varphi}\m{\leftrightarrow}\m{\psi}\m{)}\m{)}\m{)}
\endm
\begin{mmraw}%
|- -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) ->
-. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. (
ps -> ph ) ) -> ( ph <-> ps ) ) ) \$.
\end{mmraw}

\noindent Das folgende Theorem stellt eine Beziehung zwischen dem bikonditionalen Junktor und den primitiven Junktoren her und kann verwendet werden, um das $\leftrightarrow$-Symbol aus jeder wff zu eliminieren.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ bii\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\varphi}\m{\leftrightarrow}\m{\psi}\m{)}\m{\leftrightarrow}
\m{\lnot}\m{(}\m{(}\m{\varphi}\m{\rightarrow}\m{\psi}\m{)}\m{\rightarrow}\m{\lnot}
\m{(}\m{\psi}\m{\rightarrow}\m{\varphi}\m{)}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) \$= ... \$.
\end{mmraw}

\noindent Definition der {\bf Disjunktion} ({\sc oder}).\index{Disjunktion ($\vee$)}%
\index{logisches {\sc oder} ($\vee$)}%
\index{df-or@\texttt{df-or}}\label{df-or}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-or\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\varphi}\m{\vee}\m{\psi}\m{)}\m{\leftrightarrow}\m{(}\m{
\lnot}\m{\varphi}\m{\rightarrow}\m{\psi}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( ( ph \TOR ps ) <-> ( -. ph -> ps ) ) \$.
\end{mmraw}

\noindent Definition der {\bf Konjunktion} ({\sc und}).\index{Konjunktion ($\wedge$)}%
\index{logisches {\sc und} ($\wedge$)}%
\index{df-an@\texttt{df-an}}\label{df-an}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-an\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\varphi}\m{\wedge}\m{\psi}\m{)}\m{\leftrightarrow}\m{\lnot}
\m{(}\m{\varphi}\m{\rightarrow}\m{\lnot}\m{\psi}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( ( ph \TAND ps ) <-> -. ( ph -> -. ps ) ) \$.
\end{mmraw}

\noindent Definition der {\bf Disjunktion ({\sc oder}) von 3 wffs}.%
\index{df-3or@\texttt{df-3or}}\label{df-3or}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-3or\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\varphi}\m{\vee}\m{\psi}\m{\vee}\m{\chi}\m{)}\m{
\leftrightarrow}\m{(}\m{(}\m{\varphi}\m{\vee}\m{\psi}\m{)}\m{\vee}\m{\chi}\m{)}
\m{)}
\endm
\begin{mmraw}%
|- ( ( ph \TOR ps \TOR ch ) <-> ( ( ph \TOR ps ) \TOR ch ) ) \$.
\end{mmraw}

\noindent Definition der {\bf Konjunktion ({\sc und}) von 3 wffs}.%
\index{df-3an@\texttt{df-3an}}\label{df-3an}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-3an\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\varphi}\m{\wedge}\m{\psi}\m{\wedge}\m{\chi}\m{)}\m{
\leftrightarrow}\m{(}\m{(}\m{\varphi}\m{\wedge}\m{\psi}\m{)}\m{\wedge}\m{\chi}
\m{)}\m{)}
\endm

\begin{mmraw}%
|- ( ( ph \TAND ps \TAND ch ) <-> ( ( ph \TAND ps ) \TAND ch ) ) \$.
\end{mmraw}

\subsection{Definitionen für die Prädikatenlogik}\label{metadefpred}

Die Symbole $x$, $y$ und $z$ stehen für individuelle Variablen der Prädikatenlogik.  In diesem Abschnitt sind sie nicht notwendigerweise verschieden, es sei denn, es wird ausdrücklich erwähnt.

\vskip 2ex
\noindent Definition der {\bf existentiellen Quantifizierung}. 

Der Ausdruck $\exists x \varphi$ bedeutet "`Es existiert ein $x$, bei dem $\varphi$ wahr ist."'\index{Existenzquantor ($\exists$)}\label{df-ex}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-ex\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\exists}\m{x}\m{\varphi}\m{\leftrightarrow}\m{\lnot}\m{\forall}
\m{x}\m{\lnot}\m{\varphi}\m{)}
\endm
\begin{mmraw}%
|- ( E. x ph <-> -. A. x -. ph ) \$.
\end{mmraw}

\noindent Definition der {\bf echten Substitution}.\index{echte Substitution}\index{Substitution!echte}\label{df-sb}

In unserer Notation verwenden wir $[ y / x ] \varphi$, um "`die wff zu bezeichnen, die sich ergibt, wenn $y$ in der wff $\varphi$ echt durch $x$ ersetzt wird"'.\footnote{Dies kann auch so beschrieben werden, dass $x$ durch $y$ ersetzt wird, $y$ $x$ echt ersetzt, oder $x$ echt durch $y$ ersetzt wird.}
% This is elsb4, though it currently says: ( [ x / y ] z e. y <-> z e. x )
Zum Beispiel ist $[ y / x ] z \in x$ das gleiche wie $z \in y$. Man kann sich diese Notation leicht merken, wenn man sie mit einer Division vergleicht, bei der $( y / x ) \cdot x $ $y$ ist (wenn $x \neq 0$). Die Notation unterscheidet sich von der Notation $\varphi ( x | y )$, die manchmal verwendet wird, weil letztere Notation für uns mehrdeutig ist: Wir wissen zum Beispiel nicht, ob $\lnot \varphi ( x | y )$ als $\lnot ( \varphi ( x | y )$ oder $( \lnot \varphi ) ( x | y )$ zu interpretieren ist.\footnote{Aufgrund der Art und Weise, wie wir wffs ursprünglich definiert haben, ist dies der Fall bei jedem Postfix-Konnektor\index{Postfix-Konnektor} (einer, der nach den zu verbindenden Symbolen auftritt) oder einem Infix-Konnektor\index{Infix-Konnektor} (einer, der zwischen den zu verbindenden Symbolen vorkommt).  Metamath hat keine eingebaute Regel für die Vorrangigkeit einer Operatorausführung, die die Mehrdeutigkeit beseitigen könnte.  Die öffnende Klammer stellt einen effektiven Präfix-Konnektor\index{Präfix-Konnektor} dar, um die Mehrdeutigkeit zu beseitigen.  Einige Konventionen, wie z. B. die polnische Notation\index{polnische Notation}, die in den 1930er und 1940er Jahren von polnischen Logikern verwendet wurde, verwenden nur Präfix-Konnektoren und ermöglichen so den vollständigen Verzicht auf Klammern, was allerdings auf Kosten der Lesbarkeit geht.  In Metamath könnten wir, wenn wir wollten, die gesamte Notation auf die polnische Notation umstellen, ohne irgendwelche Beweise ändern zu müssen!}  In anderen Texten wird oft $\varphi(y)$ verwendet, um unser $[ y / x ] \varphi$ zu bezeichnen, aber diese Schreibweise ist noch mehrdeutiger, da es keinen ausdrücklichen Hinweis darauf gibt, was ersetzt wird. 
Man beachte, dass unsere Definition auch dann gültig ist, wenn $x$ und $y$ die gleiche Variable repräsentieren.  Die erste Konjunktion in der folgenden formalen Definition ist ein "`Trick"', um diese Eigenschaft zu erreichen, was die Definition auf den ersten Blick etwas merkwürdig erscheinen lässt.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-sb\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{[}\m{y}\m{/}\m{x}\m{]}\m{\varphi}\m{\leftrightarrow}\m{(}%
\m{(}\m{x}\m{=}\m{y}\m{\rightarrow}\m{\varphi}\m{)}\m{\wedge}\m{\exists}\m{x}%
\m{(}\m{x}\m{=}\m{y}\m{\wedge}\m{\varphi}\m{)}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( [ y / x ] ph <-> ( ( x = y -> ph ) \TAND E. x ( x = y \TAND ph ) ) ) \$.
\end{mmraw}


\noindent Definition der {\bf existentiellen Eindeutigkeit}\index{Eindeutigkeitsquantor ($\exists "!$)} ("`Es existiert genau einer"').

Man beachte, dass $y$ eine Variable ist, die sich von $x$ unterscheidet und nicht in $\varphi$ vorkommt.\label{df-eu}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-eu\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\exists}\m{{!}}\m{x}\m{\varphi}\m{\leftrightarrow}\m{\exists}
\m{y}\m{\forall}\m{x}\m{(}\m{\varphi}\m{\leftrightarrow}\m{x}\m{=}\m{y}\m{)}\m{)}
\endm

\begin{mmraw}%
|- ( E! x ph <-> E. y A. x ( ph <-> x = y ) ) \$.
\end{mmraw}

\subsection{Definitionen für die Mengenlehre}\label{setdefinitions}

Die Symbole $x$, $y$, $z$ und $w$ stellen individuelle Variablen der Prädikatenlogik dar, die in der Mengenlehre als Mengen verstanden werden. Allerdings wäre es sehr unpraktisch, nur die bisher gezeigten Konstrukte zu verwenden.

Um die Mengenlehre praktikabler zu machen, führen wir den Begriff der "`Klasse"' ein. Eine Klasse\index{Klasse} ist entweder eine Mengenvariable (wie $x$) oder ein Ausdruck der Form $\{ x | \varphi\}$ (genannt eine "`Abstraktionsklasse"'\index{Abstraktionsklasse}\index{Klassenabstraktion}).  Man beachte, dass Mengen (d.h. \ individuelle Variablen) immer existieren (dies ist ein Satz der Logik, nämlich $\exists y \, y = x$ für jede beliebige Menge $x$), während Klassen existieren können oder nicht (d.h. \ $\exists y \, y = A$ kann wahr sein oder nicht). Wenn eine Klasse nicht existiert, wird sie als "`echte Klasse"'\index{echte Klasse}\index{Klasse!echte} bezeichnet. Die Definitionen \texttt{df-clab}, \texttt{df-cleq} und \texttt{df-clel} können verwendet werden, um einen Klassen enthaltenden Ausdruck in einen Ausdruck umzuwandeln, der nur Mengenvariablen und wff-Metavariablen enthält.

Die Symbole $A$, $B$, $C$, $D$, $F$, $G$ und $R$ sind Metavariablen, die sich über Klassen erstrecken.  Eine Klassenmetavariable $A$ kann aus einer wff eliminiert werden, indem sie durch $\{ x|\varphi\}$ ersetzt wird, wobei weder $x$ noch $\varphi$ in der wff vorkommen.

Die Klassentheorie erweist sich als eliminierbare und konservative Erweiterung der Mengenlehre. Die Eigenschaft der \textbf{Eliminierbarkeit} bedeutet, dass wir für jede Formel in der erweiterten Sprache eine logisch äquivalente Formel in der Basissprache bilden können. Auch wenn die erweiterte Sprache die Vermittlung und Formulierung mathematischer Ideen für die Mengenlehre erleichtert, stärkt ihre Ausdruckskraft nicht die Ausdruckskraft der Basissprache. Die Eigenschaft der \textbf{Konservativität} bedeutet, dass wir für jeden Beweis einer Formel der Basissprache, der im erweiterten System geführt wird, einen anderen Beweis derselben Formel, der ausschließlich im Basissystem geführt wird, konstruieren können; so dass die deduktiven Möglichkeiten des erweiterten Systems und des Basissystems identisch sind, wenn es nur um Theoreme über Mengen geht. Zusammen bedeuten diese Eigenschaften, dass die erweiterte Sprache als eine definitorische Erweiterung behandelt werden kann, die \textbf{gesund} ist.

Eine strenge Begründung, die wir hier nicht geben werden, findet sich bei Levy \cite[pp.~357-366]{Levy}, der seine informelle Einführung in die Klassentheorie auf S.~7-17 ergänzt. Zwei weitere gute Abhandlungen der Klassentheorie finden sich bei Quine \cite[pp.~15-21]{Quine}\index{Quine, Willard Van Orman} und auch bei \cite[pp.~10-14]{Takeuti}\index{Takeuti, Gaisi}. Quines Ausführungen (er nennt sie virtuelle Klassen) sind elegant geschrieben und sehr lesenswert.

Im weiteren Verlauf dieses Abschnitts wird immer davon ausgegangen, dass die einzelnen Variablen voneinander verschieden sind, sofern nicht anders angegeben.  Darüber hinaus kommen Dummy-Variablen auf der rechten Seite einer Definition nicht in den zu definierenden Metavariablen für Klassen und wffs vor.

Die hier vorgestellten Definitionen sind eine unvollständige, aber in sich geschlossene Auswahl aus mehreren hundert Definitionen, die in der aktuellen Datenbasis \texttt{set.mm} enthalten sind.  Sie sind ausreichend für eine grundlegende Herleitung der elementaren Mengenlehre.

\vskip 2ex
\noindent Definition einer {\bf Abstraktionsklasse}.\index{Abstraktionsklasse}\index{Klassenabstraktion}\label{df-clab}  $x$ und $y$ müssen nicht verschieden sein.  Definition 2.1 von Quine, S.~16.  Diese Definition mag rätselhaft erscheinen, da sie kürzer ist als der zu definierende Ausdruck und uns in Bezug auf die Kürze keinen Vorteil bringt.  Warum wir diese Definition einführen, ist dadurch begründet, dass sie gut zu der von \texttt{df-clel} bereitgestellten Erweiterung des $\in$-Symbols passt.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-clab\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{\in}\m{\{}\m{y}\m{|}\m{\varphi}\m{\}}\m{%
\leftrightarrow}\m{[}\m{x}\m{/}\m{y}\m{]}\m{\varphi}\m{)}
\endm
\begin{mmraw}%
|- ( x e. \{ y | ph \} <-> [ x / y ] ph ) \$.
\end{mmraw}

\noindent Definition des {\bf Gleichheitszeichen zwischen Klassen}\index{Klassengleichheit}\label{df-cleq}.  Siehe Quine oder Kapitel 4 von Takeuti und Zaring für die Rechtfertigung und die Methoden zu ihrer Eliminierung.  Dies ist ein Beispiel für eine etwas "`gefährliche"' Definition, denn sie erweitert die Verwendung des bestehenden Gleichheitssymbols, anstatt ein neues Symbol einzuführen, und erlaubt uns, in der ursprünglichen Sprache Aussagen zu machen, die möglicherweise nicht wahr sind. Zum Beispiel erlaubt sie uns, $y = z \leftrightarrow \forall x ( x \in y \leftrightarrow x \in z )$ abzuleiten, was kein Satz der Logik ist, sondern das Extensionalitätsaxiom\index{Extensionalitätsaxiom} voraussetzt, das wir als Hypothese einfügen, damit wir wissen, wann dieses Axiom in einem Beweis vorausgesetzt wird (mit dem Befehl \texttt{show trace{\char`\_}back}).  Wir könnten die Gefahr vermeiden, indem wir ein anderes Symbol, sagen wir $\eqcirc$, anstelle von $=$ einführen; dies hätte auch den Vorteil, dass die Definition einfach zu eliminieren wäre und die Notwendigkeit der Extensionalität als Hypothese entfiele.  Wir hätten dann auch den Vorteil, dass wir genau feststellen könnten, wo die Extensionalität wirklich ins Spiel kommt.  Eines unserer Theoreme wäre $x \eqcirc y \leftrightarrow x = y$, indem wir uns auf die Extensionalität berufen.  In Übereinstimmung mit der üblichen Praxis behalten wir jedoch die "`gefährliche"' Definition bei.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-cleq.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\forall}\m{x}\m{(}\m{x}\m{\in}\m{y}\m{\leftrightarrow}\m{x}
\m{\in}\m{z}\m{)}\m{\rightarrow}\m{y}\m{=}\m{z}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ df-cleq\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{=}\m{B}\m{\leftrightarrow}\m{\forall}\m{x}\m{(}\m{x}\m{
\in}\m{A}\m{\leftrightarrow}\m{x}\m{\in}\m{B}\m{)}\m{)}
\endm
% We need to reset the startprefix and contprefix.
\setbox\startprefix=\hbox{\tt \ \ df-cleq.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\begin{mmraw}%
|- ( A. x ( x e. y <-> x e. z ) -> y = z ) \$.
\end{mmraw}
\setbox\startprefix=\hbox{\tt \ \ df-cleq\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\begin{mmraw}%
|- ( A = B <-> A. x ( x e. A <-> x e. B ) ) \$.
\end{mmraw}

\noindent Definition des {\bf Elementprädikates zwischen Klassen}\index{Klassenzugehörigkeit}.  Theorem 6.3 von Quine, S.~41, das wir als Definition übernehmen. Man beachte, dass er die Verwendung des bestehenden Zugehörigkeitssymbols erweitert, aber im Gegensatz zu {\tt df-cleq} nicht die Menge der gültigen wffs der Logik erweitert, wenn die Klassenmetavariablen durch Mengenvariablen ersetzt werden.\label{dfclel}\label{df-clel}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-clel\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{B}\m{\leftrightarrow}\m{\exists}\m{x}\m{(}\m{x}
\m{=}\m{A}\m{\wedge}\m{x}\m{\in}\m{B}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( A e. B <-> E. x ( x = A \TAND x e. B ) ) \$.?
\end{mmraw}

\noindent Definition der {\bf Ungleichheit}.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-ne\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\ne}\m{B}\m{\leftrightarrow}\m{\lnot}\m{A}\m{=}\m{B}%
\m{)}
\endm
\begin{mmraw}%
|- ( A =/= B <-> -. A = B ) \$.
\end{mmraw}

\noindent Definition der {\bf eingeschränkten Allquantifizierung}.\index{Allquantor ($\forall$)!eingeschränkt}  Enderton, S.~22.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-ral\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\forall}\m{x}\m{\in}\m{A}\m{\varphi}\m{\leftrightarrow}\m{%
\forall}\m{x}\m{(}\m{x}\m{\in}\m{A}\m{\rightarrow}\m{\varphi}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( A. x e. A ph <-> A. x ( x e. A -> ph ) ) \$.
\end{mmraw}

\noindent Definition der {\bf eingeschränkten Existenzquantifizierung}.\index{Existenzquantor ($\exists$)!eingeschränkt}  Enderton, S.~22.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-rex\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\exists}\m{x}\m{\in}\m{A}\m{\varphi}\m{\leftrightarrow}\m{%
\exists}\m{x}\m{(}\m{x}\m{\in}\m{A}\m{\wedge}\m{\varphi}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( E. x e. A ph <-> E. x ( x e. A \TAND ph ) ) \$.
\end{mmraw}

\noindent Definition der {\bf universellen Klasse}\index{universelle Klasse ($V$)}.  Definition 5.20, S.~21, von Takeuti und Zaring.\label{df-v}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-v\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{{\rm V}}\m{=}\m{\{}\m{x}\m{|}\m{x}\m{=}\m{x}\m{\}}
\endm
\begin{mmraw}%
|- {\char`\_}V = \{ x | x = x \} \$.
\end{mmraw}

\noindent Definition der {\bf Unterklassen\index{Unterklasse}\index{Teilmenge}-Beziehung zwischen zwei Klassen} (die so genannte Untermengen-Beziehung, wenn die Klassen Mengen sind, d. h.\ keine echten Klassen).
Definition 5.9 von Takeuti und Zaring, S.~17.\label{df-ss}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-ss\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\subseteq}\m{B}\m{\leftrightarrow}\m{\forall}\m{x}\m{(}
\m{x}\m{\in}\m{A}\m{\rightarrow}\m{x}\m{\in}\m{B}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( A C\_ B <-> A. x ( x e. A -> x e. B ) ) \$.
\end{mmraw}

\noindent Definition der {\bf Vereinigung\index{Vereinigung} von zwei Klassen}.  Definition 5.6 von Takeuti und Zaring, S.~16.\label{df-un}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-un\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\cup}\m{B}\m{)}\m{=}\m{\{}\m{x}\m{|}\m{(}\m{x}\m{\in}
\m{A}\m{\vee}\m{x}\m{\in}\m{B}\m{)}\m{\}}
\endm
\begin{mmraw}%
( A u. B ) = \{ x | ( x e. A \TOR x e. B ) \} \$.
\end{mmraw}

\noindent Definition des {\bf Schnitts\index{Schnittmenge} zwischen zwei Klassen}.  Definition 5.6 von Takeuti und Zaring, S.~16.\label{df-in}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-in\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\cap}\m{B}\m{)}\m{=}\m{\{}\m{x}\m{|}\m{(}\m{x}\m{\in}
\m{A}\m{\wedge}\m{x}\m{\in}\m{B}\m{)}\m{\}}
\endm
% Caret ^ requires special treatment
\begin{mmraw}%
|- ( A i\^{}i B ) = \{ x | ( x e. A \TAND x e. B ) \} \$.
\end{mmraw}

\noindent Definition der {\bf Klassendifferenz}\index{Klassendifferenz}\index{Mengendifferenz}. Definition 5.12 von Takeuti und Zaring, S.~20.  In der Literatur werden verschiedene Schreibweisen verwendet; wir haben die Konvention $\setminus$ anstelle eines Minuszeichens gewählt, um letzteres für die spätere Verwendung z.B. in der Arithmetik zu reservieren.\label{df-dif}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-dif\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\setminus}\m{B}\m{)}\m{=}\m{\{}\m{x}\m{|}\m{(}\m{x}\m{
\in}\m{A}\m{\wedge}\m{\lnot}\m{x}\m{\in}\m{B}\m{)}\m{\}}
\endm
\begin{mmraw}%
( A \SLASH B ) = \{ x | ( x e. A \TAND -. x e. B ) \} \$.
\end{mmraw}

\noindent Definition der {\bf leeren Menge}\index{leere Menge}. Vergleiche Definition 5.14 von Takeuti und Zaring, S.~20.\label{df-nul}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-nul\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\varnothing}\m{=}\m{(}\m{{\rm V}}\m{\setminus}\m{{\rm V}}\m{)}
\endm
\begin{mmraw}%
|- (/) = ( {\char`\_}V \SLASH {\char`\_}V ) \$.
\end{mmraw}

\noindent Definition der {\bf Potenzklasse}\index{Potenzmenge}\index{Potenzklasse}.  Definition 5.10 von Takeuti und Zaring, S.~17, aber wir lassen sie auch für echte Klassen gelten.  (Beachten Sie, dass \verb$~P$ das Symbol für das kalligraphische P ist, wobei die Tilde für "`lockig"' steht; siehe Anhang~\ref{ASCII}.)\label{df-pw}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-pw\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{{\cal P}}\m{A}\m{=}\m{\{}\m{x}\m{|}\m{x}\m{\subseteq}\m{A}\m{\}}
\endm
% Special incantation required to put ~ into the text
\begin{mmraw}%
|- \char`\~P~A = \{ x | x C\_ A \} \$.
\end{mmraw}

\noindent Definition einer {\bf einelementigen Klasse (Singleton)}\index{Singleton}.  Definition 7.1 von Quine, S.~48.  Sie ist auch für echte Klassen wohldefiniert, obwohl sie in diesem Fall nicht sehr aussagekräftig ist, da sie zur leeren Menge ausgewertet wird.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-sn\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\{}\m{A}\m{\}}\m{=}\m{\{}\m{x}\m{|}\m{x}\m{=}\m{A}\m{\}}
\endm
\begin{mmraw}%
|- \{ A \} = \{ x | x = A \} \$.
\end{mmraw}%

\noindent Definition eines {\bf ungeordneten Klassenpaares}\index{ungeordnetes Paar}\index{Paar}.  Definition 7.1 von Quine, S.~48.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-pr\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\{}\m{A}\m{,}\m{B}\m{\}}\m{=}\m{(}\m{\{}\m{A}\m{\}}\m{\cup}\m{\{}
\m{B}\m{\}}\m{)}
\endm
\begin{mmraw}%
|- \{ A , B \} = ( \{ A \} u. \{ B \} ) \$.
\end{mmraw}

\noindent Definition eines {\bf ungeordneten Klassentripels}\index{ungeordnetes Tripel}.  Definition von Enderton, S.~19.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-tp\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\{}\m{A}\m{,}\m{B}\m{,}\m{C}\m{\}}\m{=}\m{(}\m{\{}\m{A}\m{,}\m{B}
\m{\}}\m{\cup}\m{\{}\m{C}\m{\}}\m{)}
\endm
\begin{mmraw}%
|- \{ A , B , C \} = ( \{ A , B \} u. \{ C \} ) \$.
\end{mmraw}%

\noindent Definition von Kuratowskis\index{Kuratowski, Kazimierz} {\bf geordneten Klassenpaares}\index{geordnetes Paar}-Definition.  Definition 9.1 von Quine, S.~58. Für echte Klassen ist sie nicht sinnvoll, aber der Einfachheit halber wohldefiniert.  (Man beachte, dass \verb$<.$ für $\langle$ steht, während \verb$<$ für $<$ steht.)\label{df-op}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-op\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\langle}\m{A}\m{,}\m{B}\m{\rangle}\m{=}\m{\{}\m{\{}\m{A}\m{\}}
\m{,}\m{\{}\m{A}\m{,}\m{B}\m{\}}\m{\}}
\endm
\begin{mmraw}%
|- <. A , B >. = \{ \{ A \} , \{ A , B \} \} \$.
\end{mmraw}

\noindent Definition der {\bf Vereinigung einer Klasse}\index{Vereinigung}.  Definition 5.5, S.~16, von Takeuti und Zaring.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-uni\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\bigcup}\m{A}\m{=}\m{\{}\m{x}\m{|}\m{\exists}\m{y}\m{(}\m{x}\m{
\in}\m{y}\m{\wedge}\m{y}\m{\in}\m{A}\m{)}\m{\}}
\endm
\begin{mmraw}%
|- U. A = \{ x | E. y ( x e. y \TAND y e. A ) \} \$.
\end{mmraw}

\noindent Definition des {\bf Schnittes\index{Schnittmenge} einer Klasse}.  Definition 7.35, S.~44, von Takeuti und Zaring.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-int\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\bigcap}\m{A}\m{=}\m{\{}\m{x}\m{|}\m{\forall}\m{y}\m{(}\m{y}\m{
\in}\m{A}\m{\rightarrow}\m{x}\m{\in}\m{y}\m{)}\m{\}}
\endm
\begin{mmraw}%
|- |\^{}| A = \{ x | A. y ( y e. A -> x e. y ) \} \$.
\end{mmraw}

\noindent Definition einer {\bf transitiven Klasse}\index{transitive Klasse}\index{transitive Menge}.  Dies sollte nicht mit einer transitiven Beziehung verwechselt werden, die ein anderes Konzept ist.  Definition aus S.~71 von Enderton, erweitert auf Klassen.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-tr\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\mbox{\rm Tr}}\m{A}\m{\leftrightarrow}\m{\bigcup}\m{A}\m{
\subseteq}\m{A}\m{)}
\endm
\begin{mmraw}%
|- ( Tr A <-> 
U. A C\_ A ) \$.
\end{mmraw}
\noindent Definition einer Notation für eine {\bf allgemeine binäre Relation}\index{binäre Relation}.  Definition 6.18, S.~29, von Takeuti und Zaring, verallgemeinert auf beliebige Klassen.  Diese Definition ist wohldefiniert, wenn auch nicht sehr aussagekräftig, wenn die Klassen $A$ und/oder $B$ echte Klassen sind.\label{dfbr}  Das Fehlen von Klammern (oder eines anderen Konnektors) erzeugt keine Mehrdeutigkeit, da wir eine atomare wff definieren.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-br\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\,R}\m{\,B}\m{\leftrightarrow}\m{\langle}\m{A}\m{,}\m{B}
\m{\rangle}\m{\in}\m{R}\m{)}
\endm
\begin{mmraw}%
|- ( A R B <-> <. A , B >. e. R ) \$.
\end{mmraw}

\noindent Definition einer {\bf Abstraktionsklasse von geordneten Paaren} \index{Abstraktionsklasse!von geordneten Paaren}.  Ein Spezialfall der Definition 4.16, S.~14, von Takeuti und Zaring. Man beachte, dass $ z $ von $ x $ und $ y $ verschieden sein muss und $ z $ nicht in $\varphi$ vorkommen darf, aber $ x $ und $ y $ können identisch sein und in $\varphi$ vorkommen.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-opab\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\{}\m{\langle}\m{x}\m{,}\m{y}\m{\rangle}\m{|}\m{\varphi}\m{\}}\m{=}
\m{\{}\m{z}\m{|}\m{\exists}\m{x}\m{\exists}\m{y}\m{(}\m{z}\m{=}\m{\langle}\m{x}
\m{,}\m{y}\m{\rangle}\m{\wedge}\m{\varphi}\m{)}\m{\}}
\endm

\begin{mmraw}%
|- \{ <. x , y >. | ph \} = \{ z | E. x E. y ( z =
<. x , y >. \TAND ph ) \} \$.
\end{mmraw}

\noindent Definition der {\bf Epsilon-Relation}\index{Epsilon-Relation}.  Ähnlich der Definition 6.22, S.~30, von Takeuti und Zaring.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-eprel\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{{\rm E}}\m{=}\m{\{}\m{\langle}\m{x}\m{,}\m{y}\m{\rangle}\m{|}\m{x}\m{
\in}\m{y}\m{\}}
\endm
\begin{mmraw}%
|- \_E = \{ <. x , y >. | x e. y \} \$.
\end{mmraw}

\noindent Definition einer {\b fundierten Relation}\index{fundierte Relation}.  $R$ ist eine fundierte Relation auf $A$, genau dann, wenn (wenn und nur dann, wenn) jede nichtleere Teilmenge von $A$ ein "`$R$-minimales Element"' hat.  Ähnlich der Definition 6.21, S.~30, von Takeuti und Zaring.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-fr\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{R}\m{\,\mbox{\rm Fr}}\m{\,A}\m{\leftrightarrow}\m{\forall}\m{x}
\m{(}\m{(}\m{x}\m{\subseteq}\m{A}\m{\wedge}\m{\lnot}\m{x}\m{=}\m{\varnothing}
\m{)}\m{\rightarrow}\m{\exists}\m{y}\m{(}\m{y}\m{\in}\m{x}\m{\wedge}\m{(}\m{x}
\m{\cap}\m{\{}\m{z}\m{|}\m{z}\m{\,R}\m{\,y}\m{\}}\m{)}\m{=}\m{\varnothing}\m{)}
\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( R Fr A <-> A. x ( ( x C\_ A \TAND -. x = (/) ) ->
E. y ( y e. x \TAND ( x i\^{}i \{ z | z R y \} ) = (/) ) ) ) \$.
\end{mmraw}

\noindent Definition einer {\bf Wohlordnung}\index{Wohlordnung}.  $R$ ist eine Wohlordnung von $A$ genau dann, wenn sie auf $A$ fundiert ist und die Elemente von $A$ paarweise $R$-vergleichbar sind. Ähnlich der Definition 6.24(2), S.~30, von Takeuti und Zaring.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-we\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{R}\m{\,\mbox{\rm We}}\m{\,A}\m{\leftrightarrow}\m{(}\m{R}\m{\,
\mbox{\rm Fr}}\m{\,A}\m{\wedge}\m{\forall}\m{x}\m{\forall}\m{y}\m{(}\m{(}\m{x}\m{
\in}\m{A}\m{\wedge}\m{y}\m{\in}\m{A}\m{)}\m{\rightarrow}\m{(}\m{x}\m{\,R}\m{\,y}
\m{\vee}\m{x}\m{=}\m{y}\m{\vee}\m{y}\m{\,R}\m{\,x}\m{)}\m{)}\m{)}\m{)}
\endm
\begin{mmraw}%
( R We A <-> ( R Fr A \TAND A. x A. y ( ( x e.
A \TAND y e. A ) -> ( x R y \TOR x = y \TOR y R x ) ) ) ) \$.
\end{mmraw}

\noindent Definition des {\bf Ordinalprädikats}\index{Ordinalprädikat}, das für eine Klasse gilt, die transitiv ist und durch die Epsilon-Relation wohlgeordnet ist.  Ähnlich der Definition auf S.~468, Bell und Machover.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-ord\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\mbox{\rm Ord}}\m{\,A}\m{\leftrightarrow}\m{(}
\m{\mbox{\rm Tr}}\m{\,A}\m{\wedge}\m{E}\m{\,\mbox{\rm We}}\m{\,A}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( Ord A <-> ( Tr A \TAND E We A ) ) \$.
\end{mmraw}

\noindent Definition der {\bf Klasse aller Ordinalzahlen}\index{Ordinalzahl}.  Eine Ordinalzahl ist eine Menge, die das Ordinalprädikat erfüllt.  Definition 7.11 von Takeuti und Zaring, S.~38.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-on\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\,\mbox{\rm On}}\m{=}\m{\{}\m{x}\m{|}\m{\mbox{\rm Ord}}\m{\,x}
\m{\}}
\endm
\begin{mmraw}%
|- On = \{ x | Ord x \} \$.
\end{mmraw}

\noindent Definition des {\bf Limes-Prädikats}, das für eine nicht leere Ordinalzahl gilt, die kein Nachfolger ist (d.h. \ die die Vereinigung ihrer selbst ist)\index{Grenzzahl}. Vergleiche Bell und Machover, S.~471 und Übung (1), S.~42 von Takeuti und Zaring.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-lim\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\mbox{\rm Lim}}\m{\,A}\m{\leftrightarrow}\m{(}\m{\mbox{
\rm Ord}}\m{\,A}\m{\wedge}\m{\lnot}\m{A}\m{=}\m{\varnothing}\m{\wedge}\m{A}
\m{=}\m{\bigcup}\m{A}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( Lim A <-> ( Ord A \TAND -. A = (/) \TAND A = U. A ) ) \$.
\end{mmraw}

\noindent Definition eines {\bf Nachfolgers}\index{Nachfolger} einer Klasse.  Definition 7.22 von Takeuti und Zaring, S.~41.  Unsere Definition ist eine Verallgemeinerung auf Klassen, obwohl sie für echte Klassen bedeutungslos ist.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-suc\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\,\mbox{\rm suc}}\m{\,A}\m{=}\m{(}\m{A}\m{\cup}\m{\{}\m{A}\m{\}}
\m{)}
\endm
\begin{mmraw}%
|- suc A = ( A u. \{ A \} ) \$.
\end{mmraw}

\noindent Definition der {\bf Klasse der natürlichen Zahlen}\index{natürliche Zahlen}\index{Omega ($\omega$)}.  Vergleiche Bell und Machover, S.~471.\label{dfom}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-om\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\omega}\m{=}\m{\{}\m{x}\m{|}\m{(}\m{\mbox{\rm Ord}}\m{\,x}\m{
\wedge}\m{\forall}\m{y}\m{(}\m{\mbox{\rm Lim}}\m{\,y}\m{\rightarrow}\m{x}\m{
\in}\m{y}\m{)}\m{)}\m{\}}
\endm
\begin{mmraw}%
|- om = \{ x | ( Ord x \TAND A. y ( Lim y -> x e. y ) ) \} \$.
\end{mmraw}

\noindent Definition eines {\bf kartesischen Produkts} (auch {\bf Kreuzprodukt}\index{Kartesisches Produkt}\index{Kreuzprodukt} genannt) von zwei Klassen.  Definition 9.11 von Quine, S.~64. 

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-xp\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\times}\m{B}\m{)}\m{=}\m{\{}\m{\langle}\m{x}\m{,}\m{y}
\m{\rangle}\m{|}\m{(}\m{x}\m{\in}\m{A}\m{\wedge}\m{y}\m{\in}\m{B}\m{)}\m{\}}
\endm
\begin{mmraw}%
|- ( A X. B ) = \{ <. x , y >. | ( x e. A \TAND y e. B) \} \$.
\end{mmraw}

\noindent Definition einer {\bf Relation}\index{Relation}.  Definition 6.4(1) von Takeuti und Zaring, S.~23.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-rel\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\mbox{\rm Rel}}\m{\,A}\m{\leftrightarrow}\m{A}\m{\subseteq}
\m{(}\m{{\rm V}}\m{\times}\m{{\rm V}}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( Rel A <-> A C\_ ( {\char`\_}V X. {\char`\_}V ) ) \$.
\end{mmraw}

\noindent Definition eines {\bf Definitionsbereichs}\index{Definitionsbereich} einer Klasse\footnote{Anm. der Übersetzer: Der Begriff "`Definitionsbereich"' und die folgenden Begriffe wie "`Wertebereich"' etc. werden üblicherweise für Funktionen oder zumindest Relationen verwendet, können aber so wie hier für beliebige Klassen definiert werden.}.  Definition 6.5(1) von Takeuti und Zaring, S.~24.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-dm\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\,\mbox{\rm dom}}\m{A}\m{=}\m{\{}\m{x}\m{|}\m{\exists}\m{y}\m{
\langle}\m{x}\m{,}\m{y}\m{\rangle}\m{\in}\m{A}\m{\}}
\endm
\begin{mmraw}%
|- dom A = \{ x | E. y <. x , y >. e. A \} \$.
\end{mmraw}

\noindent Definition des {\bf Wertebereichs}\index{Wertebereich} einer Klasse.  Definition 6.5(2) von Takeuti und Zaring, S.~24.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-rn\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\,\mbox{\rm ran}}\m{A}\m{=}\m{\{}\m{y}\m{|}\m{\exists}\m{x}\m{
\langle}\m{x}\m{,}\m{y}\m{\rangle}\m{\in}\m{A}\m{\}}
\endm
\begin{mmraw}%
|- ran A = \{ y | E. x <. x , y >. e. A \} \$.
\end{mmraw}

\noindent Definition einer {\bf Einschränkung}\index{Einschränkung} einer Klasse.  Definition 6.6(1) von Takeuti und Zaring, S.~24.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-res\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\restriction}\m{B}\m{)}\m{=}\m{(}\m{A}\m{\cap}\m{(}\m{B}
\m{\times}\m{{\rm V}}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( A |` B ) = ( A i\^{}i ( B X. {\char`\_}V ) ) \$.
\end{mmraw}

\noindent Definition des {\bf Bildes}\index{Bild} einer Klasse.  Definition 6.6(2) von Takeuti und Zaring, S.~24.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-ima\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{``}\m{B}\m{)}\m{=}\m{\,\mbox{\rm ran}}\m{\,(}\m{A}\m{
\restriction}\m{B}\m{)}
\endm
\begin{mmraw}%
|- ( A "{} B ) = ran ( A |` B ) \$.
\end{mmraw}

\noindent Definition der {\bf Komposition}\index{Komposition} zweier Klassen.  Definition 6.6(3) von Takeuti und Zaring, S.~24.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-co\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\circ}\m{B}\m{)}\m{=}\m{\{}\m{\langle}\m{x}\m{,}\m{y}\m{
\rangle}\m{|}\m{\exists}\m{z}\m{(}\m{\langle}\m{x}\m{,}\m{z}\m{\rangle}\m{\in}
\m{B}\m{\wedge}\m{\langle}\m{z}\m{,}\m{y}\m{\rangle}\m{\in}\m{A}\m{)}\m{\}}
\endm
\begin{mmraw}%
|- ( A o. B ) = \{ <. x , y >. | E. z ( <. x , z
>. e. B \TAND <. z , y >. e. A ) \} \$.
\end{mmraw}

\noindent Definition einer {\bf Funktion}\index{Funktion}.  Definition 6.4(4) von Takeuti und Zaring, S.~24.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-fun\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\mbox{\rm Fun}}\m{\,A}\m{\leftrightarrow}\m{(}
\m{\mbox{\rm Rel}}\m{\,A}\m{\wedge}
\m{\forall}\m{x}\m{\exists}\m{z}\m{\forall}\m{y}\m{(}
\m{\langle}\m{x}\m{,}\m{y}\m{\rangle}\m{\in}\m{A}\m{\rightarrow}\m{y}\m{=}\m{z}
\m{)}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( Fun A <-> ( Rel A \TAND A. x E. z A. y ( <. x
   , y >. e. A -> y = z ) ) ) \$.
\end{mmraw}

\noindent Definition einer {\bf Funktion mit Definitionsbereich}.  Definition 6.15(1) von Takeuti und Zaring, S.~27.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-fn\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\,\mbox{\rm Fn}}\m{\,B}\m{\leftrightarrow}\m{(}
\m{\mbox{\rm Fun}}\m{\,A}\m{\wedge}\m{\mbox{\rm dom}}\m{\,A}\m{=}\m{B}\m{)}
\m{)}
\endm
\begin{mmraw}%
|- ( A Fn B <-> ( Fun A \TAND dom A = B ) ) \$.
\end{mmraw}

\noindent Definition einer {\bf Funktion mit Definitionsbereich und Zielbereich}.  Definition 6.15(3) von Takeuti und Zaring, S.~27.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-f\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{F}\m{:}\m{A}\m{\longrightarrow}\m{B}\m{
\leftrightarrow}\m{(}\m{F}\m{\,\mbox{\rm Fn}}\m{\,A}\m{\wedge}\m{
\mbox{\rm ran}}\m{\,F}\m{\subseteq}\m{B}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( F : A --> B <-> ( F Fn A \TAND ran F C\_ B ) ) \$.
\end{mmraw}

\noindent Definition einer {\bf injektiven} oder {\bf Eins-zu-eins-Funktion}\index{injektive Funktion}.  Vergleiche Definition 6.15(5) von Takeuti und Zaring, S.~27.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-f1\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{F}\m{:}\m{A}\m{
\raisebox{.5ex}{${\textstyle{\:}_{\mbox{\footnotesize\rm
1\tt -\rm 1}}}\atop{\textstyle{
\longrightarrow}\atop{\textstyle{}^{\mbox{\footnotesize\rm {\ }}}}}$}
}\m{B}
\m{\leftrightarrow}\m{(}\m{F}\m{:}\m{A}\m{\longrightarrow}\m{B}
\m{\wedge}\m{\forall}\m{y}\m{\exists}\m{z}\m{\forall}\m{x}\m{(}\m{\langle}\m{x}
\m{,}\m{y}\m{\rangle}\m{\in}\m{F}\m{\rightarrow}\m{x}\m{=}\m{z}\m{)}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( F : A -1-1-> B <-> ( F : A --> B \TAND
   A. y E. z A. x ( <. x , y >. e. F -> x = z ) ) ) \$.
\end{mmraw}

\noindent Definition einer {\bf surjektiven} oder {\bf rechtstotalen Funktion}\index{surjektive Funktion}\footnote{Im Englischen {\bf onto function}.}.  Definition 6.15(4) von Takeuti und Zaring, S.~27.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-fo\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{F}\m{:}\m{A}\m{
\raisebox{.5ex}{${\textstyle{\:}_{\mbox{\footnotesize\rm
{\ }}}}\atop{\textstyle{
\longrightarrow}\atop{\textstyle{}^{\mbox{\footnotesize\rm onto}}}}$}
}\m{B}
\m{\leftrightarrow}\m{(}\m{F}\m{\,\mbox{\rm Fn}}\m{\,A}\m{\wedge}
\m{\mbox{\rm ran}}\m{\,F}\m{=}\m{B}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( F : A -onto-> B\linebreak
<-> ( F Fn A \TAND ran F = B ) ) \$.
\end{mmraw}

\noindent Definition einer {\bf bijektiven Funktion}\index{bijektive Funktion}.  Vergleiche Definition 6.15(6) von Takeuti und Zaring, S.~27.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-f1o\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{F}\m{:}\m{A}
\m{
\raisebox{.5ex}{${\textstyle{\:}_{\mbox{\footnotesize\rm
1\tt -\rm 1}}}\atop{\textstyle{
\longrightarrow}\atop{\textstyle{}^{\mbox{\footnotesize\rm onto}}}}$}
}
\m{B}
\m{\leftrightarrow}\m{(}\m{F}\m{:}\m{A}
\m{
\raisebox{.5ex}{${\textstyle{\:}_{\mbox{\footnotesize\rm
1\tt -\rm 1}}}\atop{\textstyle{
\longrightarrow}\atop{\textstyle{}^{\mbox{\footnotesize\rm {\ }}}}}$}
}
\m{B}\m{\wedge}\m{F}\m{:}\m{A}
\m{
\raisebox{.5ex}{${\textstyle{\:}_{\mbox{\footnotesize\rm
{\ }}}}\atop{\textstyle{
\longrightarrow}\atop{\textstyle{}^{\mbox{\footnotesize\rm onto}}}}$}
}
\m{B}\m{)}\m{)}
\endm
\begin{mmraw}%
|- ( F : A -1-1-onto-> B \linebreak
<-> ( F : A -1-1-> B \TAND F : A -onto-> B ) ) \$.
\end{mmraw}

\noindent Definition eines {\bf Funktionswertes}\index{Funktionswert}.  Diese Definition gilt für jede Klasse und wird zur leeren Menge ausgewertet, wenn sie nicht sinnvoll ist. Beachten Sie, dass $ F`A$ dasselbe bedeutet wie die bekanntere Notation $ F(A)$ für den Wert einer Funktion an der Stelle $A$.  Die Notation $ F`A$ ist in der formalen Mengenlehre gebräuchlich.\label{df-fv}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-fv\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{F}\m{`}\m{A}\m{)}\m{=}\m{\bigcup}\m{\{}\m{x}\m{|}\m{(}\m{F}%
\m{``}\m{\{}\m{A}\m{\}}\m{)}\m{=}\m{\{}\m{x}\m{\}}\m{\}}
\endm
\begin{mmraw}%
|- ( F ` A ) = U. \{ x | ( F "{} \{ A \} ) = \{ x \} \} \$.
\end{mmraw}

\noindent Definition des {\bf Ergebnisses einer Operation}.\index{Operation} Hier ist $F$ eine Operation für zwei Operanden (z. B. $+$ für reelle Zahlen).   Dies ist auch für echte Klassen $A$ und $B$ definiert, auch wenn es in diesem Fall nicht sinnvoll ist\footnote{Anm. der Übersetzer: das Ergebnis ist in diesem Fall wie bei einem Funktionswert die leere Menge.}.  Die Definition kann jedoch zu einem sinnvollen Ergebnis führen, wenn $F$ eine echte Klasse ist.\label{dfopr}

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ df-opr\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\,F}\m{\,B}\m{)}\m{=}\m{(}\m{F}\m{`}\m{\langle}\m{A}%
\m{,}\m{B}\m{\rangle}\m{)}
\endm
\begin{mmraw}%
|- ( A F B ) = ( F ` <. A , B >. ) \$.
\end{mmraw}

\section{Tricks des Verfahrens}\label{tricks}

 In der Regel war es unser Ziel, in der Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} die moderne Notation zu verwenden.  In einigen Fällen wurde aber in unkonventioneller Weise von der in den Standardlehrbüchern verwendeten Sprache abgewichen, um deren Weiterentwicklung zu vereinfachen und die Vorteile der Metamath-Sprache besser zu nutzen.  In diesem Abschnitt werden wir einige allgemeine, in \texttt{set.mm} verwendete  Konventionen beschreiben.

\begin{itemize}
\item
Das Drehkreuzsymbol $\vdash$, das "`es ist beweisbar, dass"' bedeutet, ist das erste Token aller Behauptungen und Hypothesen, die keine Syntaxkonstruktionen sind.  Dies ist eine Standardkonvention in der Logik.  (Wir haben dies bereits erwähnt, aber dieses Symbol ist für manche Menschen ohne Logikkenntnisse etwas verstörend.  Es hat keine tiefere Bedeutung, sondern dient nur dazu, Syntaxkonstruktionen von gewöhnlichen mathematischen Aussagen zu unterscheiden).

\item
Eine Annahme der Form

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\varphi}\m{\rightarrow}\m{\forall}\m{x}\m{\varphi}\m{)}
\endm
\vskip 1ex

sollte als "`unter der Annahme, dass die Variable $x$ in wff $\varphi$ (effektiv) nicht frei ist"'\index{effektiv nicht frei} verstanden werden. Wörtlich heißt das: "`Angenommen, es ist beweisbar, dass $\varphi \rightarrow \forall x\, \varphi$."'  Auf diese Weise können wir die Komplexität vermeiden, die mit der Standardbehandlung von freien und gebundenen Variablen verbunden ist. 
%Uncomment this when uncommenting section {formalspec} below
In der Fußnote auf S.~\pageref{effectivelybound} wird dies näher erläutert.

\item
Eine Aussage in einer der Formen

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\lnot}\m{\forall}\m{x}\m{\,x}\m{=}\m{y}\m{\rightarrow}
\m{\ldots}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\lnot}\m{\forall}\m{x}\m{\,x}\m{=}\m{y}\m{\rightarrow}
\m{\ldots}\m{)}
\endm
\vskip 1ex

sollte als "`Wenn $x$ und $y$ verschiedene Variablen sind, dann..."' verstanden werden.  Mit solch einer Voraussetzung können wir in der frühen Entwicklung der Prädikatenlogik auf die \texttt{\$d}-Anweisung verzichten, so dass Symbolmanipulationen konzeptionell so einfach sind wie in der Aussagenlogik. Sobald die \texttt{\$d}-Anweisung jedoch mehr und mehr zum Einsatz gekommen ist, wird dieses Konstrukt nur noch selten verwendet.

\item
Die Aussage

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$d\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{x}\m{\,y}
\endm
\vskip 1ex

sollte als "`Angenommen $x$ und $y$ sind unterschiedliche Variablen"' verstanden werden.

\item
Die Anweisung

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$d\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{x}\m{\,\varphi}
\endm
\vskip 1ex

sollte als "`angenommen $x$ kommt in $\varphi$ nicht vor"' verstanden werden.

\item
Die Anweisung

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$d\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{x}\m{\,A}
\endm
\vskip 1ex

sollte als "`angenommen, die Variable $x$ kommt in der Klasse $A$ nicht vor"' verstanden werden.

\item
Die folgende Gruppe von Variableneinschränkungen und Hypothesen

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$d\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{x}\m{\,A}
\endm
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$d\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{x}\m{\,\psi}
\endm
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{=}\m{A}\m{\rightarrow}\m{(}\m{\varphi}\m{\leftrightarrow}
\m{\psi}\m{)}\m{)}
\endm
\vskip 1ex

wird häufig anstelle der expliziten Substitution verwendet, was bedeutet: "`angenommen, $\psi$ ergibt sich aus der echten Substitution von $A$ für $x$ in $\varphi$."'\footnote{Anm. der Übersetzer: dies wird dann eine "`implizite Substitution"' genannt.}  Manchmal wird "`\texttt{\$e} $\vdash ( \psi \rightarrow \forall x \, \psi )$"' anstelle von "`\texttt{\$d} $x\, \psi $"'\footnote{Anm. der Übersetzer: Solche Hypothesen werden neuerdings durch  "`\texttt{\$e} $\vdash F/ \, x \, \psi $"' ersetzt.} verwendet, was nur voraussetzt, dass $x$ effektiv nicht frei in $\varphi$ ist, aber nicht notwendigerweise nicht darin vorkommt.  Die Verwendung der impliziten Substitution\index{Substitution!implizite} ist zum Teil eine Frage des persönlichen Stils, obwohl sie Beweise etwas kürzer machen kann, als es bei expliziter Substitution der Fall wäre.

\item
Die Annahme


\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{A}\m{\in}\m{{\rm V}}
\endm
\vskip 1ex

sollte als "`angenommen, die Klasse $A$ ist eine Menge (d.h. sie \ existiert)"' verstanden werden. Dies ist eine praktische Konvention, die von Quine verwendet wurde.

\item
Die Bariablenbeschränkung und die Annahme

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$d\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{x}\m{\,y}
\endm
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{y}\m{\in}\m{A}\m{\rightarrow}\m{\forall}\m{x}\m{\,y}
\m{\in}\m{A}\m{)}
\endm
\vskip 1ex

sollte als "`angenommen, die Variable $x$ ist (effektiv) nicht frei in der Klasse $A$"' verstanden werden.

\end{itemize}

\section{Einige Beispiele für Theoreme}\label{sometheorems}

In diesem Abschnitt werden einige der wichtigsten Theoreme aufgelistet, die in der Datenbasis \texttt{set.mm} bewiesen werden, und sie veranschaulichen, was man mit Metamath alles machen kann.  Während alle diese Fakten bekannte Ergebnisse sind, bietet Metamath den Vorteil, dass man ihre Herleitung leicht zu den Axiomen zurückverfolgen kann.  Wir wollen hier nicht versuchen, die Details oder die Motivation zu erklären; dafür verweisen wir auf die Lehrbücher, die in den Beschreibungen erwähnt werden.  (Die Datei \texttt{set.mm} enthält bibliografische Angaben zu den Textverweisen.)  Ihre Beweise enthalten oft wichtige Konzepte, die Sie vielleicht mit dem Programm Metamath untersuchen möchten (siehe Abschnitt~\ref{exploring}).  Alle Symbole, die hier verwendet werden, sind in Abschnitt~\ref{hierarchy} definiert.  Der Kürze halber haben wir die \texttt{\$d}-Beschränkungen oder \texttt{\$f}-Hypothesen für diese Theoreme nicht aufgenommen; wenn Sie unsicher sind, konsultieren Sie die \texttt{set.mm}-Datenbasis.

Wir beginnen mit \texttt{syl} (dem Prinzip des Syllogismus). In \textit{Principia Mathe\-matica} nennen Whitehead und Russell dies "`das Prinzip des Syllogismus... weil... der Syllogismus in Barbara von ihnen abgeleitet ist"' \cite[Zitat nach Theorem *2.06 S.~101]{PM}. Einige Autoren nennen dieses Gesetz einen "`hypothetischen Syllogismus"'. Ab 2019 ist \texttt{syl} die am häufigsten referenzierte bewiesene Behauptung in der \texttt{set.mm}-Datenbasis.\footnote{ Der Metamath-Programmbefehl \texttt{show usage} zeigt die Anzahl der Verwendungen. Am 29.04.2019 (commit 71cbbbdb387e [im GitHub-Repository metamath/set.mm]) wurde \texttt{syl} 10.819 Mal direkt referenziert. Die am zweithäufigsten referenzierte bewiesene Assertion war \texttt{eqid}, die 7.738 Mal direkt referenziert wurde. }

\vskip 2ex
\noindent Theorem syl (das Prinzip des Syllogismus)\index{Syllogismus}%
\index{\texttt{syl}}\label{syl}.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ syl.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\varphi}\m{ \rightarrow }\m{\psi}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ syl.2\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\psi}\m{ \rightarrow }\m{\chi}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ syl\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{\varphi}\m{ \rightarrow }\m{\chi}\m{)}
\endm
\vskip 2ex

Das folgende Theorem ist nicht sehr tiefgründig, bietet uns aber eine häufig verwendete Notationshilfe.  Es erlaubt uns, den Ausdruck "`$A \in V$"' als eine kompakte Art zu sagen, dass die Klasse $A$ existiert, d.h. eine Menge ist.

\vskip 2ex
\noindent Es gibt zwei Möglichkeiten zu sagen, dass $A$ eine Menge ist: $A$ ist ein Element des Universums $V$ genau dann, wenn $A$ existiert (d.h. wenn es eine Menge gibt, die $A$ entspricht). Theorem 6.9 von Quine, S. 43.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ isset\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{{\rm V}}\m{\leftrightarrow}\m{\exists}\m{x}\m{\,x}\m{=}
\m{A}\m{)}
\endm
\vskip 1ex

Als nächstes beweisen wir die Axiome der Standard-ZF-Mengenlehre, die in unserem Axiomensystem fehlen.  Aus unserer Sicht sind sie Theoreme, da sie aus den anderen Axiomen abgeleitet werden können.

\vskip 2ex
\noindent Das Aussonderungsaxiom\index{Aussonderungsaxiom}, bewiesen aus den anderen Axiomen der ZF-Mengenlehre.  Vergleiche Übung 4 von Takeuti und Zaring, S.~22.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ inex1.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{A}\m{\in}\m{{\rm V}}
\endm
\setbox\startprefix=\hbox{\tt \ \ inex\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\cap}\m{B}\m{)}\m{\in}\m{{\rm V}}
\endm
\vskip 1ex

\noindent Das Leermengenaxiom\index{Leermengenaxiom}, bewiesen aus den anderen Axiomen der ZF-Mengenlehre. Korollar 5.16 von Takeuti und Zaring, S.~20.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ 0ex\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\varnothing}\m{\in}\m{{\rm V}}
\endm
\vskip 1ex

\noindent Das Paarmengenaxiom\index{Paarmengenaxiom}, bewiesen aus den anderen Axiomen der ZF-Mengenlehre.  Theorem 7.13 von Quine, S. 51.
\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ prex\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\{}\m{A}\m{,}\m{B}\m{\}}\m{\in}\m{{\rm V}}
\endm
\vskip 2ex

Als nächstes werden wir einige berühmte oder wichtige Theoreme auflisten, die in der Datenbasis \texttt{set.mm} bewiesen sind.  Keines von ihnen außer \texttt{omex} erfordert das Unendlichkeitsaxiom, wie Sie mit dem Metamath-Befehl \texttt{show trace{\char`\_}back} überprüfen können.

\vskip 2ex
\noindent Die Auflösung des Russell'schen Paradoxons\index{Russells Paradoxon}.  Es gibt keine Menge, die der Klasse aller Mengen, die nicht Mitglieder ihrer selbst sind, entspricht.  Proposition 4.14 von Takeuti und Zaring, S.~14.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ru\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\lnot}\m{\exists}\m{x}\m{\,x}\m{=}\m{\{}\m{y}\m{|}\m{\lnot}\m{y}
\m{\in}\m{y}\m{\}}
\endm
\vskip 1ex

\noindent Satz von Cantor\index{Satz von Cantor}.  Keine Menge kann auf ihre Potenzmenge abgebildet werden.  Vergleiche Theorem 6B(b) von Enderton, S.~132.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ canth.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{A}\m{\in}\m{{\rm V}}
\endm
\setbox\startprefix=\hbox{\tt \ \ canth\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\lnot}\m{F}\m{:}\m{A}\m{\raisebox{.5ex}{${\textstyle{\:}_{
\mbox{\footnotesize\rm {\ }}}}\atop{\textstyle{\longrightarrow}\atop{
\textstyle{}^{\mbox{\footnotesize\rm onto}}}}$}}\m{{\cal P}}\m{A}
\endm
\vskip 1ex

\noindent Das Burali-Forti-Paradoxon\index{Burali-Forti Paradoxon}.  Keine Menge enthält alle Ordinalzahlen. Enderton, S.~194.  (Burali-Forti war eine Person, nicht zwei.)

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ onprc\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\lnot}\m{\mbox{\rm On}}\m{\in}\m{{\rm V}}
\endm
\vskip 1ex

\noindent Peano-Postulate\index{Peano-Postulate} für die Arithmetik. Satz 7.30 von Takeuti und Zaring, S.~42--43.  Die zu beschreibenden Objekte sind die Elemente von $\omega$, d.h. die natürlichen Zahlen 0, 1, 2, \ldots.  Die Nachfolger\index{Nachfolger}-Operation suc bedeutet "`plus eins"'.  \texttt{peano1} besagt, dass 0 (die als leere Menge definiert ist) eine natürliche Zahl ist.  \texttt{peano2} besagt, dass wenn $A$ eine natürliche Zahl ist, $A+1$ auch eine natürliche Zahl ist.  \texttt{peano3} besagt, dass 0 nicht der Nachfolger einer natürlichen Zahl ist.  \texttt{peano4} besagt, dass zwei natürliche Zahlen genau dann gleich sind, wenn ihre Nachfolger gleich sind.  \texttt{peano5} ist im Wesentlichen dasselbe wie die vollständige Induktion.

\vskip 1ex
\setbox\startprefix=\hbox{\tt \ \ peano1\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\varnothing}\m{\in}\m{\omega}
\endm
\vskip 1.5ex

\setbox\startprefix=\hbox{\tt \ \ peano2\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{\omega}\m{\rightarrow}\m{{\rm suc}}\m{A}\m{\in}%
\m{\omega}\m{)}
\endm
\vskip 1.5ex

\setbox\startprefix=\hbox{\tt \ \ peano3\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{\omega}\m{\rightarrow}\m{\lnot}\m{{\rm suc}}%
\m{A}\m{=}\m{\varnothing}\m{)}
\endm
\vskip 1.5ex

\setbox\startprefix=\hbox{\tt \ \ peano4\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\omega}\m{\wedge}\m{B}\m{\in}\m{\omega}%
\m{)}\m{\rightarrow}\m{(}\m{{\rm suc}}\m{A}\m{=}\m{{\rm suc}}\m{B}\m{%
\leftrightarrow}\m{A}\m{=}\m{B}\m{)}\m{)}
\endm
\vskip 1.5ex

\setbox\startprefix=\hbox{\tt \ \ peano5\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{\varnothing}\m{\in}\m{A}\m{\wedge}\m{\forall}\m{x}\m{%
\in}\m{\omega}\m{(}\m{x}\m{\in}\m{A}\m{\rightarrow}\m{{\rm suc}}\m{x}\m{\in}%
\m{A}\m{)}\m{)}\m{\rightarrow}\m{\omega}\m{\subseteq}\m{A}\m{)}
\endm
\vskip 1.5ex

\noindent Finite Induktion (vollständige Induktion).\index{finite Induktion}\index{vollständige Induktion} Die erste Hypothese ist der Induktionsanfang und die zweite ist der Induktionsschritt.  Theorem Schema 22 von Suppes, S.~136.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ findes.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{[}\m{\varnothing}\m{/}\m{x}\m{]}\m{\varphi}
\endm
\setbox\startprefix=\hbox{\tt \ \ findes.2\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{\in}\m{\omega}\m{\rightarrow}\m{(}\m{\varphi}\m{%
\rightarrow}\m{[}\m{{\rm suc}}\m{x}\m{/}\m{x}\m{]}\m{\varphi}\m{)}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ findes\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{\in}\m{\omega}\m{\rightarrow}\m{\varphi}\m{)}
\endm
\vskip 1ex

\noindent Transfinite Induktion mit expliziter Substitution.  Die erste Hypothese ist der Induktionsanfang, die zweite ist der Induktionsschritt für Nachfolger und die dritte ist der Induktionsschritt für Grenzzahlen.  Theorem Schema 4 von Suppes, S. 197.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ tfindes.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{[}\m{\varnothing}\m{/}\m{x}\m{]}\m{\varphi}
\endm
\setbox\startprefix=\hbox{\tt \ \ tfindes.2\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{\in}\m{{\rm On}}\m{\rightarrow}\m{(}\m{\varphi}\m{%
\rightarrow}\m{[}\m{{\rm suc}}\m{x}\m{/}\m{x}\m{]}\m{\varphi}\m{)}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ tfindes.3\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{{\rm Lim}}\m{y}\m{\rightarrow}\m{(}\m{\forall}\m{x}\m{\in}%
\m{y}\m{\varphi}\m{\rightarrow}\m{[}\m{y}\m{/}\m{x}\m{]}\m{\varphi}\m{)}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ tfindes\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{x}\m{\in}\m{{\rm On}}\m{\rightarrow}\m{\varphi}\m{)}
\endm
\vskip 1ex

\noindent Prinzip der transfiniten Rekursion.\index{transfinite Rekursion} Theorem 7.41 von Takeuti und Zaring, S.~47.  Die transfinite Rekursion ist der grundlegende Satz für eine strenge Definition der Arithmetik von Ordinalzahlen, und hat auch viele andere wichtige Anwendungen. Die Annahmen \texttt{tfr.1} und \texttt{tfr.2} spezifizieren eine bestimmte (echte) Klasse $ F$.  Die komplizierte Definition von $ F$ ist an sich nicht wichtig; wichtig ist, dass es ein solches $ F$ mit den erforderlichen Eigenschaften gibt, und wir zeigen dies, indem wir $ F$ explizit angeben. \texttt{tfr1} besagt, dass $ F$ eine Funktion ist, deren Definitionsbereich die Menge der Ordnungszahlen ist.  \texttt{tfr2} besagt, dass jeder Wert von $ F$ vollständig durch seine vorherigen Werte und die Werte einer Hilfsfunktion, $G$, bestimmt ist.  \texttt{tfr3} besagt, dass $ F$ eindeutig ist, d.h. es ist die einzige Funktion, die \texttt{tfr1} und \texttt{tfr2} erfüllt.  Beachten Sie, dass $ f$ eine individuelle Variable wie $x$ und $y$ ist; es ist nur eine Gedächtnisstütze, um uns daran zu erinnern, dass $A$ eine Sammlung von Funktionen ist.

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ tfr.1\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{A}\m{=}\m{\{}\m{f}\m{|}\m{\exists}\m{x}\m{\in}\m{{\rm On}}\m{(}%
\m{f}\m{{\rm Fn}}\m{x}\m{\wedge}\m{\forall}\m{y}\m{\in}\m{x}\m{(}\m{f}\m{`}%
\m{y}\m{)}\m{=}\m{(}\m{G}\m{`}\m{(}\m{f}\m{\restriction}\m{y}\m{)}\m{)}\m{)}%
\m{\}}
\endm
\setbox\startprefix=\hbox{\tt \ \ tfr.2\ \$e\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{F}\m{=}\m{\bigcup}\m{A}
\endm
\setbox\startprefix=\hbox{\tt \ \ tfr1\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{F}\m{{\rm Fn}}\m{{\rm On}}
\endm
\setbox\startprefix=\hbox{\tt \ \ tfr2\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{z}\m{\in}\m{{\rm On}}\m{\rightarrow}\m{(}\m{F}\m{`}\m{z}%
\m{)}\m{=}\m{(}\m{G}\m{`}\m{(}\m{F}\m{\restriction}\m{z}\m{)}\m{)}\m{)}
\endm
\setbox\startprefix=\hbox{\tt \ \ tfr3\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{B}\m{{\rm Fn}}\m{{\rm On}}\m{\wedge}\m{\forall}\m{x}\m{%
\in}\m{{\rm On}}\m{(}\m{B}\m{`}\m{x}\m{)}\m{=}\m{(}\m{G}\m{`}\m{(}\m{B}\m{%
\restriction}\m{x}\m{)}\m{)}\m{)}\m{\rightarrow}\m{B}\m{=}\m{F}\m{)}
\endm
\vskip 1ex

\noindent Die Existenz von omega (die Klasse der natürlichen Zahlen).\index{natürliche Zahlen}\index{Omega ($\omega$)}\index{Unendlichkeitsaxiom}  Axiom 7 von Takeuti und Zaring, S.~43.  (Dies ist das einzige Theorem in diesem Abschnitt, das das Unendlichkeitsaxiom erfordert).

\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \
\ omex\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\omega}\m{\in}\m{{\rm V}}
\endm
%\vskip 2ex


\section{Axiome für reelle und komplexe Zahlen}\label{real}
\index{reelle Zahl}\index{komplexe Zahl}

In diesem Abschnitt werden die Axiome für reelle und komplexe Zahlen vorgestellt und kommentiert.  Analysis-Lehrbücher verwenden implizit oder explizit diese Axiome oder ihre Entsprechungen als Ausgangspunkt.  In der Datenbasis \texttt{set.mm} definieren wir reelle und komplexe Zahlen als (ziemlich komplizierte) spezifische Mengen und leiten diese Axiome als {\em Theoreme} aus den Axiomen der ZF-Mengenlehre ab, indem wir eine Methode der Dedekindschen Schnitte verwenden.  Wir lassen die Details dieser Konstruktion weg, die Sie bei Bedarf mit Hilfe der Datenbasis \texttt{set.mm} in Verbindung mit den darin referenzierten Lehrbüchern nachvollziehen können.

Sobald wir diese Theoreme bewiesen haben, formulieren wir die bewiesenen Theoreme als Axiome neu. Auf diese Weise können wir leicht erkennen, welche Axiome für einen bestimmten Beweis komplexer Zahlen benötigt werden, ohne durch die Komplexität ihrer Herleitung durch die Mengenlehre abgelenkt zu werden. Infolgedessen ist die Konstruktion eigentlich unwichtig, außer um zu zeigen, dass es Mengen gibt, die den Axiomen genügen, und dass die Axiome folglich konsistent sind, wenn die Mengenlehre konsistent ist.  Wenn man mit reellen Zahlen arbeitet, kann man sie tatsächlich als die Mengen betrachten, die sich aus der Konstruktion ergeben (für die Definitheit), oder man kann sie als nicht weiter spezifizierte Mengen betrachten, die zufälligerweise die Axiome erfüllen. Die Herleitung ist nicht einfach, aber die Tatsache, dass sie funktioniert, ist bemerkenswert und unterstützt die Idee, dass die ZFC-Mengenlehre alles ist, was wir brauchen, um eine Grundlage für die gesamte Mathematik zu schaffen.

\needspace{3\baselineskip}
\subsection{Die Axiome für reelle und komplexe Zahlen selbst}\label{realactual}

Für die Axiome werden uns 8 Klassen vorgegeben (oder vorausgesetzt):  $\mathbb{C}$ (die Menge der komplexen Zahlen), $\mathbb{R}$ (die Menge der reellen Zahlen, eine Teilmenge von $\mathbb{C}$), $0$ (Null), $1$ (Eins), $i$ (Quadratwurzel aus $-1$), $+$ (plus), $\cdot$ (mal) und $<_{\mathbb{R}}$ (kleiner als, nur für die reellen Zahlen). Subtraktion und Division sind definierte Begriffe und werden nicht in den Axiomen verwendet. Für ihre Definitionen siehe \texttt{set.mm}.

Man beachte, dass die Notation $(A+B)$ (und ähnlich $(A\cdot B)$) eine Klasse bezeichnet, die als {\em Operation},\index{Operation} bezeichnet wird und den Funktionswert der Klasse $+$ für das geordnete Paar $\langle A,B \rangle$ darstellt.  Eine Operation ist durch die Aussage \texttt{df-opr} auf Seite ~\pageref{dfopr} definiert. Die Notation $A <_{\mathbb{R}} B$ bezeichnet eine wff, die als {\em binäre Relation}\index{binäre Relation} bezeichnet wird und $\langle A,B \rangle \in \,<_{\mathbb{R}}$ bedeutet, wie durch \texttt{df-br} auf Seite ~\pageref{dfbr} definiert. 
 
Wir gehen davon aus, dass die 8 vorgegebenen Klassen die folgenden 22 Axiome erfüllen (in den unten aufgeführten Axiomen wird kurz $<$ statt $<_{\mathbb{R}}$ verwendet).

\vskip 2ex

\noindent 1. Die reellen Zahlen sind eine Teilmenge der komplexen Zahlen.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-resscn\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\mathbb{R}}\m{\subseteq}\m{\mathbb{C}}
\endm
%\vskip 1ex

\noindent 2. Eins ist eine komplexe Zahl.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-1cn\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{1}\m{\in}\m{\mathbb{C}}
\endm
%\vskip 1ex

\noindent 3. Die imaginäre Einheit $i$ ist eine komplexe Zahl.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-icn\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{i}\m{\in}\m{\mathbb{C}}
\endm
%\vskip 1ex

\noindent 4. Komplexe Zahlen sind bzgl. der Addition abgeschlossen.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-addcl\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{C}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{C}}%
\m{)}\m{\rightarrow}\m{(}\m{A}\m{+}\m{B}\m{)}\m{\in}\m{\mathbb{C}}\m{)}
\endm
%\vskip 1ex

\noindent 5. Reelle Zahlen sind bzgl. der Addition abgeschlossen.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-addrcl\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{R}}%
\m{)}\m{\rightarrow}\m{(}\m{A}\m{+}\m{B}\m{)}\m{\in}\m{\mathbb{R}}\m{)}
\endm
%\vskip 1ex

\noindent 6. Komplexe Zahlen sind bzgl. der Multiplikation abgeschlossen.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-mulcl\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{C}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{C}}%
\m{)}\m{\rightarrow}\m{(}\m{A}\m{\cdot}\m{B}\m{)}\m{\in}\m{\mathbb{C}}\m{)}
\endm
%\vskip 1ex

\noindent 7. Reelle Zahlen sind bzgl. der Multiplikation abgeschlossen.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-mulrcl\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{R}}%
\m{)}\m{\rightarrow}\m{(}\m{A}\m{\cdot}\m{B}\m{)}\m{\in}\m{\mathbb{R}}\m{)}
\endm
%\vskip 1ex

\noindent 8. Die Multiplikation von komplexen Zahlen ist kommutativ.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-mulcom\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{C}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{C}}%
\m{)}\m{\rightarrow}\m{(}\m{A}\m{\cdot}\m{B}\m{)}\m{=}\m{(}\m{B}\m{\cdot}\m{A}%
\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 9. Die Addition von komplexen Zahlen ist assoziativ.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-addass\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{C}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{C}}%
\m{\wedge}\m{C}\m{\in}\m{\mathbb{C}}\m{)}\m{\rightarrow}\m{(}\m{(}\m{A}\m{+}%
\m{B}\m{)}\m{+}\m{C}\m{)}\m{=}\m{(}\m{A}\m{+}\m{(}\m{B}\m{+}\m{C}\m{)}\m{)}%
\m{)}
\endm
%\vskip 1ex

\noindent 10. Die Multiplikation von komplexen Zahlen ist assoziativ.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-mulass\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{C}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{C}}%
\m{\wedge}\m{C}\m{\in}\m{\mathbb{C}}\m{)}\m{\rightarrow}\m{(}\m{(}\m{A}\m{\cdot}%
\m{B}\m{)}\m{\cdot}\m{C}\m{)}\m{=}\m{(}\m{A}\m{\cdot}\m{(}\m{B}\m{\cdot}\m{C}%
\m{)}\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 11. Die Multiplikation der komplexen Zahlen ist distributiv bzgl. der Addition.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-distr\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{C}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{C}}%
\m{\wedge}\m{C}\m{\in}\m{\mathbb{C}}\m{)}\m{\rightarrow}\m{(}\m{A}\m{\cdot}\m{(}%
\m{B}\m{+}\m{C}\m{)}\m{)}\m{=}\m{(}\m{(}\m{A}\m{\cdot}\m{B}\m{)}\m{+}\m{(}%
\m{A}\m{\cdot}\m{C}\m{)}\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 12. Das Quadrat von $i$ ist gleich $-1$ (ausgedrückt als $i$-Quadrat plus Eins ist Null).

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-i2m1\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{i}\m{\cdot}\m{i}\m{)}\m{+}\m{1}\m{)}\m{=}\m{0}
\endm
%\vskip 1ex

\noindent 13. Eins und Null sind verschieden.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-1ne0\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{1}\m{\ne}\m{0}
\endm
%\vskip 1ex

\noindent 14. Eines ist ein neutrales Element für die reelle Multiplikation.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-1rid\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\rightarrow}\m{(}\m{A}\m{\cdot}\m{1}%
\m{)}\m{=}\m{A}\m{)}
\endm
%\vskip 1ex

\noindent 15. Zu jeder reellen Zahl gibt es eine entsprechende negative Zahl (additives Inverses).

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-rnegex\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\rightarrow}\m{\exists}\m{x}\m{\in}%
\m{\mathbb{R}}\m{(}\m{A}\m{+}\m{x}\m{)}\m{=}\m{0}\m{)}
\endm
%\vskip 1ex

\noindent 16. Jede reelle Zahl ungleich Null hat einen Kehrwert.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-rrecex\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\rightarrow}\m{(}\m{A}\m{\ne}\m{0}%
\m{\rightarrow}\m{\exists}\m{x}\m{\in}\m{\mathbb{R}}\m{(}\m{A}\m{\cdot}%
\m{x}\m{)}\m{=}\m{1}\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 17. Eine komplexe Zahl kann durch zwei reelle Zahlen ausgedrückt werden.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-cnre\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{A}\m{\in}\m{\mathbb{C}}\m{\rightarrow}\m{\exists}\m{x}\m{\in}%
\m{\mathbb{R}}\m{\exists}\m{y}\m{\in}\m{\mathbb{R}}\m{A}\m{=}\m{(}\m{x}\m{+}\m{(}%
\m{y}\m{\cdot}\m{i}\m{)}\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 18. Die Ordnung der reellen Zahlen erfüllt die strenge Trichotomie.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-pre-lttri\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{R}}%
\m{)}\m{\rightarrow}\m{(}\m{A}\m{<}\m{B}\m{\leftrightarrow}\m{\lnot}\m{(}\m{A}%
\m{=}\m{B}\m{\vee}\m{B}\m{<}\m{A}\m{)}\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 19. Die Ordnung der reellen Zahlen ist transitiv.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-pre-lttrn\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{R}}%
\m{\wedge}\m{C}\m{\in}\m{\mathbb{R}}\m{)}\m{\rightarrow}\m{(}\m{(}\m{A}\m{<}%
\m{B}\m{\wedge}\m{B}\m{<}\m{C}\m{)}\m{\rightarrow}\m{A}\m{<}\m{C}\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 20. Die Ordnung der reellen Zahlen ist invariant bzgl. der Addition.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-pre-ltadd\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{R}}%
\m{\wedge}\m{C}\m{\in}\m{\mathbb{R}}\m{)}\m{\rightarrow}\m{(}\m{A}\m{<}\m{B}\m{%
\rightarrow}\m{(}\m{C}\m{+}\m{A}\m{)}\m{<}\m{(}\m{C}\m{+}\m{B}\m{)}\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 21. Das Produkt zweier positiver reeller Zahlen ist positiv.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-pre-mulgt0\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\in}\m{\mathbb{R}}\m{\wedge}\m{B}\m{\in}\m{\mathbb{R}}%
\m{)}\m{\rightarrow}\m{(}\m{(}\m{0}\m{<}\m{A}\m{\wedge}\m{0}%
\m{<}\m{B}\m{)}\m{\rightarrow}\m{0}\m{<}\m{(}\m{A}\m{\cdot}\m{B}\m{)}%
\m{)}\m{)}
\endm
%\vskip 1ex

\noindent 22. Eine nicht leere, nach oben begrenzte Menge von reellen Zahlen hat ein Supremum.

%\vskip 0.5ex
\setbox\startprefix=\hbox{\tt \ \ ax-pre-sup\ \$p\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{(}\m{(}\m{A}\m{\subseteq}\m{\mathbb{R}}\m{\wedge}\m{A}\m{\ne}\m{%
\varnothing}\m{\wedge}\m{\exists}\m{x}\m{\in}\m{\mathbb{R}}\m{\forall}\m{y}\m{%
\in}\m{A}\m{\,y}\m{<}\m{x}\m{)}\m{\rightarrow}\m{\exists}\m{x}\m{\in}\m{%
\mathbb{R}}\m{(}\m{\forall}\m{y}\m{\in}\m{A}\m{\lnot}\m{x}\m{<}\m{y}\m{\wedge}\m{%
\forall}\m{y}\m{\in}\m{\mathbb{R}}\m{(}\m{y}\m{<}\m{x}\m{\rightarrow}\m{\exists}%
\m{z}\m{\in}\m{A}\m{\,y}\m{<}\m{z}\m{)}\m{)}\m{)}
\endm

% NOTE: The \m{...} expressions above could be represented as
% $ \vdash ( ( A \subseteq \mathbb{R} \wedge A \ne \varnothing \wedge \exists x \in \mathbb{R} \forall y \in A \,y < x ) \rightarrow \exists x \in \mathbb{R} ( \forall y \in A \lnot x < y \wedge \forall y \in \mathbb{R} ( y < x \rightarrow \exists z \in A \,y < z ) ) ) $

\vskip 2ex

Dies ist der vollständige Satz der Axiome für reelle und komplexe Zahlen.  Sehen Sie sich an, wie Subtraktion, Division und Dezimalzahlen in \texttt{set.mm} definiert sind, und schauen Sie sich zum Spaß den Beweis von $2+ 2 = 4$ (Theorem \texttt{2p2e4} in \texttt{set.mm}) an, wie in Abschnitt \ref{2p2e4} besprochen.

In \texttt{set.mm} definieren wir die positiven ganzen Zahlen $\mathbb{N}$, die nichtnegativen ganzen Zahlen $\mathbb{N}_0$, die ganzen Zahlen $\mathbb{Z}$ und die rationalen Zahlen $\mathbb{Q}$ als Teilmengen von $\mathbb{R}$.  Dies führt zu der schönen Teilmengenkette $\mathbb{N} \subseteq \mathbb{N}_0 \subseteq \mathbb{Z} \subseteq \mathbb{Q} \subseteq \mathbb{R} \subseteq \mathbb{C}$, was uns einen einheitlichen Rahmen für die Arithmetik gibt, in dem zum Beispiel eine Eigenschaft wie die Kommutativität der Addition komplexer Zahlen automatisch für ganze Zahlen gilt.  Die natürlichen Zahlen $\mathbb{N}$\footnote{Anm. der Übersetzer: sowohl im Deutschen als auch im Englischen ist nicht eindeutig festgelegt, ob mit dem Begriff "`natürliche Zahlen"' die positiven ganzen Zahlen $\mathbb{N}$ oder die nichtnegativen ganzen Zahlen $\mathbb{N}_0$ gemeint werden.} unterscheiden sich von der zuvor definierten Menge $\omega$, aber beide erfüllen die Peanoschen Postulate.

\subsection{Axiome für komplexe Zahlen in Texten zur \\Analysis}

Die meisten Texte zur Analysis konstruieren komplexe Zahlen als geordnete Paare von reellen Zahlen, was zu konstruktionsabhängigen Eigenschaften führt, die diese Axiome erfüllen, aber nicht in ihrer reinen Form angegeben werden.  (Dies geschieht auch in \texttt{set.mm}, aber unsere Axiome abstrahieren von dieser Konstruktion.) In anderen Texten heißt es einfach, dass $\mathbb{R}$ ein "`komplettes geordnetes Teilfeld von $\mathbb{C}$ ist"', was zu redundanten Axiomen führt, wenn man diese Phrase vollständig ausformuliert.  Tatsächlich habe ich noch keinen Text gesehen, der die Axiome in der obigen expliziten Form enthält. Keines dieser Axiome ist individuell einzigartig, aber diese sorgfältig ausgearbeitete Sammlung von Axiomen ist das Ergebnis jahrelanger Arbeit der Metamath-Gemeinschaft.

\subsection{Beseitigung unnötiger Axiome für komplexe \\Zahlen}

Metamath hatte ursprünglich mehr Axiome für reelle und komplexe Zahlen, aber im Laufe der Zeit haben wir (die Metamath-Gemeinschaft) Wege gefunden, unnötige Axiome zu eliminieren (indem wir sie anhand anderer Axiome bewiesen haben) oder sie abzuschwächen (indem wir schwächere Behauptungen aufgestellt haben, ohne die Beweisbarkeit der auf sie aufbauenden Theoreme zu reduzieren). Es folgen einige Aussagen, die früher Axiome für komplexe Zahlen waren, die aber inzwischen (mit Metamath) formal als überflüssig nachgewiesen wurden:

\begin{itemize}
\item
  $\mathbb{C} \in V$.
  Früher wurde dies als "`Axiom der komplexen Zahlen"' aufgeführt.   Es handelt sich jedoch eigentlich nicht um ein Axiom der komplexen Zahlen, und sein Beweis verwendet in jedem Fall Axiome der Mengenlehre.   Von Mario Carneiro\index{Carneiro, Mario} am 17-Nov-2014 als redundant bewiesen (siehe \texttt{axcnex}).
\item
  $((A \in \mathbb{C} \land B \in \mathbb{C}$) $\rightarrow$
  $(A + B) = (B + A))$.
  Von Eric Schmidt\index{Schmidt, Eric} am 19-Jun-2012 als redundant bewiesen und von Scott Fenton\index{Fenton, Scott} am 3-Jan-2013 formalisiert (siehe \texttt{addcom}).
\item
  $(A \in \mathbb{C} \rightarrow (A + 0) = A)$.
  Von Eric Schmidt am 19. Juni 2012 als überflüssig bewiesen und von Scott Fenton am 3. Januar 2013 formalisiert (siehe \texttt{addid1}).
\item
  $(A \in \mathbb{C} \rightarrow \exists x \in \mathbb{C} (A + x) = 0)$.
  Von Eric Schmidt für überflüssig bewiesen und am 21. Mai 2007 formalisiert (siehe \texttt{cnegex}).
\item
  $((A \in \mathbb{C} \land A \ne 0) \rightarrow \exists x \in \mathbb{C} (A \cdot x) = 1)$.
  Von Eric Schmidt für überflüssig bewiesen und am 22. Mai 2007 formalisiert (siehe \texttt{recex}).
\item
  $0 \in \mathbb{R}$.
  Von Eric Schmidt am 19-Feb-2005 als überflüssig bewiesen und am 21-Mai-2007 formalisiert (siehe \texttt{0re}).
\end{itemize}

Wir könnten 0 als axiomatisches Objekt eliminieren, indem wir es als $( ( i \cdot i ) + 1 )$ definieren und es in den Axiomen durch diesen Ausdruck ersetzen. In diesem Fall wird das Axiom ax-i2m1 überflüssig. Die übrigen Axiome würden jedoch länger und weniger intuitiv werden.

Eric Schmidts Arbeit, in der er dieses Axiomensystem\cite{Schmidt} analysiert, enthält einen Beweis dafür, dass die verbleibenden Axiome, mit der eventuellen Ausnahme von ax-mulcom, unabhängig von den anderen sind. Es ist derzeit eine offene Frage, ob ax-mulcom unabhängig von den anderen Axiomen ist.

\section{Zwei plus zwei ist gleich vier}\label{2p2e4}

Es folgt ein Beweis, dass $2 + 2 = 4$, wie im Theorem \texttt{2p2e4} in der Datenbasis \texttt{set.mm} bewiesen wird. Damit wird anschaulich demonstriert, wie ein Metamath-Beweis aussehen kann. Dieser Beweis hat vielleicht mehr Schritte, als Sie gewohnt sind, aber jeder Schritt ist streng bewiesen, bis hin zu den Axiomen der Logik und Mengenlehre. Diese Darstellung wurde ursprünglich vom Metamath-Programm als {\sc HTML}-Datei erzeugt (siehe \url{https://us.metamath.org/mpeuni/2p2e4.html}).

In der Tabelle, die den Beweis zeigt, ist "`Schritt"' die sequentielle Nummer des entsprechenden Schritts, während der zugehörige "`Ausdruck"' ein Ausdruck ist, den wir bewiesen haben. Unter "`Ref"' (Referenz) ist der Name eines Theorems oder Axioms, das diesen Ausdruck rechtfertigt, und "`Hyp"' bezieht sich auf vorangegangene Schritte (falls vorhanden), die das Theorem oder Axiom benötigt, damit wir es verwenden können.  Ausdrücke werden weiter eingerückt als die von ihnen abhängigen Ausdrücke, um ihre Abhängigkeiten zu verdeutlichen.

\begin{table}[!htbp]
\caption{Zwei plus zwei ist gleich vier}
\begin{tabular}{lllll}
\textbf{Step} & \textbf{Hyp} & \textbf{Ref} & \textbf{Expression} & \\
1  &       & df-2    & $ \hspace*{10mm} \vdash 2 = 1 + 1$  & \\
2  & 1     & oveq2i  & $ \hspace*{5mm} \vdash (2 + 2) = (2 + (1 + 1))$ & \\
3  &       & df-4    & $ \hspace*{10mm} \vdash 4 = (3 + 1)$ & \\
4  &       & df-3    & $ \hspace*{15mm} \vdash 3 = (2 + 1)$ & \\
5  & 4     & oveq1i  & $ \hspace*{10mm} \vdash (3 + 1) = ((2 + 1) + 1)$ & \\
6  &       & 2cn     & $ \hspace*{15mm} \vdash 2 \in \mathbb{C}$ & \\
7  &       & ax-1cn  & $ \hspace*{15mm} \vdash 1 \in \mathbb{C}$ & \\
8  & 6,7,7 & addassi & $ \hspace*{10mm} \vdash ((2 + 1) + 1) = (2 + (1 + 1))$ & \\
9  & 3,5,8 & 3eqtri  & $ \hspace*{5mm} \vdash 4 = (2 + (1 + 1))$ & \\
10 & 2,9   & eqtr4i  & $ \vdash (2 + 2) = 4$ & \\
\end{tabular}
\end{table}

Schritt 1 besagt, dass wir behaupten können, dass $2 = 1 + 1$ ist, weil es durch \texttt{df-2} gerechtfertigt ist. Was ist \texttt{df-2}? Es ist einfach die Definition von $2$, die in unserem System als gleich $1 + 1$ definiert ist.  Dies zeigt, wie wir Definitionen in Beweisen verwenden können.

Sehen Sie sich Schritt 2 des Beweises an. In der Spalte "`Ref"' sehen wir, dass er sich auf ein zuvor bewiesenes Theorem, \texttt{oveq2i}, bezieht. Es stellt sich heraus, dass das Theorem \texttt{oveq2i} eine Annahme erfordert, und in der Spalte Hyp von Schritt 2 geben wir an, dass Schritt 1 diese Annahme erfüllt (entspricht). Wenn wir uns \texttt{oveq2i} ansehen, stellen wir fest, dass es beweist, dass wir bei einer Annahme $A = B$ beweisen können, dass $( C F A ) = ( C F B )$. Wenn wir \texttt{oveq2i} benutzen und das Ergebnis von Schritt 1 als Annahme verwenden, bedeutet das, dass $A = 2$ und $B = ( 1 + 1 )$ innerhalb dieser Verwendung von \texttt{oveq2i} gesetzt wird. Für $C$ und $F$ können wir beliebige Werte einsetzen (vorbehaltlich der syntaktischen Einschränkungen), also können wir $C = 2$ und $F = +$ wählen, was zu unserem gewünschten Ergebnis $ (2 + 2) = (2 + (1 + 1))$ führt.

Schritt 2 ist ein Beispiel für eine Substitution. Letztendlich verwendet jeder Schritt in jedem Beweis nur diese eine Substitutionsregel. Alle Regeln der Logik und alle Axiome sind so ausgedrückt, dass sie mittels dieser einen Substitutionsregel verwendet werden können. Wenn Sie also einmal die Substitution beherrschen, können Sie jeden Metamath-Beweis beherrschen, ohne Ausnahmen.

Jeder Schritt ist klar und kann sofort überprüft werden. In der {\sc HTML}-Anzeige können Sie sogar auf jeden Verweis klicken, um zu sehen, warum er gerechtfertigt ist, so dass Sie leicht erkennen können, warum der Beweis funktioniert.

\section{Deduktion}\label{deduction}

Streng genommen ist eine Deduktion (auch Inferenz genannt) eine Art von Aussage, bei der einige Annahmen wahr sein müssen, damit ihre Schlussfolgerung wahr ist. Ein Theorem hingegen hat keine Hypothesen. Informell werden beide Arten von Aussagen oft als Theoreme bezeichnet, aber in diesem Abschnitt werden wir uns an die strengen Definitionen halten.

Es kommt manchmal vor, dass wir bereits eine Deduktion der Form $\varphi \Rightarrow \psi$\index{$\Rightarrow$} bewiesen haben (bei gegebener Annahme $\varphi$ können wir $\psi$ beweisen) und wir wollen dann ein Theorem der Form $\varphi \rightarrow \psi$ beweisen.

Die Umwandlung einer Deduktion (die eine Annahme verwendet) in ein Theorem (das dies nicht tut) ist nicht so einfach, wie man vielleicht denkt. Die Deduktion besagt: "`Wenn wir $\varphi$ beweisen können, dann können wir auch $\psi$ beweisen"', was in gewisser Weise schwächer ist als die Aussage "`$\varphi$ impliziert $\psi$"'. Es gibt kein Axiom der Logik, das uns erlaubt, das Theorem direkt aus der Deduktion zu erhalten.\footnote{Die Umwandlung einer Deduktion in ein Theorem gilt nicht einmal allgemein für die Quantenlogik, die eine schwache Untermenge der klassischen Aussagenlogik ist. Es wurde gezeigt, dass das Hinzufügen des Standard-Deduktionstheorems (siehe unten) zur Quantenlogik diese zur klassischen Aussagenlogik macht!}

Dies steht im Gegensatz zum umgekehrten Weg. Wenn wir das Theorem ($\varphi \rightarrow \psi$) haben, ist es einfach, die Deduktion ($\varphi \Rightarrow \psi$) mit Hilfe des Modus ponens\index{Modus ponens} (\texttt{ax-mp}; siehe Abschnitt \ref{axmp}) wiederherzustellen.

In den folgenden Unterabschnitten besprechen wir zunächst das Standard-Deduktionstheorem (die traditionelle, aber umständliche Art, Deduktionen in Theoreme umzuwandeln) und das Theorem der schwachen Deduktion (eine eingeschränkte Version des Standard-Deduktionstheorems, die einfacher zu handhaben ist und früher in der Mengenlehre-Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} weit verbreitet war. In Abschnitt \ref{deductionstyle} besprechen wir den Deduktionsstil, den neueren Ansatz, den wir jetzt in den meisten Fällen empfehlen. Der Deduktionsstil verwendet die "`Deduktionsform"', eine Form, bei der jeder Annahme (außer Definitionen) und der Schlussfolgerung eine universelle Prämisse vorangestellt wird ("`$\varphi \rightarrow$"'). Der Deduktionsstil ist in \texttt{set.mm} weit verbreitet, so dass es nützlich ist, ihn zu verstehen und zu begreifen, warum er weit verbreitet ist. In Abschnitt \ref{naturaldeduction} wird kurz unser Ansatz zur Verwendung der natürlichen Deduktion in \texttt{set.mm} erörtert, da dieser Ansatz eng mit dem Deduktionsstil verbunden ist. Wir schließen mit einer Zusammenfassung der Stärken unseres Ansatzes, die wir für überzeugend halten.

\subsection{Das Standard-Deduktionstheorem}\label{standarddeductiontheorem}

Die Informationen, die in der Deduktion oder ihrem Beweis enthalten sind, können genutzt werden, um uns beim Beweis des zugehörigen Theorems zu helfen. In traditionellen Logikbüchern gibt es ein Metatheorem, das sogenannte Deduktionstheorem\index{Deduktionstheorem}\index{Standard-Deduktionstheorem}, das von Herbrand und Tarski um 1930 unabhängig voneinander entdeckt wurde. Das Deduktionstheorem, das wir oft als Standard-Deduktionstheorem bezeichnen, liefert einen Algorithmus für die Konstruktion eines Beweises eines Theorems aus dem Beweis seiner entsprechenden Deduktion. Siehe z. B. \cite[S.~56]{Margaris}\index{Margaris, Angelo}. Um einen Beweis für ein Theorem zu konstruieren, betrachtet der Algorithmus jeden Schritt im Beweis der ursprünglichen Deduktion und ersetzt den Schritt durch mehrere Schritte, wobei die Annahme eliminiert und zu einer Prämisse wird.

In der gewöhnlichen Mathematik führt niemand den Algorithmus tatsäch\-lich aus, weil er (in seiner einfachsten Form) eine exponentielle Explosion der Anzahl der Beweisschritte mit sich bringt, je mehr Annahmen eliminiert werden. Stattdessen beruft man sich auf das Standard-Deduktionstheorem, um zu behaupten, dass der Algorithmus prinzipiell durchführbar ist, ohne ihn tatsächlich auszuführen. Außerdem ist der Algorithmus nicht so einfach, wie er auf den ersten Blick erscheinen mag, wenn man ihn rigoros anwendet. Es gibt eine subtile Einschränkung des Standard-Deduktionstheorems, die bei der Arbeit mit der Prädikatenlogik berücksichtigt werden muss, nämlich das Axiom der Verallgemeinerung (weitere Einzelheiten finden Sie in der Literatur).

Eines der Ziele von Metamath ist es, mit möglichst wenigen zugrundeliegenden Konzepten deutlich zu machen, wie Mathematik direkt aus den Axiomen abgeleitet werden kann, und nicht indirekt nach irgendwelchen versteckten Regeln, die in einem Programm vergraben sind oder nur von Logikern verstanden werden. Wenn wir das Standard-Deduktionstheorem zur Sprache und zum Beweisverifizierer hinzufügen würden, würde das beides stark verkomplizieren und Metamaths Ziel der Einfachheit weitgehend zunichte machen. Im Prinzip könnten wir direkt Beweise erstellen, indem wir die vom Algorithmus des Standard-Deduktionstheorems generierten Beweisschritte erweitern.  Aber das ist in der Praxis kaum machbar, weil die Anzahl der Beweisschritte schnell riesig, ja sogar astronomisch groß wird. Da der Algorithmus des Standard-Deduktionstheorems durch den Beweis gesteuert wird, müssten wir diesen Beweis noch einmal von vorne durchgehen - ausgehend von den Axiomen -, um das entsprechende Theorem zu erhalten. In Bezug auf die Länge des Beweises würde es keine Einsparungen geben, wenn man das Theorem direkt beweist, anstatt zuerst die Deduktionsform zu beweisen.

\subsection{Das Theorem der schwachen Deduktion}\label{weakdeductiontheorem}

Wir haben eine effizientere Methode entwickelt, um ein Theorem aus einer Deduktion zu beweisen, die in vielen (aber nicht allen) Fällen anstelle des Standard-Deduktionstheorems verwendet werden kann. Wir nennen diese effizientere Methode das Theorem der schwachen Deduktion\index{Theorem der schwachen Deduktion}.\footnote{Es gibt auch ein davon unabhängiges "`Theorem der schwachen Deduktion"' im Bereich der Relevanzlogik, so dass wir, um Verwirrung zu vermeiden, unser Theorem "`Theorem der schwachen Deduktion für die klassische Logik"' nennen könnten.} Im Gegensatz zum Standard-Deduktionstheorem erzeugt das Theorem der schwachen Deduktion das Theorem direkt aus einer speziellen Substitutionsinstanz der Deduktion, wobei eine kleine, feste Anzahl von Schritten verwendet wird, die ungefähr proportional zur Länge des endgültigen Theorems ist.

Wenn Sie auf einen Beweis stoßen, der auf das Theorem der schwachen Deduktion \texttt{dedth} (oder eine seiner Varianten \texttt{dedthxx}) verweist, können Sie dem Beweis folgendermaßen folgen, ohne sich in die Details zu vertiefen: Klicken Sie einfach auf das Theorem, auf das in dem Schritt direkt vor dem Verweis auf \texttt{dedth} verwiesen wird, und ignorieren Sie alles andere. Das Theorem \texttt{dedth} verwandelt einfach eine Annahme in eine Prämisse (d.h. die Annahme, gefolgt von $\rightarrow$, wird vor die Behauptung gestellt, und die Annahme selbst wird eliminiert), wenn bestimmte Bedingungen erfüllt sind.

Das Theorem der schwachen Deduktion eliminiert eine Annahme $\varphi$ und macht sie zu einer Prämisse. Dies geschieht durch den Beweis eines Ausdrucks $ \varphi \rightarrow \psi $ bei zwei Annahmen:
(1)
$ ( A = {\rm if} ( \varphi , A , B ) \rightarrow ( \varphi \leftrightarrow \chi ) ) $
und
(2) $\chi$.
Man beachte, dass es für $\varphi$ einen Beweis geben muss, wenn die Klassenvariable $A$ durch eine bestimmte Klasse $B$ ersetzt wird. Die Annahme $\chi$ sollte der Inferenz zugewiesen werden. Die Details des Beweises des Theorems der schwachen Deduktion können Sie im Theorem \texttt{dedth} sehen.

Das Theorem der schwachen Deduktion ist wahrscheinlich einfacher zu verstehen, wenn man Beweise studiert, die es verwenden. Sehen wir uns zum Beispiel den Beweis von \texttt{renegcl} an, der beweist, dass $ \vdash ( A \in \mathbb{R} \rightarrow - A \in \mathbb{R} )$:

\needspace{4\baselineskip}
\begin{longtabu} {l l l X}
\textbf{Step} & \textbf{Hyp} & \textbf{Ref} & \textbf{Expression} \\
  1 &  & negeq &
  $\vdash$ $($ $A$ $=$ ${\rm if}$ $($ $A$ $\in$ $\mathbb{R}$ $,$ $A$ $,$ $1$ $)$ $\rightarrow$
  $\textrm{-}$ $A$ $=$ $\textrm{-}$ ${\rm if}$ $($ $A$ $\in$ $\mathbb{R}$
  $,$ $A$ $,$ $1$ $)$ $)$ \\
 2 & 1 & eleq1d &
    $\vdash$ $($ $A$ $=$ ${\rm if}$ $($ $A$ $\in$ $\mathbb{R}$ $,$ $A$ $,$ $1$ $)$ $\rightarrow$ $($
    $\textrm{-}$ $A$ $\in$ $\mathbb{R}$ $\leftrightarrow$
    $\textrm{-}$ ${\rm if}$ $($ $A$ $\in$ $\mathbb{R}$ $,$ $A$ $,$ $1$ $)$ $\in$
    $\mathbb{R}$ $)$ $)$ \\
 3 &  & 1re & $\vdash 1 \in \mathbb{R}$ \\
 4 & 3 & elimel &
   $\vdash {\rm if} ( A \in \mathbb{R} , A , 1 ) \in \mathbb{R}$ \\
 5 & 4 & renegcli &
   $\vdash \textrm{-} {\rm if} ( A \in \mathbb{R} , A , 1 ) \in \mathbb{R}$ \\
 6 & 2,5 & dedth &
   $\vdash ( A \in \mathbb{R} \rightarrow \textrm{-} A \in \mathbb{R}$ ) \\
\end{longtabu}

Die etwas seltsam aussehenden Schritte in \texttt{renegcl} vor Schritt 5 sind technischer Natur, die dafür sorgen, dass dieser Zauber funktioniert, und sie können für einen schnellen Überblick über den Beweis ignoriert werden. Um den "`wichtigen"' Teil des Beweises von \texttt{renegcl} weiter zu verfolgen, können Sie sich den Verweis auf \texttt{renegcli} in Schritt 5 ansehen.

Nachdem dies geklärt ist, wollen wir uns kurz ansehen, wie für \texttt{renegcl} das Theorem der schwachen Deduktion (\texttt{dedth}) verwendet wird, um seine Aufgabe zu erfüllen, falls Sie etwas Ähnliches tun oder es besser verstehen wollen. Lassen Sie uns im Beweis von \texttt{renegcl} rückwärts arbeiten. Schritt 6 wendet \texttt{dedth} an, um unser Zielergebnis $ \vdash ( A \in \mathbb{R} \rightarrow\, - A \in \mathbb{R} )$ zu erzeugen. Dies erfordert zum einen die (substituierte) Deduktion \texttt{renegcli} in Schritt 5. Von sich aus beweist \texttt{renegcli} die Deduktion $ \vdash A \in \mathbb{R} \Rightarrow\, \vdash - A \in \mathbb{R}$; dies ist die Deduktionsform, die wir in Theoremform zu bringen versuchen, und somit hat \texttt{renegcli} eine eigene Annahme, die erfüllt werden muss. Um die Annahme des Aufrufs von \texttt{renegcli} in Schritt 5 zu erfüllen, wird sie schließlich auf das bereits bewiesene Theorem $1 \in \mathbb{R}$ in Schritt 3 reduziert. Schritt 4 verbindet die Schritte 3 und 5; Schritt 4 ruft \texttt{elimel} auf, einen Spezialfall von \texttt{elimhyp}, der eine Ist-Element-Von-Hypothese für das Theorem der schwachen Deduktion eliminiert\footnote{Anm. der Übersetzer: Das Theorem \texttt{elimel} besagt $ B \in C \Rightarrow\, {\rm if} ( A \in C , A , B ) \in C $, also dass entweder der "`then"'-Teil des if-Statements in $ C $ enthalten ist, was wegen der "`if"'-Bedingungung der Fall ist, oder der "`else"'-Teil, was aus der Annahme $ B \in C $ folgt.}.

Andererseits muss die Äquivalenz der Schlussfolgerung von \texttt{renegcl} $( - A \in \mathbb{R} )$ und der substituierten Schlussfolgerung von \texttt{renegcli} bewiesen werden, was in Schritt 2 und 1 geschieht.

Das Theorem der schwachen Deduktion hat seine Grenzen. Insbesondere müssen wir in der Lage sein, einen Spezialfall der Annahme der Deduktion als eigenständiges Theorem zu beweisen. Wir haben zum Beispiel $1 \in \mathbb{R}$ in Schritt 3 von \texttt{renegcl} verwendet.

Früher haben wir das Theorem der schwachen Deduktion ausgiebig in \texttt{set.mm} verwendet. Inzwischen empfehlen wir jedoch in den meisten Fällen die Anwendung des "`Deduktionsstils"', da der Deduktionsstil oft eine einfachere und klarere Vorgehensweise ermöglicht. Daher werden wir nun den Deduktionsstil beschreiben.

\subsection{Deduktionsstil}\label{deductionstyle}

Wir ziehen es jetzt vor, Behauptungen in "`Deduktionsform"' zu schreiben, um die Verwendung des Standard-Deduktionstheorems oder des Theorems der schwachen Deduktion in Beweisen zu vermeiden. Wir nennen diesen Ansatz "`Deduktionsstil"'.\index{Deduktionsstil}

Es wird einfacher sein, dies zu erklären, wenn man zunächst einige Begriffe definiert:

\begin{itemize}
\item \textbf{geschlossene Form}\index{geschlossene Form}\index{Formen!geschlossen}:
Behauptungen (Theoreme) ohne Hypothesen. Normalerweise hat ihre Bezeichnung kein spezielles Suffix. Ein Beispiel ist \texttt{unss}, das besagt:
$\vdash ( ( A \subseteq C \wedge B \subseteq C ) \leftrightarrow ( A \cup B )
\subseteq C )\label{eq:unss}$
\item \textbf{Deduktionsform}\index{Deduktionsform}\index{Formen!Deduktion}:
Behauptungen mit einer oder mehreren Hypothesen, bei der die Schlussfolgerung eine Implikation mit einer wff-Variablen als Prämisse (normalerweise $\varphi$) ist und jede Hypothese (\$e Aussage) entweder (1) eine Implikation mit derselben Prämisse wie die der Schlussfolgerung oder (2) eine Definition ist. Eine Definition kann für eine Klassenvariable (dies ist eine Klassenvariable, gefolgt von "`="') oder eine wff-Variable (dies ist eine wff-Variable, gefolgt von $\leftrightarrow$) erfolgen; Klassenvariablendefinitionen sind häufiger. In der Praxis wird ein Beweis in Deduktionsform auch viele Schritte enthalten, die Implikationen sind, bei denen die Prämisse entweder diese wff-Variable ist (normalerweise $\varphi$) oder eine Konjunktion (...$\land$...), die diese wff-Variable ($\varphi$) enthält. Wenn eine Behauptung in Deduktionsform vorliegt, und auch andere Formen möglich sind, dann fügen wir ihrer Bezeichnung den Suffix "`d"' hinzu. Ein Beispiel dafür ist \texttt{unssd}, das besagt\footnote{Der Kürze halber zeigen wir hier (und an anderen Stellen) ein $\&$\index{$\&$} zwischen Hypothesen\index{Hypothese} und ein $\Rightarrow$\index{$\Rightarrow$}\index{Schlussfolgerung} zwischen den Hypothesen und der Schlussfolgerung. Diese Notation ist technisch gesehen nicht Teil der Metamath-Sprache, sondern eine bequeme Abkürzung, um sowohl die Hypothesen als auch die Schlussfolgerung darzustellen.}:
$\vdash ( \varphi \rightarrow A \subseteq C )\quad\&\quad \vdash ( \varphi
    \rightarrow B \subseteq C )\quad\Rightarrow\quad \vdash ( \varphi
    \rightarrow ( A \cup B ) \subseteq C )\label{eq:unssd}$
\item \textbf{Inferenzform}\index{Inferenzform}\index{Formen!Inferenz}:
Behauptungen mit einer oder mehreren Annahmen, die nicht in Deduktionsform vorliegen (z.B. gibt es keine gemeinsame Prämisse). Liegt eine Behauptung in der Inferenzform vor und sind auch andere Formen möglich, so fügen wir der Bezeichnung ein "`i"' hinzu. Ein Beispiel ist \texttt{unssi}, das besagt:
$\vdash A \subseteq C\quad\&\quad \vdash B \subseteq C\quad\Rightarrow\quad
    \vdash ( A \cup B ) \subseteq C\label{eq:unssi}$
\end{itemize}

Wenn wir den Deduktionsstil verwenden, drücken wir eine Behauptung in der Deduktionsform aus. In dieser Form wird jeder Annahme (mit Ausnahme von Definitionen) und der Schlussfolgerung eine universelle Prämisse ("`$\varphi \rightarrow$"') vorangestellt. Die Prämisse (z.B. $\varphi$) ahmt den Kontext nach, der im Deduktionstheorem behandelt wird, so dass es nicht notwendig ist, das Deduktionstheorem direkt zu verwenden.

Sobald Sie eine Behauptung in Deduktionsform haben, können Sie sie leicht in die Inferenzform oder geschlossene Form umwandeln:

\begin{itemize}
\item Um eine Behauptung Ti in Inferenzform zu beweisen, wenn die Behauptung Td in Deduktionsform vorliegt, gibt es einen einfachen mechanischen Prozess, den man anwenden kann. Zuerst nimmt man jede Annahme Ti und fügt ein \texttt{T.} $\rightarrow$-Präfix ("`wahr impliziert"') unter Verwendung von \texttt{a1i} ein. Sie können dann die vorhandene Behauptung Td verwenden, um die resultierende Schlussfolgerung mit einem \texttt{T.} $\rightarrow$-Präfix beweisen. Schließlich können Sie dieses Präfix mit \texttt{mptru} entfernen, was zu der Schlussfolgerung führt, die Sie beweisen wollten\footnote{Anm. der Übersetzer: Siehe zum Beispiel \texttt{hadbi123i} oder \texttt{abeq2i}.}. 
\item Um eine Behauptung T in geschlossener Form zu beweisen, wenn die Behauptung Td in Deduktionsform vorliegt, gibt es ein weiteres einfaches mechanisches Verfahren, das Sie anwenden können. Wählen Sie zunächst einen Ausdruck, der die Konjunktion (...$\land$...) aller Folgerungen jeder Annahme von Td ist. Beweisen Sie dann, dass dieser Ausdruck jede der einzelnen Annahmen von Td impliziert, indem Sie die Konjunktionen eliminieren (es gibt eine Reihe von bewiesenen Behauptungen, um dies zu tun, einschließlich
\texttt{simpl},
\texttt{simpr},
\texttt{3simpa},
\texttt{3simpb},
\texttt{3simpc},
\texttt{simp1},
\texttt{simp2},
und
\texttt{simp3}).
Wenn der Ausdruck verschachtelte Konjunktionen hat, können die inneren Konjunktionen durch Verkettung der obigen Theoreme mit \texttt{syl} herausgebrochen werden (siehe Abschnitt \ref{syl}).\footnote{Es gibt tatsächlich viele Theoreme (mit simp* gekennzeichnet, wie z.B. \texttt{simp333}), die innere Konjunktionen in einem Schritt auflösen. Aber anstatt sie alle zu lernen, können Sie einfach die gerade beschriebene Verkettung für den Beweis verwenden, und dann den Metamath-Programmbefehl \texttt{minimize{\char`\_}with}\index{\texttt{minimize{\char`\_}with}-Befehl} die richtigen speziellen simp*-Theoreme herausfinden lassen, die die Verkettungen aufzulösen.} Als letzten Schritt können Sie dann die bereits bewiesene Behauptung Td (die in Deduktionsform vorliegt) anwenden und die Behauptung T in geschlossener Form beweisen.
\end{itemize}

Wir können auch jede Behauptung T in geschlossener Form leicht in die zugehörige Behauptung Ti in Inferenzform umwandeln, indem wir den Modus ponens\index{Modus ponens} anwenden (siehe Abschnitt \ref{axmp}) \footnote{Anm. der Übersetzer: Eine Behauptung T in geschlossener Form kann auch leicht in die zugehörige Behauptung Td in Deduktionsform umgewandelt werden, indem die Prämisse von T durch $\varphi$ ersetzt wird und für jedes Konjunkt aus der ursprünglichen Prämisse eine Hypothese bestehend aus dem Konjunkt mit vorangestelltem  $\varphi \rightarrow $ ergänzt wird.}.

Die gemeinsame Prämisse in der Deduktionsform kann auch verwendet werden, um den Kontext darzustellen, der für die Unterstützung von Systemen des natürlichen Schließens notwendig ist. Daher werden wir nun die natürliche Deduktion diskutieren.

\subsection{Natürliche Deduktion}\label{naturaldeduction}

Systeme des natürlichen Schließens oder der natürlichen Deduktion\index{natürliche Deduktion} (ND) als solche wurden ursprünglich 1934 von zwei unabhängig voneinander arbeitenden Logikern eingeführt: Ja\'skowski und Gentzen. ND-Systeme sollen auf formal ordentliche Weise traditionelle Methoden des mathematischen Schließens (wie den bedingten Beweis, den indirekten Beweis und den Beweis durch Fallunterscheidung) rekonstruieren. Als Rekonstruktionen wurden sie natürlich durch frühere Arbeiten beeinflusst, und viele spezifische ND-Systeme und Notationen wurden seit ihrem Ursprung entwickelt.

Es gibt viele ND-Varianten, aber Indrzejczak\cite[S.~31-32]{Indrzejczak}\index{Indrzejczak, Andrzej} schlägt vor, dass jedes System des natürlichen Schließens zumindest diese drei Kriterien erfüllen muss:

\begin{itemize}
\item "`Es gibt Möglichkeiten, um Annahmen in einen Beweis einzufügen und auch um sie zu eliminieren. Gewöhnlich bedarf es einiger buchhalterischer Hilfsmittel, um den Gültigkeitsbereich einer Annahme anzugeben und zu zeigen, dass ein Teil eines Beweises, der von einer eliminierten Annahme abhängt, entlastet wird.
\item Es gibt keine (oder zumindest eine sehr begrenzte Menge von) Axiomen, weil ihre Rolle von der Menge der primitiven Regeln für die Einführung und Eliminierung logischer Konstanten übernommen wird, was bedeutet, dass elementare Schlussfolgerungen anstelle von Formeln als primitiv angesehen werden.
\item (Ein echtes) ND-System erlaubt eine große Freiheit bei der Konstruktion von Beweisen und die Möglichkeit, verschiedene Strategien der Beweissuche anzuwenden, wie den bedingten Beweis, den Beweis durch Fallunterscheidungen, den Beweis durch reductio ad absurdum usw."'
\end{itemize}

Der Metamath Proof Explorer (MPE), wie er in \texttt{set.mm} definiert ist, ist im Grunde ein System im Hilbert-Stil. Das heißt, MPE basiert auf einer größeren Anzahl von Axiomen (im Vergleich zu Systemen der natürlichen Deduktion), einer sehr kleinen Menge von Schlussregeln (Modus ponens), und der Kontext wird nicht durch die Inferenzregeln in der Mitte eines Beweises verändert. Abgesehen davon können MPE-Beweise mit dem Ansatz der natürlichen Deduktion (ND), wie er ursprünglich von Ja\'skowski und Gentzen entwickelt wurde, erstellt werden.

Der gebräuchlichste und empfohlene Ansatz für die Anwendung von ND in MPE ist die Verwendung der Deduktionsform \index{Deduktionsform}%
\index{Formen!Deduktion} und die Anwendung der in MPE bewiesenen Behauptungen, die den ND-Regeln entsprechen. Zum Beispiel ist MPE's \texttt{jca} äquivalent zur ND-Regel $\land$-I (and-insertion). Wir haben eine Liste von Äquivalenzen erstellt, die Sie einsehen können. Dieser Ansatz für die Anwendung eines ND-Ansatzes innerhalb von MPE stützt sich im Wesentlichen auf Metamaths wff-Metavariablen und wird in der Präsentation "`Natural Deductions in the Metamath Proof Language"' von Mario Carneiro \cite{CarneiroND}\index{Carneiro, Mario} näher beschrieben.

In diesem Stil sind viele Schritte eine Implikation, deren Prämissen den Kontext ($\Gamma$) der meisten ND-Systeme nachahmt. Um eine Annahme hinzuzufügen, fügen Sie sie einfach der Implikationsprämisse hinzu (typischerweise unter Verwendung von \texttt{simpr}) und verwenden diese neue Prämisse für alle späteren Behauptungen im selben Bereich. Wenn Sie eine Behauptung in einem ND-Hypothesenbereich verwenden wollen, der außerhalb des aktuellen ND-Hypothesenbereichs liegt, ändern Sie die Behauptung so, dass die ND-Hypothesenannahme zu ihrer Prämisse hinzugefügt wird (typischerweise mit \texttt{adantr}). Die meisten Beweisschritte werden mit Hilfe von Regeln bewiesen, die Hypothesen und Ergebnisse der Form $\varphi \rightarrow$ ... haben.

Ein Beispiel mag dies deutlicher machen. Schauen wir uns Theorem 5.5 von \cite[S.~18]{Clemente}\index{Clemente Laboreo, Daniel} zusammen mit einer zeilenweisen Übersetzung unter Verwendung der üblichen Übersetzung der natürlichen Deduktion (ND) in die Metamath Proof Explorer (MPE) Notation an (dies ist Beweis \texttt{ex-natded5.5}). Das ursprüngliche Ziel des Beweises war der Beweis von $ \lnot \psi$ unter zwei Annahmen, $( \psi \rightarrow \chi )$ und $ \lnot \chi$. Wir werden diese Aussagen in die MPE-Deduktionsform übersetzen, indem wir ihnen allen das Präfix $\varphi \rightarrow$ voranstellen. In MPE lautet das Ziel also $( \varphi \rightarrow \lnot \psi )$, und die beiden Hypothesen lauten $( \varphi \rightarrow ( \psi \rightarrow \chi )$ und $( \varphi \rightarrow \lnot \chi )$.

Die folgende Tabelle zeigt den Beweis im Stil der natürlichen Deduktion von Fitch und seine MPE-Entsprechung. Die Spalte \textit{\#} zeigt die ursprüngliche Nummerierung, \textit{MPE\#} zeigt die Nummer im äquivalenten MPE-Beweis (den wir später zeigen werden), \textit{ND-Ausdruck} zeigt die ursprüngliche Beweisbehauptung in ND-Notation, und \textit{MPE-Übersetzung} zeigt ihre Übersetzung in MPE, wie in diesem Abschnitt diskutiert. Die letzten Spalten zeigen die Begründung in ND bzw. MPE.

\needspace{4\baselineskip}
{\setlength{\extrarowsep}{4pt} % Keep rows from being too close together
\begin{longtabu}   { @{} c c X X X X }
\textbf{\#} & \textbf{MPE\#} & \textbf{ND-Ausdruck} &
\textbf{MPE-Über\-setzung} & \textbf{ND-Begrün\-dung} &
\textbf{MPE-Begrün\-dung} \\
\endhead

1 & 2;3 &
$( \psi \rightarrow \chi )$ &
$( \varphi \rightarrow ( \psi \rightarrow \chi ) )$ &
gegeben &
\$e; \texttt{adantr} um die ND-Hypothese einzufügen \\

2 & 5 &
$ \lnot \chi$ &
$( \varphi \rightarrow \lnot \chi )$ &
gegeben &
\$e; \texttt{adantr} um die ND-Hypothese einzufügen \\

3 & 1 &
... $\vert$ $\psi$ &
$( \varphi \rightarrow \psi )$ &
Annahme der ND-Hypothese &
\texttt{simpr} \\

4 & 4 &
... $\chi$ &
$( ( \varphi \land \psi ) \rightarrow \chi )$ &
$\rightarrow$\,E 1,3 &
\texttt{mpd} 1,3 \\

5 & 6 &
... $\lnot \chi$ &
$( ( \varphi \land \psi ) \rightarrow \lnot \chi )$ &
IT 2 &
\texttt{adantr} 5 \\

6 & 7 &
$\lnot \psi$ &
$( \varphi \rightarrow \lnot \psi )$ &
$\land$\,I 3,4,5 &
\texttt{pm2.65da} 4,6 \\

\end{longtabu}
}


Im Original wurden lateinische Buchstaben verwendet; wir haben sie durch griechische Buchstaben ersetzt, um den Metamath-Namenskonventionen zu folgen und um die Metamath-Übersetzung leichter nachvollziehen zu können. Die zeilenweise Metamath-Übersetzung dieses Ansatzes der natürlichen Deduktion stellt jeder Zeile eine Prämisse mit $\varphi$ voran und verwendet die Metamath-Äquivalente der natürlichen Deduktionsregeln. Um eine Annahme hinzuzufügen, wird die Prämisse so modifiziert, dass sie sie enthält (typischerweise durch Verwendung von \texttt{adantr}; \texttt{simpr} ist nützlich, wenn man eine direkte Abhängigkeit von der neuen Annahme haben möchte, wie hier gezeigt).

In Metamath können wir die beiden gegebenen Aussagen als folgende Hypothesen darstellen:

\needspace{2\baselineskip}
\begin{itemize}
\item ex-natded5.5.1 $\vdash ( \varphi \rightarrow ( \psi \rightarrow \chi ) )$
\item ex-natded5.5.2 $\vdash ( \varphi \rightarrow \lnot \chi )$
\end{itemize}

\needspace{4\baselineskip}
Hier ist der Beweis in Metamath als zeilenweise Übersetzung:

\begin{longtabu}   { l l l X }
\textbf{Step} & \textbf{Hyp} & \textbf{Ref} & \textbf{Ex\-pres\-sion} \\
\endhead
1 & & simpr & $\vdash ( ( \varphi \land \psi ) \rightarrow \psi )$ \\
2 & & ex-natded5.5.1 &
  $\vdash ( \varphi \rightarrow ( \psi \rightarrow \chi ) )$ \\
3 & 2 & adantr &
 $\vdash ( ( \varphi \land \psi ) \rightarrow ( \psi \rightarrow \chi ) )$ \\
4 & 1, 3 & mpd &
 $\vdash ( ( \varphi \land \psi ) \rightarrow \chi ) $ \\
5 & & ex-natded5.5.2 &
 $\vdash ( \varphi \rightarrow \lnot \chi )$ \\
6 & 5 & adantr &
 $\vdash ( ( \varphi \land \psi ) \rightarrow \lnot \chi )$ \\
7 & 4, 6 & pm2.65da &
 $\vdash ( \varphi \rightarrow \lnot \psi )$ \\
\end{longtabu}

Die direkte Verwendung spezifischer Regeln für die natürliche Deduktion kann zu sehr langen Beweisen führen, und zwar aus genau demselben Grund, aus dem die direkte Verwendung von Axiomen in Beweisen im Hilbert-Stil zu sehr langen Beweisen führen kann. Wenn das Ziel kurze und klare Beweise sind, dann ist es besser, bereits bewiesene Behauptungen in Deduktionsform wiederzuverwenden, als jedes Mal von vorne anzufangen und nur grundlegende natürliche Deduktionsregeln zu verwenden.

\subsection{Die Stärken unseres Ansatzes}

Soweit wir wissen, gibt es in der Literatur weder das Theorem der schwachen Deduktion noch die natürliche Deduktionsmethode von Mario Carneiro\index{Carneiro, Mario}. Um eine Annahme in eine Prämisse umzuwandeln, benötigt das in der Literatur übliche "`Deduktionstheorem"'\index{Deduktionstheorem}\index{Standard-Deduktionstheorem} eine Metalogik außerhalb der vom Axiomensystem bereitgestellten Begriffe. Stattdessen bevorzugen wir im Allgemeinen die Methode der natürlichen Deduktion von Mario Carneiro, verwenden dann das schwache Deduktionstheorem in Fällen, in denen es schwierig ist, es anzuwenden, und verwenden erst dann das vollständige Standard-Deduktionstheorem als letzten Ausweg.

Das Theorem der schwachen Deduktion\index{Theorem der schwachen Deduktion} erfordert keine zusätzliche Metalogik, sondern wandelt eine Schlussfolgerung direkt in ein Theorem in geschlossener Form um, mit einem strengen Beweis, der nur das Axiomensystem verwendet. Im Gegensatz zum Standard-Deduktionstheorem gibt es keine implizite externe Rechtfertigung, auf die wir vertrauen müssen, um es anzuwenden.

Die Methode der natürlichen Deduktion\index{natürliche Deduktion} von Mario Carneiro erfordert ebenfalls keine neuen metalogischen Begriffe. Sie umgeht die Metalogik des Deduktionstheorems, indem sie den Annahmen und Schlussfolgerungen jeder möglichen Schlussfolgerung von Anfang an eine universelle Prämisse ("`$\varphi \rightarrow$"') voranstellt.

Wir finden es beeindruckend und befriedigend, dass wir so viel im praktischen Sinne tun können, ohne unser Hilbert-artiges Axiomensystem zu verlassen. Natürlich enthält unsere Axiomatisierung, die in Form von Schemata vorliegt, eine eigene Metalogik, die wir ausnutzen. Aber diese Metalogik ist relativ einfach, und für unsere Alternativen zum Deduktionstheorem verwenden wir in erster Linie nur die direkte Substitution von Ausdrücken für Metavariablen.

\begin{sloppy}
\section{Erforschung der Mengenlehre-Datenbasis}\label{exploring}
\end{sloppy}
% NOTE: All examples performed in this section are
% recorded wtih "set width 61" % on set.mm as of 2019-05-28
% commit c1e7849557661260f77cfdf0f97ac4354fbb4f4d.

An dieser Stelle möchten Sie vielleicht die Datei \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} genauer studieren.  Achten Sie insbesondere auf die Annahmen, die zur Definition von wffs\index{wohlgeformte Formel (wff)} (die oben nicht enthalten sind) benötigt werden, auf die Variablentypen (\texttt{\$f}\index{\texttt{\$f}-Anweisung}-Anweisungen) und auf die eingeführten Definitionen.  Beginnen Sie mit einigen einfachen Theoremen der Aussagenlogik und stellen Sie sicher, dass Sie jeden Schritt eines Beweises im Detail verstehen.  Sobald Sie die ersten paar Beweise hinter sich gebracht haben und mit der Metamath-Sprache vertraut sind, wird jeder Teil der \texttt{set.mm}-Datenbasis Schritt für Schritt genauso einfach zu verstehen sein wie jeder andere Teil - Sie müssen keinen "`Quantensprung"' bezüglich der mathematischen Raffinesse durchmachen, um einem tiefgehenden Beweis in der Mengenlehre folgen zu können.

Als Nächstes möchten Sie vielleicht untersuchen, wie Konzepte wie die natürlichen Zahlen definiert und beschrieben werden.  Dies geschieht wahrscheinlich am besten in Verbindung mit Standard-Lehrbüchern der Mengenlehre, die Ihnen ein besseres Verständnis vermitteln können.  Die Datenbasis \texttt{set.mm} bietet Referenzen, mit denen Sie beginnen können.  Von dort aus beginnt Ihr Weg zu einem sehr tiefgehenden, rigorosen Verständnis der abstrakten Mathematik.

Das Programm Metamath\index{Metamath} kann Ihnen dabei helfen, eine Metamath-Datenbasis durchzugehen, sei es um herauszufinden, wie ein bestimmter Schritt in einem Beweis erfolgt, oder nur aus allgemeiner Neugier.  Wir werden einige Beispiele für die Befehle durchgehen und dabei die Datenbasis der Mengenlehre \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} verwenden, die mit der Metamath-Software geliefert wird.  Diese sollten Ihnen den Einstieg erleichtern.  Siehe Kapitel~\ref{commands} für eine detailliertere Beschreibung der Befehle.  Beachten Sie, dass wir die vollständige Schreibweise aller Befehle angegeben haben, um Mehrdeutigkeiten bei zukünftigen Befehlen zu vermeiden.  In der praktischen Arbeit brauchen Sie nur die Zeichen eingeben, die erforderlich sind, um jeden Befehl keyword\index{Befehlsschlüsselwort} eindeutig zu identifizieren, oft nur ein oder zwei Zeichen pro Schlüsselwort, und Sie brauchen sie nicht in Großbuchstaben zu schreiben.

Führen Sie zunächst das Programm Metamath wie oben beschrieben aus.  Sie sollten die Eingabeaufforderung \verb/MM>/ sehen.  Lesen Sie die Datei \texttt{set.mm} ein:\index{\texttt{read}-Befehl}

\begin{verbatim}
MM> read set.mm
Reading source file "set.mm"... 34554442 bytes
34554442 bytes were read into the source buffer.
The source has 155711 statements; 2254 are $a and 32250 are $p.
No errors were found.  However, proofs were not checked.
Type VERIFY PROOF * if you want to check them.
\end{verbatim}

Wie bei den meisten Beispielen in diesem Buch wird das, was Sie sehen werden, leicht von den dargestellten Inhalten abweichen, da wir unsere Datenbasen (einschließlich \texttt{set.mm}) ständig verbessern.

Prüfen wir die Integrität der Datenbasis.  Dieser Vorgang kann ein oder zwei Minuten dauern, wenn Ihr Computer langsam ist.

\begin{verbatim}
MM> verify proof *
0 10%  20%  30%  40%  50%  60%  70%  80%  90% 100%
..................................................
All proofs in the database were verified in 2.84 s.
\end{verbatim}

Es wurden keine Fehler gemeldet, so dass jeder Beweis korrekt ist.

Sie müssen die Namen (Bezeichnungen) der Theoreme kennen, bevor Sie sich diese ansehen können. Oft ist das Durchsuchen der Datenbasisdatei(en) mit einem Texteditor die beste Vorgehensweise.  In \texttt{set.mm} gibt es viele detaillierte Kommentare, vor allem am Anfang, die Ihnen helfen können. Der Befehl \texttt{search} im Programm Metamath ist ebenfalls sehr nützlich.  Die Option \texttt{comments} listet die Aussagen auf, deren zugehöriger Kommentar (der unmittelbar vor der Aussage steht) eine von Ihnen angegebene Zeichenfolge enthält.  Wenn Sie zum Beispiel Endertons {\em Elements of Set Theory} studieren \cite{Enderton}\index{Enderton, Herbert B.}, möchten Sie vielleicht die Verweise darauf in der Datenbasis finden.  Bei der zu suchenden Zeichenfolge \texttt{enderton} wird nicht zwischen Groß- und Kleinschreibung unterschieden.  (Auf diese Weise werden nicht alle Theoreme in der Datenbasis angezeigt, die in Endertons Buch enthalten sind, da es für ein bestimmtes Theorem, das in mehreren Lehrbüchern vorkommen kann, in der Regel nur ein einziges Zitat gibt.)\index{\texttt{search}-Befehl}

\begin{verbatim}
MM> search * "enderton" / comments
12067 unineq $p "... Exercise 20 of [Enderton] p. 32 and ..."
12459 undif2 $p "...Corollary 6K of [Enderton] p. 144. (C..."
12953 df-tp $a "...s. Definition of [Enderton] p. 19. (Co..."
13689 unissb $p ".... Exercise 5 of [Enderton] p. 26 and ..."
\end{verbatim}
\begin{center}
(etc.)
\end{center}

Oder Sie möchten nachsehen, welche Theoreme etwas mit Konjunktionen (logisches {\sc und}) zu tun haben.  Die Anführungszeichen um den Suchstring sind optional, wenn es keine Mehrdeutigkeit gibt.\index{\texttt{search}-Befehl}

\begin{verbatim}
MM> search * conjunction / comments
120 a1d $p "...be replaced with a conjunction ( ~ df-an )..."
662 df-bi $a "...viated form after conjunction is introdu..."
1319 wa $a "...ff definition to include conjunction ('and')."
1321 df-an $a "Define conjunction (logical 'and'). Defini..."
1420 imnan $p "...tion in terms of conjunction. (Contribu..."
\end{verbatim}
\begin{center}
(etc.)
\end{center}

Nun werden wir uns mit einigen Details befassen.  Schauen wir uns das erste Axiom der Aussagenlogik an (wir könnten \texttt{sh st} als Abkürzung für \texttt{show statement} verwenden).\index{\texttt{show statement}-Befehl}

\begin{verbatim}
MM> show statement ax-1/full
Statement 49 is located on line 11182 of the file "set.mm".
Its statement number for HTML pages is 6.
"Axiom _Simp_.  Axiom A1 of [Margaris] p. 49.  One of the 3
axioms of propositional calculus.  The 3 axioms are also
given as Definition 2.1 of [Hamilton] p. 28.
..."
49 ax-1 $a |- ( ph -> ( ps -> ph ) ) $.
Its mandatory hypotheses in RPN order are:
  wph $f wff ph $.
  wps $f wff ps $.
The statement and its hypotheses require the variables:
  ph ps
The variables it contains are:  ph ps
\end{verbatim}

Vergleichen Sie dies mit \texttt{ax-1} auf Seite~\pageref{ax1}.  Sie sehen, dass zum Beispiel das Symbol \texttt{ph} die {\sc ascii}-Notation für $\varphi$ ist.  Um die mathematischen Symbole für einen beliebigen Ausdruck zu sehen, können Sie ihn in \LaTeX\ umsetzen (geben Sie \texttt{help tex} für Anweisungen dazu ein)\index{latex@{\LaTeX}} oder, was einfacher ist, verwenden Sie einfach einen Texteditor, um sich die Kommentare anzusehen, in denen die Symbole zuerst in \texttt{set.mm} eingeführt werden.  Die Annahmen \texttt{wph} und \texttt{wps}, die von \texttt{ax-1} verlangt werden, bedeuten, dass die Variablen \texttt{ph} und \texttt{ps} wffs sein müssen.

Als nächstes wählen wir ein einfaches Theorem der Aussagenlogik, das Gesetz der Selbstimplikation\footnote{Anm. der Übersetzer: Im Originaltext wird dieses Gesetz, wie in {\em Principia Mathematica} \cite{PM}, "`principle of identity"' genannt, was aber oft mit dem "`law of identity"' verwechselt wird, das im Deutschen "`Identitätsprinzip"' genannt wird.}, das direkt aus den Axiomen bewiesen wird.  Wir werden uns die Aussage und dann ihren Beweis ansehen.\index{\texttt{show statement}-Befehl}

\begin{verbatim}
MM> show statement id1/full
Statement 116 is located on line 11371 of the file "set.mm".
Its statement number for HTML pages is 22.
"Principle of identity.  Theorem *2.08 of [WhiteheadRussell]
p. 101.  This version is proved directly from the axioms for
demonstration purposes.
..."
116 id1 $p |- ( ph -> ph ) $= ... $.
Its mandatory hypotheses in RPN order are:
  wph $f wff ph $.
Its optional hypotheses are:  wps wch wth wta wet
      wze wsi wrh wmu wla wka
The statement and its hypotheses require the variables:  ph
These additional variables are allowed in its proof:
      ps ch th ta et ze si rh mu la ka
The variables it contains are:  ph
\end{verbatim}

Die optionalen Variablen \index{optionale Variable} \texttt{ps}, \texttt{ch}, etc.\ stehen bei Bedarf zur Verwendung in einem Beweis dieser Aussage zur Verfügung, und wenn diese verwendet würden, würden die entsprechenden optionalen Hypothesen \texttt{wps}, \texttt{wch}, etc. ebenfalls verwendet werden. (Siehe Abschnitt~\ref{dollaref} für die Bedeutung von "`optionaler Hypothese"'. \index{optionale Hypothese}) Der Grund dafür, dass diese in der Anzeige der Aussage auftauchen, ist, dass die Aussage \texttt{id1} zufällig in ihrem Gültigkeitsbereich liegt (siehe Abschnitt~\ref{scoping} für die Definition von "`Gültigkeitsbereich"'\index{Gültigkeitsbereich}), aber tatsächlich werden wir in der Aussagenlogik niemals optionale Hypothesen oder Variablen verwenden.  Dies wird wichtig, nachdem Quantoren eingeführt wurden, wo "`Dummy"'-Variablen oft in der Mitte eines Beweises benötigt werden.

Schauen wir uns den Beweis der Aussage \texttt{id1} an.  Wir verwenden den Befehl \texttt{show proof}, der standardmäßig die "`unwesentlichen"' Schritte unterdrückt, die die wffs konstruieren.\index{\texttt{show proof}-Befehl} Wir zeigen den Beweis im "`lemmon"'-Format an (ein Format ohne Einrückungen mit expliziten Verweisen auf vorherige Schrittnummern) und nummerieren die angezeigten Schritte neu:

\begin{verbatim}
MM> show proof id1 /lemmon/renumber
1 ax-1           $a |- ( ph -> ( ph -> ph ) )
2 ax-1           $a |- ( ph -> ( ( ph -> ph ) -> ph ) )
3 ax-2           $a |- ( ( ph -> ( ( ph -> ph ) -> ph ) ) ->
                     ( ( ph -> ( ph -> ph ) ) -> ( ph -> ph )
                                                          ) )
4 2,3 ax-mp      $a |- ( ( ph -> ( ph -> ph ) ) -> ( ph -> ph
                                                          ) )
5 1,4 ax-mp      $a |- ( ph -> ph )
\end{verbatim}

Wenn Sie Abschnitt~\ref{trialrun} gelesen haben, werden Sie wissen, wie Sie diesen Beweis interpretieren können.  Schritt~2 zum Beispiel ist eine Anwendung des Axioms \texttt{ax-1}.  Dieser Beweis ist identisch mit demjenigen in Hamiltons {\em Logic for Mathematicians} \cite[S.~32]{Hamilton}\index{Hamilton, Alan G.}.

Vielleicht möchten Sie sich ansehen, welche Substitutionen in \texttt{ax-1} vorgenommen werden, um zu Schritt~2 zu gelangen. Der entsprechende Befehl muss die "`echte"' Schrittnummer kennen, also zeigen wir den Beweis noch einmal ohne die Option \texttt{renumber} an.\index{\texttt{show proof}-Befehl}

\begin{verbatim}
MM> show proof id1 /lemmon
 9 ax-1          $a |- ( ph -> ( ph -> ph ) )
20 ax-1          $a |- ( ph -> ( ( ph -> ph ) -> ph ) )
24 ax-2          $a |- ( ( ph -> ( ( ph -> ph ) -> ph ) ) ->
                     ( ( ph -> ( ph -> ph ) ) -> ( ph -> ph )
                                                          ) )
25 20,24 ax-mp   $a |- ( ( ph -> ( ph -> ph ) ) -> ( ph -> ph
                                                          ) )
26 9,25 ax-mp    $a |- ( ph -> ph )
\end{verbatim}

Die "`echte"' Nummer des zu betrachtenden Schrittes ist 20.  Schauen wir uns die Details an.

\begin{verbatim}
MM> show proof id1 /detailed_step 20
Proof step 20:  min=ax-1 $a |- ( ph -> ( ( ph -> ph ) -> ph )
  )
This step assigns source "ax-1" ($a) to target "min" ($e).
The source assertion requires the hypotheses "wph" ($f, step
18) and "wps" ($f, step 19).  The parent assertion of the
target hypothesis is "ax-mp" ($a, step 25).
The source assertion before substitution was:
    ax-1 $a |- ( ph -> ( ps -> ph ) )
The following substitutions were made to the source
assertion:
    Variable  Substituted with
     ph        ph
     ps        ( ph -> ph )
The target hypothesis before substitution was:
    min $e |- ph
The following substitution was made to the target hypothesis:
    Variable  Substituted with
     ph        ( ph -> ( ( ph -> ph ) -> ph ) )
\end{verbatim}

Dies zeigt die Substitutionen\index{Substitution!Variable}\index{Variablensubstitution}, die an den Variablen in \texttt{ax-1} vorgenommen wurden.  Es wird auf die Schritte 18 und 19 verwiesen, die in unserer Beweisdarstellung nicht gezeigt werden.  Um diese Schritte zu sehen, können Sie den Beweis mit der Option \texttt{all} anzeigen. 

Sehen wir uns nun einen etwas fortgeschritteneren Beweis der Aussagenlogik an.  Beachten Sie, dass \verb+/\+ das Symbol für $\wedge$ (logisches {\sc und}, auch Konjunktion genannt) ist. \index{Konjunktion ($\wedge$)} \index{logisches {\sc und} ($\wedge$)}

\begin{verbatim}
MM> show statement prth/full
Statement 1791 is located on line 15503 of the file "set.mm".
Its statement number for HTML pages is 559.
"Conjoin antecedents and consequents of two premises.  This
is the closed theorem form of ~ anim12d .  Theorem *3.47 of
[WhiteheadRussell] p. 113.  It was proved by Leibniz,
and it evidently pleased him enough to call it
_praeclarum theorema_ (splendid theorem).
..."
1791 prth $p |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ( ph
      /\ ch ) -> ( ps /\ th ) ) ) $= ... $.
Its mandatory hypotheses in RPN order are:
  wph $f wff ph $.
  wps $f wff ps $.
  wch $f wff ch $.
  wth $f wff th $.
Its optional hypotheses are:  wta wet wze wsi wrh wmu wla wka
The statement and its hypotheses require the variables:  ph
      ps ch th
These additional variables are allowed in its proof:  ta et
      ze si rh mu la ka
The variables it contains are:  ph ps ch th


MM> show proof prth /lemmon/renumber
1 simpl          $p |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) ->
                                               ( ph -> ps ) )
2 simpr          $p |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) ->
                                               ( ch -> th ) )
3 1,2 anim12d    $p |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) ->
                           ( ( ph /\ ch ) -> ( ps /\ th ) ) )
\end{verbatim}

Es gibt Verweise auf eine Reihe unbekannter Aussagen.  Um zu sehen, um welche es sich handelt, können Sie Folgendes eingeben:

\begin{verbatim}
MM> show proof prth /statement_summary
Summary of statements used in the proof of "prth":

Statement simpl is located on line 14748 of the file
"set.mm".
"Elimination of a conjunct.  Theorem *3.26 (Simp) of
[WhiteheadRussell] p. 112. ..."
  simpl $p |- ( ( ph /\ ps ) -> ph ) $= ... $.

Statement simpr is located on line 14777 of the file
"set.mm".
"Elimination of a conjunct.  Theorem *3.27 (Simp) of
[WhiteheadRussell] ..."
  simpr $p |- ( ( ph /\ ps ) -> ps ) $= ... $.

Statement anim12d is located on line 15445 of the file
"set.mm".
"Conjoin antecedents and consequents in a deduction.
..."
  anim12d.1 $e |- ( ph -> ( ps -> ch ) ) $.
  anim12d.2 $e |- ( ph -> ( th -> ta ) ) $.
  anim12d $p |- ( ph -> ( ( ps /\ th ) -> ( ch /\ ta ) ) )
      $= ... $.
\end{verbatim}
\begin{center}
(etc.)
\end{center}

Natürlich können Sie jede dieser Aussagen und ihre Beweise und so weiter bis zu den Axiomen der Aussagenlogik zurückverfolgen, wenn Sie möchten.

Der Befehl \texttt{search} ist nützlich, um Aussagen zu finden, deren Inhalt Sie ganz oder teilweise kennen.  Das folgende Beispiel findet alle Aussagen, die \verb@ph -> ps@ gefolgt von \verb@ch -> th@ enthalten.  Das \verb@$*@ ist ein Platzhalter, der auf alles passt; das \texttt{\$} vor dem \verb$*$ verhindert Konflikte mit Token-Namen für mathematische Symbole.  Das \verb@*@ nach \texttt{SEARCH} ist ebenfalls ein Platzhalter, der in diesem Fall "`passt auf jede Bezeichnung"' bedeutet. \index{\texttt{search}-Befehl}

% I'm omitting this one, since readers are unlikely to see it:
% 1096 bisymOLD $p |- ( ( ( ph -> ps ) -> ( ch -> th ) ) -> ( (
%   ( ps -> ph ) -> ( th -> ch ) ) -> ( ( ph <-> ps ) -> ( ch
%    <-> th ) ) ) )
\begin{verbatim}
MM> search * "ph -> ps $* ch -> th"
1791 prth $p |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ( ph
    /\ ch ) -> ( ps /\ th ) ) )
2455 pm3.48 $p |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( (
    ph \/ ch ) -> ( ps \/ th ) ) )
117859 pm11.71 $p |- ( ( E. x ph /\ E. y ch ) -> ( ( A. x (
    ph -> ps ) /\ A. y ( ch -> th ) ) <-> A. x A. y ( ( ph /\
    ch ) -> ( ps /\ th ) ) ) )
\end{verbatim}

Drei Aussagen, \texttt{prth}, \texttt{pm3.48} und \texttt{pm11.71}, wurden als übereinstimmend befunden.

Um zu sehen, von welchen Axiomen\index{Axiom} und Definitionen\index{Definition} der Beweis von \texttt{prth} letztlich abhängt, können Sie das Programm die Hierarchie der Theoreme und Definitionen zurückverfolgen lassen.\index{\texttt{show trace{\char`\_}back}-Befehl}

\begin{verbatim}
MM> show trace_back prth /essential/axioms
Statement "prth" assumes the following axioms ($a
statements):
  ax-1 ax-2 ax-3 ax-mp df-bi df-an
\end{verbatim}

Beachten Sie, dass die 3 Axiome der Aussagenlogik und der Modus ponens benötigt werden (wie erwartet); außerdem gibt es eine Reihe von Definitionen, die unterwegs verwendet werden.  Beachten Sie, dass Metamath keinen Unterschied\index{Axiom vs. Definition} zwischen Axiomen\index{Axiom} und Definitionen\index{Definition} macht.  In \texttt{set.mm} wurden sie künstlich unterschieden, indem man ihren Bezeichnungen\index{Label in \texttt{set.mm}} jeweils \texttt{ax-} und \texttt{df-} voranstellte.  Zum Beispiel definiert \texttt{df-an} die Konjunktion (logisch {\sc und}), die durch das Symbol \verb+/\+ dargestellt wird. In Abschnitt~\ref{definitions} wird die Philosophie von Definitionen erörtert, und die Metamath-Sprache verfolgt einen besonders einfachen, konservativen Ansatz, indem sie die \texttt{\$a}\index{\texttt{\$a}-Anweisung}-Anweisungen sowohl für Axiome als auch für Definitionen verwendet.

Sie können das Programm auch berechnen lassen, wie viele Schritte ein Beweis hat,\index{Beweislänge} wenn wir ihn bis zu den \texttt{\$a}-Anweisungen zurückverfolgen würden.

\begin{verbatim}
MM> show trace_back prth /essential/count_steps
The statement's actual proof has 3 steps.  Backtracking, a
total of 79 different subtheorems are used.  The statement
and subtheorems have a total of 274 actual steps.  If
subtheorems used only once were eliminated, there would be a
total of 38 subtheorems, and the statement and subtheorems
would have a total of 185 steps.  The proof would have 28349
steps if fully expanded back to axiom references.  The
maximum path length is 38.  A longest path is:  prth <-
anim12d <- syl2and <- sylan2d <- ancomsd <- ancom <- pm3.22
<- pm3.21 <- pm3.2 <- ex <- sylbir <- biimpri <- bicomi <-
bicom1 <- bi2 <- dfbi1 <- impbii <- bi3 <- simprim <- impi <-
con1i <- nsyl2 <- mt3d <- con1d <- notnot1 <- con2i <- nsyl3
<- mt2d <- con2d <- notnot2 <- pm2.18d <- pm2.18 <- pm2.21 <-
pm2.21d <- a1d <- syl <- mpd <- a2i <- a2i.1 .
\end{verbatim}

Daraus ergibt sich, dass wir 274 Schritte überprüfen müssten, wenn wir den Beweis ausgehend von den Axiomen vollständig verifizieren wollen.  Es werden auch einige weitere Statistiken angezeigt.  Es gibt einen oder mehrere Pfade zurück zu den Axiomen, die am längsten sind; dieser Befehl sucht einen von ihnen heraus und zeigt ihn an.  Die Länge des längsten Pfades kann in gewisser Weise ausdrücken, wie "`tief"' das Theorem ist.

Wir könnten uns auch fragen, welche Beweise von dem Theorem \texttt{prth} abhängen.  Wenn er später nie verwendet wird, könnten wir ihn als überflüssig streichen, wenn er an sich nicht von Interesse ist.\index{\texttt{show usage}-Befehl}

% I decided to show the OLD values here.
\begin{verbatim}
MM> show usage prth
Statement "prth" is directly referenced in the proofs of 18
statements:
  mo3 moOLD 2mo 2moOLD euind reuind reuss2 reusv3i opelopabt
  wemaplem2 rexanre rlimcn2 o1of2 o1rlimmul 2sqlem6 spanuni
  heicant pm11.71
\end{verbatim}

Somit wird \texttt{prth} von 18 Beweisen direkt verwendet. Wir können die Option \texttt{/recursive} verwenden, um die indirekte Verwendung einzuschließen:

\begin{verbatim}
MM> show usage prth /recursive
Statement "prth" directly or indirectly affects the proofs of
24214 statements:
  mo3 mo mo3OLD eu2 moOLD eu2OLD eu3OLD mo4f mo4 eu4 mopick
...
\end{verbatim}

\subsection{Eine Anmerkung zum "`kompakten"' \\Beweis\-format}

Das Programm Metamath zeigt Beweise in einem "`kompakten"'\index{kompakter Beweis} Format an, wenn der Beweis in komprimiertem Format in der Datenbasis gespeichert ist.  Dies kann etwas verwirrend sein, wenn man nicht weiß, wie dies zu interpretieren ist. Wenn Sie zum Beispiel den vollständigen Beweis des Theorems \texttt{id1} anzeigen lassen, wird er wie folgt beginnen:

\begin{verbatim}
MM> show proof id1 /lemmon/all
 1 wph           $f wff ph
 2 wph           $f wff ph
 3 wph           $f wff ph
 4 2,3 wi    @4: $a wff ( ph -> ph )
 5 1,4 wi    @5: $a wff ( ph -> ( ph -> ph ) )
 6 @4            $a wff ( ph -> ph )
\end{verbatim}

\begin{center}
{etc.}
\end{center}

Schritt 4 wird ein "`lokales Label"', \index{lokales Label } \texttt{@4}, zugewiesen. Später, bei Schritt 6, wird auf dieses Label \texttt{@4} verwiesen, anstatt den expliziten Beweis für diesen Schritt anzuzeigen.  Diese Technik macht sich die Tatsache zunutze, dass sich Schritte in einem Beweis häufig wiederholen, insbesondere bei der Konstruktion von wffs.  Das kompakte Format reduziert die Anzahl der Schritte in der Darstellung des Beweises und wird von manchen Benutzern bevorzugt.

Wenn Sie das normale Format mit den "`wahren"' Schrittzahlen sehen wollen, können Sie folgende Abhilfe verwenden:\index{\texttt{save proof}-Befehl}

\begin{verbatim}
MM> save proof id1 /normal
The proof of "id1" has been reformatted and saved internally.
Remember to use WRITE SOURCE to save it permanently.
MM> show proof id1 /lemmon/all
 1 wph           $f wff ph
 2 wph           $f wff ph
 3 wph           $f wff ph
 4 2,3 wi        $a wff ( ph -> ph )
 5 1,4 wi        $a wff ( ph -> ( ph -> ph ) )
 6 wph           $f wff ph
 7 wph           $f wff ph
 8 6,7 wi        $a wff ( ph -> ph )
\end{verbatim}

\begin{center}
{etc.}
\end{center}

Beachten Sie, dass aus den ursprünglichen 6 Schritten nun 8 Schritte geworden sind.  Das Format ist jetzt jedoch dasselbe wie in Kapitel~\ref{using} beschrieben.

\chapter{Die Metamath-Sprache}
\label{languagespec}

\begin{quote}
  {\em So kann die Mathematik als das Fach definiert werden, in dem wir nie wissen, wovon wir sprechen, noch ob das, was wir sagen, wahr ist.}
      \flushright\sc  Bertrand Russell\footnote{Frei übersetzt nach \cite[S.~84]{Russell2}.}\\
\end{quote}\index{Russell, Bertrand}

Das wohl auffälligste Merkmal der Metamath-Sprache ist das fast voll\-stän\-dige Fehlen einer fest verdrahteten Syntax. Metamath\index{Metamath} versteht keine andere Mathematik oder Logik als die, die für die Konstruktion endlicher Symbolfolgen nach einer kleinen Menge einfacher, eingebauter Regeln erforderlich ist.  Die einzige Regel für Beweise ist die Ersetzung einer Variablen durch einen Ausdruck (Symbolfolge) mit einer einfachen Variableneinschränkung, um Kollisionen zwischen gebundenen Variablen zu verhindern.  Die primitiven Konzepte, die in Metamath eingebaut sind, beinhalten die einfache Manipulation von endlichen Objekten (Symbolen), die wir uns als Menschen leicht vergegenwärtigen können und mit denen Computer leicht umgehen können.  Sie scheinen so ziemlich die einfachsten Konzepte zu sein, die für die Standardmathematik erforderlich sind.

Dieses Kapitel dient als Nachschlagewerk für die Sprache Metamath\index{Metamath}. Es behandelt die langwierigen technischen Details der Sprache, von denen Sie einige beim ersten Lesen vielleicht überfliegen möchten.  Andererseits sollten Sie den definierten Begriffen in {\bf Fettschrift} große Aufmerksamkeit schenken; sie haben präzise Bedeutungen, die Sie sich für das spätere Verständnis merken sollten.  Am besten machen Sie sich zunächst mit den Beispielen in Kapitel~\ref{using} vertraut, um eine gewisse Motivation für die Sprache zu erhalten.

%% Uncomment this when uncommenting section {formalspec} below
Wenn Sie eine gewisse Kenntnis über die Mengenlehre haben, sollten Sie dieses Kapitel in Verbindung mit der formalen mengentheoretischen Beschreibung der Metamath-Sprache im Anhang~\ref{formalspec} studieren.

Wir werden den Namen "`Metamath"'\index{Metamath} verwenden, um entweder die Meta\-math-Computersprache oder die mit der Computersprache verbundene Meta\-math-Software zu bezeichnen.  Wir werden nicht zwischen diesen beiden unterscheiden, wenn der Kontext klar ist.

Der nächste Abschnitt enthält die vollständige Spezifikation der Metamath-Sprache. Sie dient als maßgebliche Referenz und stellt die Syntax detailliert genug dar, um einen Parser\index{Metamath parsen} und einen Beweisverifizierer zu schreiben.  Die Spezifikation ist knapp und es ist wahrscheinlich schwer, die Sprache direkt aus ihr heraus zu lernen. Aber wir nehmen sie hier für die ungeduldigen Leute auf, die lieber alles im Voraus sehen wollen, bevor sie sich mit ausführlichen Erklärungen beschäftigen wollen.  Spätere Abschnitte erläutern dieses Material und liefern Beispiele. Wir werden die Definitionen in diesen Abschnitten wiederholen, und Sie können den nächsten Abschnitt beim ersten Lesen überspringen und mit Abschnitt~\ref{tut1} (S.~\pageref{tut1}) fortfahren.

\section{Spezifikation der Metamath-Sprache}\label{spec}
\index{Metamath!Spezifikation}

\begin{quote}
  {\em Manchmal muss man schwierige Dinge sagen, aber man sollte sie so einfach wie möglich sagen.}
    \flushright\sc  G. H. Hardy\footnote{Frei übersetzt nach dem Zitat in \cite{deMillo}, S.~273.}\\
\end{quote}\index{Hardy, G. H.}

\subsection{Vorbereitungen}\label{spec1}

% Space is technically a printable character, so we'll word things
% carefully so it's unambiguous.
Eine Metamath-{\bf Datenbasis}\index{Datenbasis} wird aus einer übergeordneten Quelldatei zusammen mit allen Quelldateien aufgebaut, die durch Anweisungen zum Einbinden von Dateien (siehe unten) eingebunden werden.  Die einzigen Zeichen, die in einer Metamath-Quelldatei vorkommen dürfen, sind die 94 druckbaren {\sc ascii}\index{ascii@{\sc ascii}}-Zeichen ohne Whitespace-Zeichen, d.h. Ziffern, Groß- und Kleinbuchstaben, und die folgenden 32 Sonderzeichen\index{Sonderzeichen}:\label{spec1chars}

\begin{verbatim}
! '' # $ % & ' ( ) * + , - . / :
; < = > ? @ [ \ ] ^ _ ` { | } ~
\end{verbatim}
plus die folgenden Zeichen, die als "`Whitespace"'-Zeichen\label{whitespace} bezeichnet werden: Leerzeichen (ein druckbares Zeichen) und die nicht druckbaren Steuerzeichen Tabulator, Wagenrücklauf, Zeilenvorschub und Seitenvorschub.\footnote{Anm. der Übersetzer: Im Deutschen wird ein "`Whitespace"'-Zeichen manchmal auch als "`Leerraum"' oder "`Weißraum"'oder noch sperriger "`Zwischenraumzeichen"' übersetzt. Wir benutzen hier aber durchgängig die auch im Deutschen üblicherweise verwendete englische Bezeichnung "`Whitespace"'.} Wir verwenden die Schriftart \texttt{typewriter}, um die druckbaren Zeichen anzuzeigen.

Eine Metamath-Datenbasis besteht aus einer Folge von drei Arten von {\bf Token}\index{Token}, die durch {\bf Whitespace}\index{Whitespace} (eine beliebige Folge von einem oder mehreren "`Whitespace"'-Zeichen ) getrennt sind.  Die Menge der {\bf Schlüsselwort}\index{Schlüsselwort}-Token ist \texttt{\$\char`\{}, \texttt{\$\char`\}}, \texttt{\$c}, \texttt{\$v}, \texttt{\$f}, \texttt{\$e}, \texttt{\$d}, \texttt{\$a}, \texttt{\$p}, \texttt{\$.}, \texttt{\$=}, \texttt{\$(}, \texttt{\$)}, \texttt{\$[}, und \texttt{\$]}. Die letzten vier werden als {\bf Hilfs-}\index{Hilfsschlüsselwort} oder vorverarbeitende Schlüsselwörter bezeichnet.  Ein {\bf Label}\index{Label}-Token besteht aus einer beliebigen Kombination von Buchstaben, Ziffern und den Zeichen Bindestrich, Unterstrich und Punkt.  Ein Token für ein {\bf mathematisches Symbol}\index{mathematisches Symbol} kann aus einer beliebigen Kombination der 93 druckbaren Standard-{\sc ascii}-Zeichen außer Leerzeichen und \texttt{\$}~ bestehen. Bei allen Token wird zwischen Groß- und Kleinschreibung unterschieden.

\subsection{Vorverarbeitung}

Mit dem Token \texttt{\$(} beginnt ein {\bf Kommentar} und \texttt{\$)} beendet einen Kommentar.\index{\texttt{\$(} und \texttt{\$)} Hilfsschlüsselwörter}\index{Kommentar} Kommentare können jedes der 94 druckbaren Nicht-Whitespace-Zeichen und Whitespace enthalten, mit der Ausnahme, dass sie nicht die 2-Zeichen-Sequenzen \texttt{\$(} oder \texttt{\$)} enthalten dürfen (Kommentare lassen sich nicht verschachteln). Kommentare werden beim Parsen ignoriert (wie Whitespace behandelt), z. B. ist \texttt{\$( \$[ \$)} ein Kommentar. Siehe S.~\pageref{mathcomments} für die Konventionen zur Darstellung von Kommentaren; diese Konventionen können für die Zwecke des Parsens ignoriert werden.

Eine {\bf Anweisung zum Einbinden von Dateien} besteht aus \texttt{\$[}, gefolgt von einem Dateinamen, gefolgt von \texttt{\$]}.\index{\texttt{\$[} und \texttt{\$]} Hilfsschlüsselwörter}\index{eingebundene Datei}\index{Dateieinbindung} Es ist nur im äußersten Bereich zulässig (d. h. nicht zwischen \texttt{\$\char`\{} und \texttt{\$\char`\}}) und darf nicht innerhalb einer Aussage stehen (z. B. darf es nicht zwischen dem Label einer \texttt{\$a}-Anweisung und ihrem abschließenden \texttt{\$.} vorkommen). Der Dateiname darf weder ein \texttt{\$} noch ein Whitespace enthalten.  Die Datei muss existieren. Die Unterscheidung zwischen Groß- und Kleinschreibung des Namens folgt den Konventionen des Betriebssystems.  Der Inhalt der Datei ersetzt die Anweisung zum Einbinden von Dateien beim Einlesen der übergeordneten Datei. Eingebundene Dateien können andere Dateien einbinden. Nur der erste Verweis auf eine bestimmte Datei wird eingebunden; alle späteren Verweise auf dieselbe Datei (ob in der Datei der obersten Ebene oder in eingebundene Dateien) führen dazu, dass die Anweisung zum Einbinden von Dateien ignoriert wird (wie Whitespace behandelt wird). Ein Prüfprogramm kann davon ausgehen, dass Dateinamen bestehend aus unterschiedlichen Zeichenketten sich auf unterschiedliche Dateien beziehen, um spätere Verweise zu ignorieren. Ein Selbstverweis auf eine Datei wird ignoriert, ebenso wie jeder Verweis auf die übergeordnete Datei (um Schleifen zu vermeiden). Eingebundene Dateien dürfen kein \texttt{\$(} ohne ein passendes \texttt{\$)}, kein \texttt{\$[} ohne ein passendes \texttt{\$]} und keine unvollständigen Aussagen (z. B. ein \texttt{\$a} ohne ein passendes \texttt{\$.}) enthalten. Es ist derzeit nicht spezifiziert, ob Pfadreferenzen relativ zum aktuellen Verzeichnis des Prozesses oder zum Verzeichnis, das die Datei enthält, zu verstehen sind, so dass Datenbasen die Verwendung von Pfadnamen-Trennzeichen (z.B. "`/"') in Dateinamen vermeiden sollten.

Wie alle Token müssen die Schlüsselwörter \texttt{\$(}, \texttt{\$)}, \texttt{\$[} und \texttt{\$]}
von Whitespace umgeben sein.

\subsection{Grundlegende Syntax}

Nach der Vorverarbeitung besteht eine Datenbasis aus einer Folge von {\bf Anweisungen}. Dies sind die Gültigkeitsbereichsanweisungen \texttt{\$\char`\{} und \texttt{\$\char`\}} sowie die Anweisungen \texttt{\$c}, \texttt{\$v}, \texttt{\$f}, \texttt{\$e}, \texttt{\$d}, \texttt{\$a} und \texttt{\$p}.

Eine {\bf Gültigkeitsbereichsanweisung}\index{Gültigkeitsbereichsanweisung} besteht nur aus ihrem Schlüsselwort: \texttt{\$\char`\{} oder \texttt{\$\char`\}}. Mit \texttt{\$\char`\{} beginnt ein {\bf Block}\index{Block}, und ein zugehöriges \texttt{\$\char`\}} beendet den Block. Jedes \texttt{\$\char`\{} muss ein zugehöriges \texttt{\$char`\}} haben. Rekursiv definiert ist ein Block eine Folge von keinem, einem oder mehreren Token außer \texttt{\$\char`\{} und \texttt{\$\char`\}} und möglicherweise anderen enthaltenen Blöcken.  Es gibt einen {\bf äußersten Block}\index{Block!äußerster}, der nicht von \texttt{\$\char`\{} \texttt{\$\char`\}} eingeklammert ist; das Ende des äußersten Blocks ist das Ende der Datenbasis.


% LaTeX bug? can't do \bf\tt

Eine {\bf \$v}- oder {\bf \$c-Anweisung}\index{\texttt{\$v}-Anweisung}\index{\texttt{\$c}-Anweisung} besteht aus dem Schlüsselwort-Token \texttt{\$v} bzw. \texttt{\$c}, gefolgt von einem oder mehreren mathematischen Symbolen,
% The word "token" is used to distinguish "$." from the sentence-ending period.
gefolgt von dem \texttt{\$.}-Token. Diese Anweisungen {\bf erklären}\index{Erklärung} die mathematischen Symbole zu {\bf Variablen}\index{Variable!Metamath} bzw. {\bf Konstanten}\index{Konstanten}. Dasselbe mathematische Symbol darf nicht zweimal in ein und derselben \texttt{\$v}- oder \texttt{\$c}-Anweisung vorkommen.

%c%A math symbol becomes an {\bf active}\index{aktives mathematisches Symbol}
%c%when declared and stays active until the end of the block in which it is
%c%declared.  A math symbol may not be declared a second time while it is active,
%c%but it may be declared again after it becomes inactive.

Ein mathematisches Symbol wird {\bf aktiv}\index{aktives mathematisches Symbol}, sobald es deklariert wird, und bleibt es bis zum Ende des Blocks, in dem es deklariert wird.  Eine Variable kann nicht ein zweites Mal deklariert werden, solange sie aktiv ist, aber sie kann erneut deklariert werden (als Variable, aber nicht als Konstante), nachdem sie inaktiv geworden ist.  Eine Konstante muss im äußersten Block deklariert werden und darf nicht ein zweites Mal deklariert werden.\index{Umdeklarierung von Symbolen}

Eine {\bf \$f-Anweisung}\index{\texttt{\$f}-Anweisung} besteht aus einem Label, gefolgt von \texttt{\$f}, gefolgt von seinem Typcode (eine aktive Konstante), gefolgt von einer aktiven Variablen, gefolgt von dem \texttt{\$.}-Token.  Eine {\bf \$e-Anweisung}\index{\texttt{\$e}-Anweisung} besteht aus einem Label, gefolgt von \texttt{\$e}, gefolgt von seinem Typcode (einer aktiven Konstante), gefolgt von keinem, einem oder mehreren aktiven mathematischen Symbolen, gefolgt von dem \texttt{\$.}-Token.  Eine {\bf Hypothese}\index{Hypothese} ist eine \texttt{\$f}- oder \texttt{\$e}-Anweisung. Der durch eine \texttt{\$f}-Anweisung für ein bestimmtes Label deklarierte Typ ist global, auch wenn die Variable es nicht ist (z. B. kann eine Datenbasis nicht \texttt{wff P} in einem lokalen Bereich und \texttt{class P} in einem anderen haben).

Eine {\bf einfache \$d-Anweisung}\index{\texttt{\$d}-Anweisung!einfach}besteht aus \texttt{\$d}, gefolgt von zwei verschiedenen aktiven Variablen, gefolgt von dem Token \texttt{\$.}\.  Eine zusammengesetzte Anweisung besteht aus \texttt{\$d}, gefolgt von drei oder mehr Variablen (alle unterschiedlich), gefolgt von dem \texttt{\$.}\ Token.  Die Reihenfolge der Variablen in einer \texttt{\$d}-Anweisung ist unerheblich.  Eine zusammengesetzte \texttt{\$d}-Anweisung ist äquivalent zu einer Reihe von einfachen \texttt{\$d}-Anweisungen, eine für jedes mögliche Paar von Variablen, die in der zusammengesetzten \texttt{\$d}-Anweisung vorkommen.  In dieser Spezifikation nehmen wir an, dass alle \texttt{\$d}-Anweisungen einfach sind.  Eine \texttt{\$d}-Anweisung wird auch als {\bf disjunkte} {\bf Variableneinschränkung}\index{disjunkte Variableneinschränkung} bezeichnet.

Eine {\bf \$a-Anweisung}\index{\texttt{\$a}-Anweisung} besteht aus einem Label, gefolgt von \texttt{\$a}, gefolgt von seinem Typcode (einer aktiven Konstante), gefolgt von keinem, einem oder mehreren aktiven mathematischen Symbolen, gefolgt von dem \texttt{\$.}\-Token.  Eine {\bf \$p-Anweisung}\index{\texttt{\$p}-Anweisung} besteht aus einem Label, gefolgt von \texttt{\$p}, gefolgt von seinem Typcode (einer aktiven Konstanten), gefolgt von keinem, einem oder mehreren aktiven mathematischen Symbolen, gefolgt von \texttt{\$=}, gefolgt von einer Folge von Labels, gefolgt von dem \texttt{\$.}\-Token.  Eine {\bf Behauptung}\index{Behauptung} ist eine \texttt{\$a}- oder \texttt{\$p}-Anweisung.

Eine \texttt{\$f}-, \texttt{\$e}- oder \texttt{\$d}-Anweisung ist von der Stelle, an der sie auftritt, bis zum Ende des Blocks, in dem sie auftritt, {\bf aktiv}. Eine \texttt{\$a}- oder \texttt{\$p}-Anweisung ist {\bf aktiv} von der Stelle, an der sie auftritt, bis zum Ende der Datenbasis. Es darf nicht zwei aktive \texttt{\$f}-Anweisungen geben, die die gleiche Variable enthalten.  Jede Variable in einer \texttt{\$e}-, \texttt{\$a}- oder \texttt{\$p}-Anweisung muss in einer aktiven \texttt{\$f}-Anweisung vorkommen.\footnote{Diese Anforderung kann den Vereinheitlichungsalgorithmus (Berechnung der Substitutionen), der für die Beweisüberprüfung erforderlich ist, erheblich vereinfachen.}

%The label that begins each \texttt{\$f}, \texttt{\$e}, \texttt{\$a}, and
%\texttt{\$p} statement must be unique.
Jedes Label-Token muss eindeutig sein, und kein Label-Token darf mit einem Token eines mathematischen Symbols übereinstimmen.\label{namespace}\footnote{Diese Einschränkung wurde am 24. Juni 2006 hinzugefügt. Sie ist theoretisch nicht notwendig, wird aber eingeführt, um das Schreiben bestimmter Parser zu erleichtern.}

Die Menge der {\bf obligatorischen Variablen}\index{obligatorische Variable}, die mit einer Behauptung verbunden ist, ist die (möglicherweise leere) Menge der Variablen in der Behauptung und in allen aktiven \texttt{\$e}-Anweisungen.  Die (möglicherweise leere) Menge der {\bf obligatorischen Hypothesen}\index{obligatorische Hypothese} ist die Menge aller aktiven \texttt{\$f}-Anweisungen, die obligatorische Variablen enthalten, zusammen mit allen aktiven \texttt{\$e}-Anweisungen. Die Menge der {\bf obligatorischen {\bf \$d}-Anweisungen}\index{obligatorische disjunkte Variableneinschränkung}, die mit einer Behauptung verbunden ist, sind die aktiven \texttt{\$d}-Anweisungen, deren Variablen beide zu den obligatorischen Variablen der Behauptung gehören.

\subsection{Beweisverifizierung}\label{spec4}

Die Folge von Labeln zwischen den Token in einer \texttt{\$p}-Anweisung ist ein {\bf Beweis}\index{Beweis!Metamath}. Jedes Label in einem Beweis muss das Label einer anderen aktiven Aussage als die der \texttt{\$p}-Anweisung selbst sein; eine Kennzeichnung muss sich also entweder auf eine aktive Hypothese der \texttt{\$p}-Anweisung oder auf eine frühere Behauptung beziehen.

Ein {\bf Ausdruck}\index{Ausdruck} ist eine Folge von mathematischen Symbolen. Eine {\bf Substitutionsabbildung}\index{Substitutionsabbildung} assoziiert eine Menge von Variablen mit einer Menge von Ausdrücken.  Es ist zulässig, dass eine Variable auf einen Ausdruck abgebildet wird, der sie enthält.  Eine {\bf Substitution}\index{Substitution!Variable}\index{Variablensubstitution} ist die gleichzeitige Ersetzung aller Variablen in einem oder mehreren Ausdrücken durch die Ausdrücke, denen die Variablen zugeordnet sind.

Ein Beweis wird in der Reihenfolge seiner Labelfolge gescannt.  Wenn sich das Label auf eine aktive Hypothese bezieht, wird der Ausdruck in der Hypothese auf einen Stapel\index{Stapel}\index{RPN-Stapel} geschoben.  Bezieht sich das Label auf eine Behauptung, so muss eine (eindeutige) Substitution vorhanden sein, die, wenn sie an den obligatorischen Hypothesen der referenzierten Behauptung vorgenommen wird, bewirkt, dass diese mit den obersten (d. h. jüngsten) Einträgen des Stapels in der Reihenfolge des Auftretens der obligatorischen Hypothesen übereinstimmen, wobei der oberste Stapel-Eintrag mit der letzten obligatorischen Hypothese der referenzierten Behauptung übereinstimmt.  Anschließend werden so viele Stapel-Einträge wie obligatorischen Hypothesen vorhanden sind, vom Stapel entfernt.  Die gleiche Ersetzung wird an der referenzierten Behauptung vorgenommen, und das Ergebnis wird auf den Stapel geschoben. Nachdem das letzte Label im Beweis verarbeitet wurde, muss der Stapel einen einzigen Eintrag enthalten, der mit dem Ausdruck in der \texttt{\$p}-Anweisung übereinstimmt, die den Beweis enthält.

%c%{\footnotesize\begin{quotation}\index{Umdeklarierung von Symbolen}
%c%{{\em Comment.}\label{spec4comment} Whenever a math symbol token occurs in a
%c%{\texttt{\$c} or \texttt{\$v} statement, it is considered to designate a distinct new
%c%{symbol, even if the same token was previously declared (and is now inactive).
%c%{Thus a math token declared as a constant in two different blocks is considered
%c%{to designate two distinct constants (even though they have the same name).
%c%{The two constants will not match in a proof that references both blocks.
%c%{However, a proof referencing both blocks is acceptable as long as it doesn't
%c%{require that the constants match.  Similarly, a token declared to be a
%c%{constant for a referenced assertion will not match the same token declared to
%c%{be a variable for the \texttt{\$p} statement containing the proof.  In the case
%c%{of a token declared to be a variable for a referenced assertion, this is not
%c%{an issue since the variable can be substituted with whatever expression is
%c%{needed to achieve the required match.
%c%{\end{quotation}}
%c2%A proof may reference an assertion that contains or whose hypotheses contain a
%c2%constant that is not active for the \texttt{\$p} statement containing the proof.
%c2%However, the final result of the proof may not contain that constant. A proof
%c2%may also reference an assertion that contains or whose hypotheses contain a
%c2%variable that is not active for the \texttt{\$p} statement containing the proof.
%c2%That variable, of course, will be substituted with whatever expression is
%c2%needed to achieve the required match.

Ein Beweis kann ein \texttt{?}\ anstelle eines Labels enthalten, um einen unbekannten Schritt anzuzeigen (Abschnitt~\ref{unknown}).  Ein Beweisverifizierer kann jeden Beweis ignorieren, der \texttt{?}\ enthält, sollte aber den Benutzer warnen, dass der Beweis unvollständig ist.

Ein {\bf komprimierter Beweis}\index{komprimierter Beweis}\index{Beweis!komprimiert} ist eine alternative Beweis-Notation, die im Anhang\ref{compressed} beschrieben wird; siehe auch Verweise auf "`komprimierte Beweise"' im Index.  Komprimierte Beweise sind eine Erweiterung der Metamath-Sprache, die ein vollständiger Beweisverifizierer analysieren und verifizieren können sollte.

\subsubsection{Überprüfung von disjunkten Variableneinschränkungen}

Jede in einem Beweis vorgenommene Substitution muss wie folgt überprüft werden, um sicherzustellen, dass alle disjunkten Variableneinschränkungen erfüllt sind.

Wenn zwei durch eine Substitution ersetzte Variablen in einer obligatorischen \texttt{\$d}-Anweisung\index{\texttt{\$d}-Anweisung} der referenzierten Behauptung vorhanden sind, müssen die beiden aus der Substitution resultierenden Ausdrücke folgende Bedingungen erfüllen.  Erstens dürfen die beiden Ausdrücke keine Variablen gemeinsam haben. Zweitens muss jedes mögliche Paar von Variablen, eine von jedem Ausdruck, in einer aktiven \texttt{\$d}-Anweisung der \texttt{\$p}-Anweisung, die den Beweis enthält, vorhanden sein.

\vskip 1ex

Damit ist die Spezifikation der Metamath-Sprache abgeschlossen; siehe Anhang \ref{BNF} für ihre Syntax in erweiterter Backus--Naur-Form (EBNF)\index{erweiterte Backus--Naur-Form}\index{EBNF}.

\section{Die grundlegenden Schlüsselwörter}\label{tut1}

Im folgenden werden die im letzten Abschnitt vorgestellten Konstrukte der Metamath-Sprache genauer erläutert.

Wie die meisten Computersprachen bezieht Metamath\index{Metamath} seine Eingaben aus einer oder mehreren {\bf-Quelldateien}\index{Quelldatei}, die Zeichen im Standardcode {\sc ascii} (American Standard Code for Information Interchange)\index{ascii@{\sc ascii}} für Computer enthalten.  Eine Quelldatei besteht aus einer Reihe von {\bf Tokens}\index{Token}, d.h. Zeichenketten aus druckbaren Zeichen ohne Whitespace (aus dem auf S.~\pageref{spec1chars} gezeigten Satz von 94 Zeichen), die durch {\bf Whitespace}\index{Whitespace} (Leerzeichen, Tabulatoren, Wagenrücklauf, Zeilenvorschub und Seitenvorschub) getrennt sind. Jede Zeichenkette, die nur aus diesen Zeichen besteht, wird wie ein einzelnes Leerzeichen behandelt.  Die druckbaren Zeichen ohne Whitespace {\index{druckbares Zeichen}}, die Metamath erkennt, sind die 94 Zeichen auf Standard-{\sc ascii}-Tastaturen.

Metamath hat die Möglichkeit, mehrere Dateien zusammenzufügen, um die Eingabe zu bilden (Abschnitt~\ref{include}).  Wir nennen den Gesamtinhalt aller Dateien, nachdem sie zusammengefügt wurden, eine {\bf database}\index{Datenbasis}, um sie von einer einzelnen Quelldatei zu unterscheiden.  Die Tokens in einer Datenbasis bestehen aus {\bf Schlüsselwörter}\index{Schlüsselwort}, die in die Sprache eingebaut sind, sowie aus zwei Arten von benutzerdefinierten Tokens, den {\bf Labels}\index{Label} und die {\bf mathematischen Symbole}\index{mathematisches Symbol}.  (Der Kürze halber werden wir oft einfach {\bf symbol}\index{Symbol} anstelle von mathematischem Symbol sagen).  Die Menge der {\bf grundlegenden Schlüsselwörter}\index{grundlegendes Schlüsselwort} ist
\texttt{\$c}\index{\texttt{\$c}-Anweisung},
\texttt{\$v}\index{\texttt{\$v}-Anweisung},
\texttt{\$e}\index{\texttt{\$e}-Anweisung},
\texttt{\$f}\index{\texttt{\$f}-Anweisung},
\texttt{\$d}\index{\texttt{\$d}-Anweisung},
\texttt{\$a}\index{\texttt{\$a}-Anweisung},
\texttt{\$p}\index{\texttt{\$p}-Anweisung},
\texttt{\$=}\index{\texttt{\$=} Schlüsselwort},
\texttt{\$.}\index{\texttt{\$.} Schlüsselwort},
\texttt{\$\char`\{}\index{\texttt{\$\char`\{} und \texttt{\$\char`\}} Schlüsselwörter} und \texttt{\$\char`\}}.  Dies ist der vollständige Satz der syntaktischen Elemente der sogenannten {\bf Grundsprache}\index{grundlegende Sprache} von Metamath, und mit ihnen können Sie die gesamte Mathematik ausdrücken, so wie es bei der Entwicklung von Metamath beabsichtigt war.  Sie sollten sich unbedingt mit ihnen vertraut machen. Tabelle~\ref{basickeywords} listet die grundlegenden Schlüsselwörter zusammen mit einer kurzen Beschreibung ihrer Funktionen auf.  Für den Moment wird diese Beschreibung Ihnen nur eine vage Vorstellung von der Bedeutung der Schlüsselwörter geben; später werden wir die Schlüsselwörter im Detail beschreiben.


\begin{table}[htp] \caption{Zusammenfassung der grundlegenden Schlüsselwörter von Metamath} \label{basickeywords}
\begin{center}
\begin{tabular}{|p{5pc}|l|}
\hline
\em \centering Schlüsselwort&\em Beschreibung\\
\hline
\hline
\centering
   \texttt{\$c}&Konstantensymbol-Deklaration\\
\hline
\centering
   \texttt{\$v}&Variablensymbol-Deklaration\\
\hline
\centering
   \texttt{\$d}&disjunkte Variableneinschränkung\\
\hline
\centering
   \texttt{\$f}&("`Fließende"') Hypothese vom Variablentyp \\
\hline
\centering
   \texttt{\$e}&Logische ("`wesentliche"') Hypothese\\
\hline
\centering
   \texttt{\$a}&Axiomatische Behauptung\\
\hline
\centering
   \texttt{\$p}&Beweisbare Behauptung\\
\hline
\centering
   \texttt{\$=}&Beginn des Beweises in einer \texttt{\$p}-Anweisung \\
\hline
\centering
   \texttt{\$.}&Ende einer der obigen Anweisungen\\
\hline
\centering
   \texttt{\$\char`\{}&Beginn eines Blocks\\
\hline
\centering
   \texttt{\$\char`\}}&Ende eines Blocks\\
\hline
\end{tabular}
\end{center}
\end{table}

%For LaTeX bug(?) where it puts tables on blank page instead of btwn text
%May have to adjust if text changes
%\newpage

Es gibt einige zusätzliche Schlüsselwörter, {\bf Hilfsschlüsselwörter}\index{Hilfsschlüsselwort} genannt, die hilfreich für das Arbeiten mit Metamath\index{Metamath} sind. Diese sind Teil der {\bf erweiterten Sprache}\index{erweiterte Sprache}. Sie bieten Ihnen die Möglichkeit, Kommentare in eine Metamath-Quelldatei\index{Quelldatei} einzufügen und auf andere Quelldateien zu verweisen.  Wir werden diese in späteren Abschnitten vorstellen. Tabelle~\ref{otherkeywords} fasst sie zusammen, so dass Sie diese beim Durchsehen einiger Quelldateien zum Lernen der grundlegenden Schlüsselwörter erkennen können.

\begin{table}[htp] \caption{Hilfsschlüsselwörter in Methamath} \label{otherkeywords}
\begin{center}
\begin{tabular}{|p{5pc}|l|}
\hline
\em \centering Schlüsselwort&\em Beschreibung\\
\hline
\hline
\centering
   \texttt{\$(}&Beginn eines Kommentars\\
\hline
\centering
   \texttt{\$)}&Ende eines Kommentars\\
\hline
\centering
   \texttt{\$[}&Anfang des Namens einer eingeschlossenen Quelldatei\\
\hline
\centering
   \texttt{\$]}&Ende des Namens einer eingeschlossenen Quelldatei\\
\hline
\end{tabular}
\end{center}
\end{table}
\index{\texttt{\$(} und \texttt{\$)} Hilfsschlüsselwörter}
\index{\texttt{\$[} und \texttt{\$]} Hilfsschlüsselwörter}


Im Gegensatz zu den Schlüsselwörtern\index{Schlüsselwort} in einigen Computersprachen handelt es sich bei den Schlüsselwörtern nicht um englische Wörter, sondern um kurze zweistellige Zeichenfolgen.  Dadurch sind sie zwar anfangs etwas schwerer zu merken, aber durch ihre Kürze fügen sie sich in die beschriebene Mathematik ein und lenken nicht davon ab, so wie es etwa Satzzeichen tun.


\subsection{Benutzerdefinierte Tokens}\label{dollardollar}\index{Token}

Wie Sie vielleicht bemerkt haben, beginnen alle Schlüsselwörter mit dem Zeichen \texttt{\$}.  Dieses banale Währungssymbol wird normalerweise nicht in der höheren Mathematik verwendet (abgesehen von Förderanträgen), daher haben wir es ausgewählt, um die Metamath\index{Metamath}-Schlüsselwörter von gewöhnlichen mathematischen Symbolen zu unterscheiden. Das Zeichen \texttt{\$} wird daher als Sonderzeichen betrachtet und darf nicht als Zeichen in einem benutzer\-defi\-nier\-ten Token verwendet werden.  Bei allen Tokens und Schlüsselwörtern wird zwischen Groß- und Kleinschreibung unterschieden; so wird beispiels\-weise \texttt{n} als ein anderes Zeichen als \texttt{N} betrachtet.  Durch die Unterscheidung zwischen Groß- und Kleinschreibung wird der verfügbare {\sc ascii}-Zeichensatz so umfangreich wie möglich genutzt.

\subsubsection{Mathemathische Symbole}\index{Token}\index{mathematisches Symbol}

Mathematische Symbole sind Tokens, die zur Darstellung von Symbolen verwendet werden, die in gewöhnlichen mathematischen Formeln vorkommen.  Sie können aus einer beliebigen Kombination der 93 druckbaren {\sc ascii}-Zeichen (das Leerzeichen ausgeschlossen) außer \texttt{\$}~ bestehen. Einige Beispiele sind \texttt{x}, \texttt{+}, \texttt{(}, \texttt{|-}, \verb$!%@?&$, und \texttt{bounded}.  Aus Gründen der Lesbarkeit ist es am besten, wenn diese Symbole den tatsächlichen mathematischen Symbolen im Rahmen des {\sc ascii}-Zeichensatzes so ähnlich wie möglich sind, um die Lesbarkeit der resultierenden mathematischen Ausdrücke zu verbessern.

In der Metamath-Sprache drückt man gewöhnliche mathematische Formeln und Aussagen als Sequenzen von mathematischen Symbolen aus, wie z.B. \texttt{2 + 2 = 4} (fünf Symbole, alles Konstanten).\footnote{Um Mehrdeutigkeiten mit anderen Ausdrücken zu vermeiden, wird dies in der Mengenlehre-Datenbasis \texttt{set.mm} als \texttt{|- ( 2 + 2 ) = 4 } ausgedrückt, dessen \LaTeX-Äquivalent $\vdash (2+2)=4$ ist.  Das \,$\vdash$ bedeutet "`ist ein Satz"' und die Klammern ermöglichen eine explizite assoziative Gruppierung.}\index{Drehkreuz ({$\,\vdash$})} Es kann sich sogar um englische oder auch deutsche Sätze handeln, wie in \texttt{E ist geschlossen und begrenzt} (fünf Symbole) - hier wäre \texttt{E} eine Variable und die anderen vier Konstantensymbole.  Im Prinzip könnte eine Metamath-Datenbasis so konstruiert werden, dass sie mit fast jeder eindeutigen mathematischen Aussage in englischer Sprache arbeitet. In der Praxis wären die Definitionen, die erforderlich wären, um alle möglichen Syntax-Variationen zu berücksichtigen, jedoch umständlich und verwirrend und hätten möglicherweise subtile, zufällig eingebaute Tücken.  Wir empfehlen generell, mathematische Aussagen, wann immer möglich, mit kompakten mathematischen Standardsymbolen auszudrücken und ihre englischsprachigen Beschreibungen in Kommentare zu setzen.
Axiome\index{Axiom} und Definitionen\index{Definition} (\texttt{\$a}\index{\texttt{\$a}-Anweisung}-Anweisungen) sind die einzigen Stellen, an denen Metamath keinen Fehler erkennt, und dies hilft, die Anzahl der benötigten Definitionen zu reduzieren.

Es steht Ihnen frei, beliebige Tokens\index{Token} für mathematische Symbole\index{mathematisches Symbol} zu verwenden.  Im Anhang~\ref{ASCII} werden Token-Namen für Symbole in der Mengenlehre empfohlen, und wir schlagen vor, dass Sie diese übernehmen, um die Mengenlehre-Datenbasis \texttt{set.mm}  in Ihre Datenbasis aufnehmen zu können.  Für Ausdrucke können Sie die Tokens in einer Datenbasis mit dem Satzprogramm \LaTeX\ in mathematische Standardsymbole umwandeln.  Der Metamath-Befehl \texttt{open tex} {\em Dateinamen}\index{\texttt{open tex}-Befehl} erzeugt eine Ausgabe, die von \LaTeX.\index{latex@{\LaTeX}} gelesen werden kann. Die Korrespondenz zwischen den Token und den tatsächlichen Symbolen wird durch \texttt{latexdef}-Anweisungen innerhalb eines speziellen Datenbasiskommentars hergestellt, der mit \texttt{\$t} gekennzeichnet ist.\index{\texttt{\$t}-Anweisung}\index{Schriftsatzanweisung}   Sie können diesen Kommentar bearbeiten, um die Definitionen zu ändern oder neue hinzuzufügen. Im Anhang~\ref{ASCII} wird genauer beschrieben, wie das funktioniert.

% White space\index{Whitespace} is normally used to separate math
% symbol\index{mathematisches Symbol} tokens, but they may be juxtaposed without white
% space in \texttt{\$d}\index{\texttt{\$d}-Anweisung}, \texttt{\$e}\index{\texttt{\$e}
% statement}, \texttt{\$f}\index{\texttt{\$f}-Anweisung}, \texttt{\$a}\index{\texttt{\$a}
% statement}, and \texttt{\$p}\index{\texttt{\$p}-Anweisung} statements when no
% ambiguity will result.  Specifically, Metamath parses the math symbol sequence
% in one of these statements in the following manner:  when the math symbol
% sequence has been broken up into tokens\index{Token} up to a given character,
% the next token is the longest string of characters that could constitute a
% math symbol that is active\index{active
% math symbol} at that point.  (See Section~\ref{scoping} for the
% definition of an active math symbol.)  For example, if \texttt{-}, \texttt{>}, and
% \texttt{->} are the only active math symbols, the juxtaposition \texttt{>-} will be
% interpreted as the two symbols \texttt{>} and \texttt{-}, whereas \texttt{->} will
% always be interpreted as that single symbol.\footnote{For better readability we
% recommend a white space between each token.  This also makes searching for a
% symbol easier to do with an editor.  Omission of optional white space is useful
% for reducing typing when assigning an expression to a temporary
% variable\index{temporäre Variable} with the \texttt{let variable} Metamath
% program command.}\index{\texttt{let variable}-Befehl}
%
% Schlüsselwörter\index{Schlüsselwort} may be placed next to math symbols without white
% space\index{Whitespace} between them.\footnote{Again, we do not recommend
% this for readability.}
%
% The math symbols\index{mathematisches Symbol} in \texttt{\$c}\index{\texttt{\$c}-Anweisung}
% and \texttt{\$v}\index{\texttt{\$v}-Anweisung} statements must always be separated
% by white space\index{white
% space}, for the obvious reason that these statements define the names
% of the symbols.
%
% Math symbols referred to in comments (see Section~\ref{comments}) must also be
% separated by white space.  This allows you to make comments about symbols that
% are not yet active\index{active
% math symbol}.  (The "`math mode"' feature of comments is also a quick and
% easy way to obtain word processing text with embedded mathematical symbols,
% independently of the main purpose of Metamath; the way to do this is described
% in Section~\ref{comments})

\subsubsection{Labels}\index{Token}\index{Label}

Label-Token werden verwendet, um Metamath\index{Metamath}-Anweisungen für eine spätere Referenz zu identifizieren\footnote{Anm. der Übersetzer: deshalb werden "`Labels"' im Deutschen oft auch als "`Sprungmarken"' bezeichnet.}. Label-Token dürfen nur Buchstaben, Ziffern und die drei Zeichen Punkt, Bindestrich und Unterstrich enthalten:
\begin{verbatim}
. - _
\end{verbatim}

Ein Label wird deklariert\index{Label-Deklaration}, indem man es unmittelbar vor das Schlüsselwort der Anweisung setzt, die es kennzeichnet.  Zum Beispiel könnte das Label \texttt{axiom.1} wie folgt deklariert werden:
\begin{verbatim}
axiom.1 $a |- x = x $.
\end{verbatim}

Jede \texttt{\$e}\index{\texttt{\$e}-Anweisung},
\texttt{\$f}\index{\texttt{\$f}-Anweisung},
\texttt{\$a}\index{\texttt{\$a}-Anweisung}, und
\texttt{\$p}\index{\texttt{\$p}-Anweisung}-Anweisung in einer Datenbasis muss ein Label für sie deklariert haben.  Keine anderen Anweisungstypen dürfen Label-Deklarationen haben.  Jedes Label muss eindeutig sein.

Auf ein Label (und die damit bezeichnete Anweisung) wird {\bf referenziert}\index{Label-Referenz}, indem das Label zwischen den \texttt{\$=}\index{\texttt{\$=} Schlüsselwort} und \texttt{\$.}\index{\texttt{\$.} Schlüsselwort}\ Schlüsselwörtern in eine \texttt{\$p}-Anweisung aufgenommen wird.  Die Folge von Labels\index{Label-Sequenz} zwischen diesen beiden Schlüsselwörtern wird als {\bf Beweis}\index{Beweis} bezeichnet.  Ein Beispiel für eine Anweisung mit einem Beweis, dem wir später begegnen werden (Abschnitt~\ref{proof}), ist
\begin{verbatim}
wnew $p wff ( s -> ( r -> p ) )
     $= ws wr wp w2 w2 $.
\end{verbatim}

Sie müssen noch nicht wissen, was das bedeutet, aber Sie sollten wissen, dass das Label \texttt{wnew} durch diese \texttt{\$p}-Anweisung deklariert wird und dass davon ausgegangen wird, dass die Labels \texttt{ws}, \texttt{wr}, \texttt{wp} und \texttt{w2} früher in der Datenbasis deklariert wurden und hier referenziert werden.

\subsection{Konstanten und Variablen}
\index{Konstante}
\index{Variable}

Ein {\bf Ausdruck}\index{Ausdruck} ist eine beliebige Folge von mathematischen Symbolen, die auch leer sein kann.

Die grundlegende Metamath\index{Metamath}-Sprache\index{grundlegende Sprache} hat zwei Arten von mathematischen Symbolen\index{mathematisches Symbol}:  {\bf Konstanten}\index{Konstante} und {\bf Variablen}\index{Variable}.  In einem Metamath-Beweis kann eine Konstante nicht durch einen beliebigen Ausdruck ersetzt werden.  Eine Variable kann durch einen beliebigen Ausdruck ersetzt\index{Substitution!Variable}\index{Variablensubstitution} werden.  Diese Sequenz kann andere Variablen und sogar die zu ersetzende Variable einschließen.  Diese Substitution findet statt, wenn Beweise verifiziert werden, und wird in Abschnitt~\ref{proof} beschrieben.  Die Anweisung \texttt{\$f} (später in Abschnitt~\ref{dollaref} beschrieben) wird verwendet, um den {\bf Typ} einer Variablen anzugeben (d.h. um welche Art von Variable es sich handelt)\index{Variablentyp}\index{Typ} zu spezifizieren und ihr eine Bedeutung zu geben, die typischerweise mit einer "`Metavariablen"' assoziiert wird. \index{Metavariable}\footnote{Eine Metavariable ist eine Variable, die sich über die syntaktischen Elemente der diskutierten Objektsprache erstreckt; zum Beispiel könnte eine Metavariable eine Variable der Objektsprache und eine andere Metavariable eine Formel in der Objektsprache repräsentieren. } in der gewöhnlichen Mathematik; eine Variable kann z. B. als wff oder wohlgeformte Formel (in der Logik), als Menge (in der Mengenlehre) oder als nichtnegative ganze Zahl (in der Zahlentheorie) angegeben werden.

\subsection{Die \texttt{\$c}- und \texttt{\$v}-Deklarationsanweisungen}
\index{\texttt{\$c}-Anweisung}
\index{Konstantendeklaration}
\index{\texttt{\$v}-Anweisung}
\index{Variablendeklaration}

Konstanten werden mit \texttt{\$c}\index{\texttt{\$c}-Anweisung}-Anweisungen eingeführt oder {\bf deklariert}\index{Konstantendeklaration}, und Variablen werden mit \texttt{\$v}\index{\texttt{\$v}-Anweisung}-Anweisungen deklariert.  Eine {\bf einfache} Deklarationsanweisung\index{einfache Deklaration} führt eine einzelne Konstante oder Variable ein.  Ihre Syntax ist eine der folgenden:
\begin{center}
  \texttt{\$c} {\em math-symbol} \texttt{\$.}\\
  \texttt{\$v} {\em math-symbol} \texttt{\$.}
\end{center}
Die Notation {\em math-symbol} bedeutet ein beliebiges  Token\index{Token} für ein mathe\-ma\-tisches Symbol.

Einige Beispiele für einfache Anweisungen sind:
\begin{center}
  \texttt{\$c + \$.}\\
  \texttt{\$c -> \$.}\\
  \texttt{\$c ( \$.}\\
  \texttt{\$v x \$.}\\
  \texttt{\$v y2 \$.}
\end{center}

Die Zeichen in einem mathematischen Symbol\index{mathematisches Symbol}, das deklariert wird, sind für Meta\-math irrelevant; zum Beispiel könnten wir eine rechte Klammer als Variable deklarieren,
\begin{center}
  \texttt{\$v ) \$.}\\
\end{center}
obwohl dies unkonventionell wäre.

Die Anweisung {\bf zusammengesetzte} Deklaration\index{zusammengesetzte Deklaration} ist eine Kurzform für die gleichzeitige Deklaration mehrerer Symbole.  Ihre Syntax ist eine der folgenden:
\begin{center}
  \texttt{\$c} {\em math-symbol}\ \,$\cdots$\ {\em math-symbol} \texttt{\$.}\\
  \texttt{\$v} {\em math-symbol}\ \,$\cdots$\ {\em math-symbol} \texttt{\$.}
\end{center}\index{\texttt{\$c}-Anweisung}
Hier bedeutet die Ellipse (\ldots) eine beliebige Anzahl von {\em math-symbol}\,en.

Ein Beispiel für eine zusammengesetzte Deklaration ist:
\begin{center}
  \texttt{\$v x y mu \$.}\\
\end{center}
Dies entspricht den drei einfachen Deklarationsanweisung
\begin{center}
  \texttt{\$v x \$.}\\
  \texttt{\$v y \$.}\\
  \texttt{\$v mu \$.}\\
\end{center}
\index{\texttt{\$v}-Anweisung}

Es gibt bestimmte Regeln dafür, wo in der Datenbasis mathematische Symbole deklariert werden dürfen, welche Abschnitte der Datenbasis von ihnen Kenntnis haben (d.h. wo sie "`aktiv"' sind) und wann sie mehr als einmal deklariert werden dürfen.  Diese werden in Abschnitt~\ref{scoping} und speziell auf S.~\pageref{redeclaration} diskutiert.

\subsection{Die \texttt{\$d}-Anweisung}\label{dollard}
\index{\texttt{\$d}-Anweisung}

Die Anweisung \texttt{\$d} wird als eine {\bf disjunkte Variableneinschränkung} be\-zeich\-net.  Die Syntax der {\bf einfachen} Version dieser Anweisung lautet
\begin{center}
  \texttt{\$d} {\em variable variable} \texttt{\$.},
\end{center}
wobei jede {\em variable} eine zuvor deklarierte Variable ist und die beiden {\em variable}\,n unterschiedlich sind.  (Genauer gesagt muss jede {\em variable} eine {\bf aktive} Variable sein, was bedeutet, dass es eine vorherige \texttt{\$v}-Anweisung geben muss, deren {\bf Gültigkeitsbereich}\index{Gültigkeitsbereich} die \texttt{\$d}-Anweisung einschließt.  Diese Begriffe werden definiert, wenn wir in Abschnitt~\ref{scoping} über Anweisungen mit Gültigkeitsbereich sprechen).

In der gewöhnlichen Mathematik können Formeln auftreten, die wahr sind, wenn die Variablen in ihnen unterschiedlich\index{unterschiedliche Variablen} sind, aber falsch werden, wenn diese Variablen identisch gemacht werden. Zum Beispiel ist die prädikatenlogische Formel $\exists x\,x \neq y$, was bedeutet: "`Für ein gegebenes $y$ existiert ein $x$, das nicht gleich $y$ ist"', in den meisten mathematischen Theorien wahr (nämlich in allen nicht-trivialen Theorien\index{nicht-triviale Theorie}, d.h. solchen mit mehr als einem Individuum, wie z.B. die Arithmetik).  Wenn wir jedoch $y$ durch $x$ ersetzen, erhalten wir $\exists x\,x \neq x$, was immer falsch ist, da es bedeutet, dass "`etwas existiert, das nicht gleich sich selbst ist."'\footnote{Wenn Sie Logiker sind, werden Sie dies als die unzulässige Substitution\index{echte Substitution}\index{Substitution!echte} einer freien Variablen\index{freie Variable} mit einer gebundenen Variablen\index{gebundene Variable} erkennen.  Metamath macht keinen inhärenten Unterschied zwischen freien und gebundenen Variablen; stattdessen lässt man Metamath wissen, welche Substitutionen zulässig sind, indem man \texttt{\$d}-Anweisungen in der richtigen Weise in seinem Axiomensystem verwendet.}\index{freie vs.\ gebundene Variable}  Mit der Anweisung \texttt{\$d} können Sie eine Beschränkung angeben, die die Ersetzung einer Variablen durch eine andere verbietet.  In diesem Fall würden wir die Anweisung
\begin{center}
  \texttt{\$d x y \$.}
\end{center}\index{\texttt{\$d}-Anweisung}
verwenden, um diese Beschränkung zu spezifizieren.

Die Reihenfolge, in der die Variablen in einer \texttt{\$d}-Anweisung erscheinen, ist nicht wichtig.  Wir könnten auch
\begin{center}
  \texttt{\$d y x \$.}
\end{center}
verwenden.

Die Anweisung \texttt{\$d} ist eigentlich noch allgemeiner, wie das "`disjunkt"'\index{disjunkte Variablen} in ihrem Namen vermuten lässt.  Die volle Bedeutung besteht darin, dass bei einer Substitution der beiden Variablen (im Verlauf eines Beweises, der sich auf eine \texttt{\$a}- oder \texttt{\$p}-Anweisung bezieht, die mit der \texttt{\$d}-Anweisung verknüpft ist), die beiden Ausdrücke, die sich aus der Substitution ergeben, keine gemeinsamen Variablen haben dürfen.  Außerdem muss jedes mögliche Paar von Variablen, eine von jedem Ausdruck, in einer \texttt{\$d}-Anweisung enthalten sein, die mit der zu beweisenden Anweisung verbunden ist.  (Diese Anforderung zwingt die zu beweisende Anweisung dazu, die ursprüngliche disjunkte Variableneinschränkung zu "`vererben"').

Nehmen wir zum Beispiel an, dass \texttt{u} eine Variable ist.  Wenn die Beschränkung
\begin{center}
  \texttt{\$d A B \$.}
\end{center}
für ein Theorem angegeben wurde, auf das in einem
Beweis verwendet wird, dürfen wir nicht \texttt{A} durch \mbox{\tt a + u} und
\texttt{B} durch \mbox{\tt b + u} ersetzen, da diese beiden Symbolfolgen die
Variable \texttt{u} gemeinsam haben.  Außerdem, wenn \texttt{a} und \texttt{b} Variablen sind, können wir nicht \texttt{A} durch \texttt{a} und \texttt{B} durch \texttt{b} ersetzen, es sei denn, wir haben auch \texttt{\$d a b} für das zu beweisende Theorem angegeben. Mit anderen Worten, die Eigenschaft von \texttt{\$d}, die mit einem Paar von Variablen verbunden ist, muss nach der Substitution wirksam erhalten bleiben.

Die \texttt{\$d}\index{\texttt{\$d}-Anweisung}-Anweisung bedeutet {\em nicht}, dass die beiden Variablen nicht durch dasselbe ersetzt werden dürfen, wie man zunächst denken könnte.  Wenn man beispielsweise \texttt{A} und \texttt{B} im obigen Beispiel durch identische Symbolsequenzen ersetzt, die nur aus Konstanten bestehen, entsteht kein disjunkter Variablenkonflikt, da die beiden Symbolsequenzen keine Variablen gemeinsam haben (da sie überhaupt keine Variablen haben).  Ebenso tritt kein Konflikt auf, wenn die beiden Variablen in einer Anweisung \texttt{\$d} durch die leere Symbolfolge\index{leere Substitution} ersetzt werden.

Die \texttt{\$d}-Anweisung hat keine direkte Entsprechung in der gewöhnlichen Mathematik: zum Teil deshalb, weil die Variablen\index{Variable} von Metamath nicht wirklich dasselbe sind wie die Variablen\index{Variable!in der gewöhnlichen Mathematik} der gewöhnlichen Mathematik, sondern vielmehr Metavariablen\index{Metavariable}, die sich über gewöhnliche Variablen erstrecken (sowie über andere Arten von Symbolen und Gruppen von Symbolen).  Je nach Situation können wir die Anweisung \texttt{\$d} informell auf verschiedene Weise interpretieren.  Nehmen wir zum Beispiel an, dass \texttt{x} und \texttt{y} Variablen sind, die sich über Zahlen erstrecken (genauer gesagt, dass \texttt{x} und \texttt{y} Metavariablen sind, die sich über Variablen erstrecken, die beliebige Zahlen repräsentieren), und dass \texttt{ph} ($\varphi$) und \texttt{ps} ($\psi$) Variablen (genauer gesagt, Metavariablen) sind, die sich über Formeln erstrecken.  Wir können die folgenden Interpretationen durchführen, die der informellen Sprache der gewöhnlichen Mathematik entsprechen:
\begin{quote}
\begin{tabbing}
\texttt{\$d x y \$.} bedeutet "`\=unter der Voraussetzung, dass $x$ und $y$\\ \>unterschiedliche Variablen sind."'\\
\texttt{\$d x ph \$.} bedeutet "`\=unter der Voraussetzung, dass $x$ nicht in\\ \>$\varphi$ vorkommt."'\\
\texttt{\$d ph ps \$.} bedeutet "`\=unter der Voraussetzung, dass $\varphi$ und $\psi$ \\ \>keine gemeinsamen Variablen haben."'
\end{tabbing}
\end{quote}\index{\texttt{\$d}-Anweisung}

\subsubsection{Zusammengesetzte \texttt{\$d} Anweisungen}

Die {\bf zusammengesetzte} Version der \texttt{\$d}-Anweisung ist eine Kurzform für die Angabe mehrerer Variablen, deren Ersetzungen paarweise disjunkt sein müssen. Ihre Syntax lautet:
\begin{center}
  \texttt{\$d} {\em variable}\ \,$\cdots$\ {\em variable} \texttt{\$.}
\end{center}\index{\texttt{\$d}-Anweisung}
Hier steht {\em variable} für das Token einer zuvor deklarierten Variable (genauer gesagt, einer aktiven Variable) und alle {\em variable}\,n sind unterschiedlich.  Die zusammengesetzte \texttt{\$d}-Anweisung wird von Metamath intern in eine einfache \texttt{\$d}-Anweisung für jedes mögliche Paar von Variablen in der ursprünglichen \texttt{\$d}-Anweisung zerlegt.  Zum Beispiel ist
\begin{center}
  \texttt{\$d w x y z \$.}
\end{center}
gleichbedeutend mit
\begin{center}
  \texttt{\$d w x \$.}\\
  \texttt{\$d w y \$.}\\
  \texttt{\$d w z \$.}\\
  \texttt{\$d x y \$.}\\
  \texttt{\$d x z \$.}\\
  \texttt{\$d y z \$.}
\end{center}

Zwei oder mehr einfache \texttt{\$d}-Anweisungen, die das gleiche Variablenpaar angeben, werden intern zu einer einzigen \texttt{\$d}-Anweisung zusammengefasst.  So ist die Menge der drei Anweisungen
\begin{center}
  \texttt{\$d x y \$.}
  \texttt{\$d x y \$.}
  \texttt{\$d y x \$.}
\end{center}
gleichbedeutend mit
\begin{center}
  \texttt{\$d x y \$.}
\end{center}

In ähnlicher Weise werden bei zusammengesetzten \texttt{\$d}-Anweisungen nach der internen Zerlegung die gemeinsamen Variablenpaare kombiniert.  Zum Beispiel ist die Menge der Anweisungen
\begin{center}
  \texttt{\$d x y A \$.}
  \texttt{\$d x y B \$.}
\end{center}
gleichbedeutend mit
\begin{center}
  \texttt{\$d x y \$.}
  \texttt{\$d x A \$.}
  \texttt{\$d y A \$.}
  \texttt{\$d x y \$.}
  \texttt{\$d x B \$.}
  \texttt{\$d y B \$.}
\end{center}
welches gleichbedeutend ist mit
\begin{center}
  \texttt{\$d x y \$.}
  \texttt{\$d x A \$.}
  \texttt{\$d y A \$.}
  \texttt{\$d x B \$.}
  \texttt{\$d y B \$.}
\end{center}

Metamath\index{Metamath} verifiziert beim Verifizieen eines Beweises automatisch, dass alle \texttt{\$d}-Beschränkungen erfüllt sind.  \texttt{\$d}-Anweisungen werden in Beweisen nie direkt referenziert (deshalb haben sie keine Labels\index{Label}), aber Metamath weiß immer, welche erfüllt sein müssen (d.h. \ aktiv sind) und meldet einen Fehler, wenn eine Verletzung auftritt.

Zur Veranschaulichung, wie Metamath eine fehlende \texttt{\$d}-Anweisung erkennt, betrachten wir das folgende Beispiel aus der Datenbasis \texttt{set.mm}.

\begin{verbatim}
$d x z $.  $d y z $.
$( Theorem to add distinct quantifier to atomic formula. $)
ax5eq $p |- ( x = y -> A. z x = y ) $=...
\end{verbatim}

Diese Aussage benötigt offensichtlich die Bedingung, dass $z$ von $x$ verschieden sein muss in dem Theorem \texttt{ax5eq}, das  $x=y \rightarrow \forall z \, x=y$ besagt (das ist offensichtlich, wenn man Logiker ist, denn sonst könnte man $x=y \rightarrow \forall x \, x=y$ folgern, was falsch ist, wenn die freien Variablen $x$ und $y$ gleich sind).

Schauen wir uns an, was passiert, wenn wir in der Datenbasis diese \texttt{\$d}-Anweisung auszukommentieren.

\begin{verbatim}
$( $d x z $. $) $d y z $.
$( Theorem to add distinct quantifier to atomic formula. $)
ax5eq $p |- ( x = y -> A. z x = y ) $=...
\end{verbatim}

Wenn Metamath versucht, den Beweis zu verifizieren, wird es Ihnen sagen, dass \texttt{x} und \texttt{z} disjunkt sein müssen, weil einer seiner Schritte auf ein Axiom oder Theorem verweist, das diese Bedingung erfüllt.

\begin{verbatim}
MM> verify proof ax5eq
ax5eq ?Error at statement 1918, label "ax5eq", type "$p":
      vz wal wi vx vy vz ax-13 vx vy weq vz vx ax-c16 vx vy
                                               ^^^^^
There is a disjoint variable ($d) violation at proof step 29.
Assertion "ax-c16" requires that variables "x" and "y" be
disjoint.  But "x" was substituted with "z" and "y" was
substituted with "x".  The assertion being proved, "ax5eq",
does not require that variables "z" and "x" be disjoint.
\end{verbatim}

Wir können die Ersetzungen in \texttt{ax-c16} mit dem folgenden Befehl sehen.

\begin{verbatim}
MM> show proof ax5eq / detailed_step 29
Proof step 29:  pm2.61dd.2=ax-c16 $a |- ( A. z z = x -> ( x =
  y -> A. z x = y ) )
This step assigns source "ax-c16" ($a) to target "pm2.61dd.2"
($e).  The source assertion requires the hypotheses "wph"
($f, step 26), "vx" ($f, step 27), and "vy" ($f, step 28).
The parent assertion of the target hypothesis is "pm2.61dd"
($p, step 36).
The source assertion before substitution was:
    ax-c16 $a |- ( A. x x = y -> ( ph -> A. x ph ) )
The following substitutions were made to the source
assertion:
    Variable  Substituted with
     x         z
     y         x
     ph        x = y
The target hypothesis before substitution was:
    pm2.61dd.2 $e |- ( ph -> ch )
The following substitutions were made to the target
hypothesis:
    Variable  Substituted with
     ph        A. z z = x
     ch        ( x = y -> A. z x = y )
\end{verbatim}

Die disjunkten Variableneinschränkungen von \texttt{ax-c16} können mit dem Befehl \texttt{show state\-ment} ermittelt werden.  Die Zeile, die mit "`\texttt{Its mandatory
dis\-joint var\-i\-able pairs are:}\ldots"' beginnt, listet alle Variablenpaare in spitzen Klammern auf.

\begin{verbatim}
MM> show statement ax-c16/full
Statement 3033 is located on line 9338 of the file "set.mm".
"Axiom of Distinct Variables. ..."
  ax-c16 $a |- ( A. x x = y -> ( ph -> A. x ph ) ) $.
Its mandatory hypotheses in RPN order are:
  wph $f wff ph $.
  vx $f setvar x $.
  vy $f setvar y $.
Its mandatory disjoint variable pairs are:  <x,y>
The statement and its hypotheses require the variables:  x y
      ph
The variables it contains are:  x y ph
\end{verbatim}

Da Metamath immer erkennt, wenn \texttt{\$d}\index{\texttt{\$d}-Anweisung}-Anweisungen für einen Beweis benötigt werden, brauchen Sie sich keine Sorgen zu machen, dass Sie vergessen haben, eine entsprechende Anweisung einzufügen; sie kann immer hinzugefügt werden, wenn Sie die obige Fehlermeldung sehen.  Wenn Sie unnötige \texttt{\$d}-Anweisungen einfügen, kann es schlimmstenfalls passieren, dass Ihr Theorem nicht so allgemein ist wie es sein könnte, und dies kann seine spätere Verwendung einschränken.

Andererseits muss man bei der Einführung von Axiomen (\texttt{\$a}\index{\texttt{\$a}-Anweisung}-Anweisun\-gen) sehr vorsichtig sein, um die notwendigen zugehörigen \texttt{\$d}-Anweisungen richtig anzugeben, da Metamath keine Möglichkeit hat zu prüfen, ob die Axiome korrekt sind.  Metamath hätte zum Beispiel keine Kenntnis darüber, dass \texttt{ax-c16}, das wir als ein Axiom der Logik betrachten, zu Widersprüchen führen würde, wenn wir seine zugehörige \texttt{\$d}-Anweisung weglassen.

% This was previously a comment in footnote-sized type, but it can be
% hard to read this much text in a small size.
% As a result, it's been changed to normally-sized text.
\label{nodd}
Sie fragen sich vielleicht, ob es möglich ist, Standardmathematik in der Metamath-Sprache ohne die Anweisung \texttt{\$d}\index{\texttt{\$d}-Anweisung} zu entwickeln, da sie wie ein Ärgernis erscheint, das die Überprüfung von Beweisen erschwert. Die Anweisung \texttt{\$d} wird in bestimmten Teilbereichen der Mathematik wie der Aussagenlogik nicht benötigt.  Dummy-Variablen\index{Dummy-Variable!eliminieren} und die damit verbundenen \texttt{\$d}-Anweisungen lassen sich jedoch in Beweisen in der Standardlogik erster Ordnung sowie in der in \texttt{set.mm} verwendeten Variante nicht vermeiden.  Tatsächlich gibt es keine Obergrenze für die Anzahl der Dummy-Variablen, die in einem Beweis eines Satzes der Logik erster Ordnung mit 3 oder mehr Variablen benötigt werden, wie H.\ Andr{e}ka\index{Andr{\'{e}}ka, H.} \cite{Nemeti} gezeigt hat.  Ein System erster Ordnung, das sie vollständig vermeidet, findet sich in \cite{Megill}\index{Megill, Norman}; der Trick dort besteht einfach darin, die notwendigen Dummy-Variablen bedenkenlos in ein zu beweisendes Theorem einzubetten, so dass sie nicht mehr "`dummy"' sind, und dann das resultierende längere Theorem so zu interpretieren, dass die eingebetteten Dummy-Variablen ignoriert werden.  Falls Sie das interessiert, das System in \texttt{set.mm}, das sich aus \texttt{ax-1} bis \texttt{ax-c14} in \texttt{set.mm} ergibt, und das Entfernen von \texttt{ax-c16} und \texttt{ax-5} erfordert keine \texttt{\$d}-Anweisungen, ist aber logisch vollständig in dem in \cite{Megill} beschriebenen Sinne.  Das bedeutet, dass damit jeder Satz der Logik erster Ordnung bewiesen werden kann, solange wir dem Satz eine Prämisse hinzufügen, das Dummy- und alle anderen Variablen, die unterschiedlich sein müssen, einschließt.  In ähnlicher Weise können Axiome für die Mengenlehre entwickelt werden, die keine disjunkten Variableneinschränkungen erfordern\index{Mengenlehre ohne disjunkte Variableneinschränkungen}, wie unter \url{http://us.metamath.org/mpeuni/mmzfcnd.html} erläutert. Zusammen ermöglichen diese im Prinzip die Entwicklung der gesamten Mathematik unter Metamath ohne eine \texttt{\$d}-Anweisung, während die Länge der resultierenden Theoreme wachsen würde, je mehr Dummy-Variablen in ihren Beweisen benötigt werden.

\subsection{Die \texttt{\$f}- und \texttt{\$e}-Anweisungen}\label{dollaref}
\index{\texttt{\$e}-Anweisung}
\index{\texttt{\$f}-Anweisung}
\index{fließende Hypothese}
\index{essentielle Hypothese}
\index{Variablentyp-Hypothese}
\index{logische Hypothese}
\index{Hypothese}

Metamath kennt zwei Arten von Hypothesen, die \texttt{\$f}\index{\texttt{\$f}-Anweisung}- oder {\bf Variablentyp}-Hypothese und die \texttt{\$e}- oder {\bf logische} Hypothese. \index{\texttt{\$d}-Anweisung}\footnote{Streng genommen handelt es sich bei der \texttt{\$d}-Anweisung auch um eine Hypothese, aber sie wird in einem Beweis nie direkt referenziert, weshalb wir sie eher als Beschränkung denn als Hypothese bezeichnen, um Verwirrung zu vermeiden.  Die Überprüfung auf Verletzungen von \texttt{\$d}-Restriktionen erfolgt automatisch und ist in den Algorithmus zur Überprüfung von Beweisen in Metamath integriert.} Die Buchstaben \texttt{f} und \texttt{e} stehen für "`fließend"' \index{fließende Hypothese} (was in etwa bedeutet, dass sie nur verwendet wird, wenn sie relevant ist) bzw. "`essentiell"' \index{essentielle Hypothese} (was bedeutet, dass sie immer verwendet wird), aus Gründen, die deutlich werden, wenn wir Frames in Abschnitt~\ref{frames} und Gültigkeitsbereiche in Abschnitt~\ref{scoping} besprechen. Die Syntax dieser Anweisungen ist wie folgt:
\begin{center}
  {\em label} \texttt{\$f} {\em typecode} {\em variable} \texttt{\$.}\\
  {\em label} \texttt{\$e} {\em typecode}
      {\em math-symbol}\ \,$\cdots$\ {\em math-symbol} \texttt{\$.}\\
\end{center}
\index{\texttt{\$e}-Anweisung}
\index{\texttt{\$f}-Anweisung}
Eine Hypothese muss ein {\em Label}\index{Label} haben.  Der Ausdruck in einer \texttt{\$e}-Hypothese besteht aus einem Typcode (einem aktiven konstanten mathematischen Symbol), gefolgt von einer Folge von keinem, einem oder mehreren mathematischen Symbolen. Jedes mathematische Symbol (einschließlich {\em constant} und {\em variable}) muss eine zuvor deklarierte Konstante oder Variable sein.  (Außerdem muss jedes mathematische Symbol aktiv sein, was bei der Besprechung von Gültigkeitsbereichsanweisungen in Abschnitt~\ref{scoping} behandelt wird).  Eine \texttt{\$f}-Hypothese wird verwendet, um die Art oder den {\bf Typ}\index{Variablentyp}\index{Typ} einer Variablen zu spezifizieren (wie z.B. "`sei $x$ eine ganze Zahl"'), und eine \texttt{\$e}-Hypothese wird verwendet, um eine logische Wahrheit auszudrücken (wie z.B. "`angenommen $x$ ist prim"'), die festgelegt sein muss, damit eine Behauptung, die sie erfordert, auch wahr ist.

Der Typ einer Variablen muss in einer \texttt{\$f}-Anweisung angegeben sein, bevor sie in einer \texttt{\$e}-, \texttt{\$a}- oder \texttt{\$p}-Anweisung verwendet werden kann.  Es darf nur eine (aktive) \texttt{\$f}-Anweisung für eine bestimmte Variable geben.  ("`Aktiv"' ist in Abschnitt~\ref{scoping} definiert.)

In der gewöhnlichen Mathematik werden Theoreme oft in der Form "`Annahme $P$; dann $Q$"' ausgedrückt, wobei $Q$ eine Aussage ist, die man ableiten kann, wenn man von der Aussage $P$ ausgeht.\index{freie Variable}
\footnote{Eine stärkere Version eines Theorems wie dieses wäre die {\em einzelne} Formel $P\rightarrow Q$ ($P$ impliziert $Q$), aus der die schwächere Version oben durch den Modus ponens in der Logik folgt.  
Wir diskutieren diese stärkere Form hier nicht.  In der schwächeren Form sagen wir nur, dass, wenn wir $P$ beweisen können, wir auch $Q$ beweisen können.  
Wenn $x$ die einzige freie Variable in $P$ und $Q$ ist, ist in der Sprache der Logiker die stärkere Form äquivalent zu $\forall x ( P \rightarrow Q)$ (für alle $x$ impliziert $P$ $Q$), während die schwächere Form äquivalent zu $\forall x P \rightarrow \forall x Q$ ist. Die stärkere Form impliziert die schwächere, aber nicht umgekehrt.  
Um genau zu sein, wird die schwächere Form des Satzes richtigerweise als "`Inferenz"' und nicht als Satz bezeichnet.}
In der Metamath-Sprache würde man die mathematische Aussage $P$ als Hypothese (in diesem Fall eine \texttt{\$e}-Anweisung in der Metamath-Sprache) und die Aussage $Q$ als beweisbare Behauptung (eine \texttt{\$p}-Anweisung in der Metamath-Sprache) ausdrücken.

Hier einige Beispiele für Hypothesen, denen Sie in der Logik und Mengenlehre begegnen könnten:
\begin{center}
	\texttt{stmt1 \$f wff P \$.}\\
	\texttt{stmt2 \$f setvar x \$.}\\
	\texttt{stmt3 \$e |- ( P -> Q ) \$.}
\end{center}
\index{\texttt{\$e}-Anweisung}
\index{\texttt{\$f}-Anweisung}

Informell würde dies lauten: "`Angenommen $P$ sei eine wohlgeformte Formel"', "`Angenommen $x$ sei eine (individuelle) Variable"' und "`Angenommen, wir haben $P \rightarrow Q$ bewiesen."'  Das Drehkreuz-Symbol \,$\vdash$\index{Drehkreuz ({$\,\vdash$})} wird in Logik-Texten häufig verwendet, um anzuzeigen, dass "`ein Beweis existiert für"'.

Zusammengefasst:
\begin{itemize}
\item Eine \texttt{\$f}-Hypothese teilt Metamath den Typ oder die Art seiner Variablen mit. Sie ist vergleichbar mit einer Variablendeklaration in einer Computersprache, die dem Compiler mitteilt, dass eine Variable eine Ganzzahl oder eine Gleitkommazahl ist.
\item Die \texttt{\$e}-Hypothese entspricht dem, was man in der gewöhnlichen Mathematik eine "`Hypothese"' nennt.
\end{itemize}

Bevor eine Behauptung\index{Behauptung} (\texttt{\$a}- oder \texttt{\$p}-Aussage) in einem Beweis referenziert werden kann, müssen alle zugehörigen \texttt{\$f}- und \texttt{\$e}-Hypothesen (d.h. \ jene \texttt{\$e}-Hypothesen, die aktiv sind) erfüllt sein (d.h. durch den Beweis nachgewiesen werden).  Die Bedeutung des Begriffs "`assoziiert"' (den wir in Abschnitt~\ref{frames} als {\bf obligatorisch} bezeichnen werden) wird klar, wenn wir später über Gültigkeitsbereiche sprechen.

Beachten Sie, dass nach jedem \texttt{\$f}-, \texttt{\$e}-, \texttt{\$a}- oder \texttt{\$p}-Token ein \textit{typecode}\index{Typcode} stehen muss. Der Typcode ist eine Konstante, die verwendet wird, um die Typen von Ausdrücken festzulegen. Dies wird deutlicher, wenn wir mehr über Behauptungen (\texttt{\$a}- und \texttt{\$p}-Anweisungen) erfahren. Ein Beispiel kann auch ihren Zweck verdeutlichen. In der Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}%
\index{Metamath Proof Explorer} werden die folgenden Typcodes verwendet:

\begin{itemize}
\item \texttt{wff} :
  Symbol einer wohlgeformten Formel (wff)
  (sprich: "`die folgende Symbolfolge ist eine wff"').
% The *textual* typecode for turnstile is "|-", but when read it's a little
% confusing, so I intentionally display the mathematical symbol here instead
% (I think it's clearer in this context).
\item \texttt{$\vdash$} :
  Drehkreuz (sprich: "`die folgende Symbolfolge ist beweisbar"' oder "`ein Beweis existiert für"').
\item \texttt{setvar} :
  Typ der individuellen Mengenvariable (sprich: "`das Folgende ist eine individuelle Mengenvariable"').   Beachten Sie, dass dies \textit{nicht} der Typ eines beliebigen Mengenausdrucks ist, sondern dazu dient, sicherzustellen, dass nur ein einziges Symbol nach Quantoren wie "`für alle"' ($\forall$) und "`Es gibt ein"' ($\exists$) verwendet wird.
\item \texttt{class} :
  Ein Ausdruck, der ein syntaktisch gültiger Klassenausdruck ist.   Alle gültigen Mengenausdrücke sind auch gültige Klassenausdrücke, daher haben Mengenausdrücke normalerweise den Typcode \texttt{class}.   Verwenden Sie den Typcode \texttt{class} und \textit{nicht} den \texttt{setvar}-Typcode für den Typ von Mengenausdrücken, es sei denn, Sie wollen gezielt eine einzelne Mengenvariable bestimmen.
\end{itemize}

\subsection{Behauptungen (\texttt{\$a}- und \texttt{\$p}-Anweisungen)}
\index{\texttt{\$a}-Anweisung}\index{\texttt{\$p}-Anweisung}\index{Behauptung}\index{axiomatische Behauptung}\index{beweisbare Behauptung}

Es gibt zwei Arten von Behauptungen, \texttt{\$a}\index{\texttt{\$a}-Anweisung}-Anweisungen ({\bf axiomatische Behauptungen}) und \texttt{\$p}-Anweisungen ({\bf beweisbare Behauptungen}).  Ihre Syntax lautet wie folgt:
\begin{center}
  {\em label} \texttt{\$a} {\em typecode} {\em math-symbol} \ldots
         {\em math-symbol} \texttt{\$.}\\
  {\em label} \texttt{\$p} {\em typecode} {\em math-symbol} \ldots
        {\em math-symbol} \texttt{\$=} {\em proof} \texttt{\$.}
\end{center}
\index{\texttt{\$a}-Anweisung}
\index{\texttt{\$p}-Anweisung}
\index{\texttt{\$=} Schlüsselwort}
Eine Behauptung erfordert immer ein {\em Label}\index{Label}. Der Ausdruck in einer Behauptung besteht aus einem Typcode (einer aktiven Konstante), gefolgt von einer Folge von keinem, einem oder mehreren mathematischen Symbolen.  Jedes mathematische Symbol, einschließlich aller {\em Konstanten}, muss eine zuvor deklarierte Konstante oder Variable sein.  (Außerdem muss jedes mathematische Symbol aktiv sein, was bei der Besprechung von Gültigkeitsbereichsanweisungen in Abschnitt~\ref{scoping} behandelt wird).

Eine \texttt{\$a}-Anweisung ist in der Regel eine syntaktische Definition (z. B. wenn $P$ und $Q$ wffs sind, dann ist $(P\to Q)$ auch eine wwf), ein Axiom\index{Axiom} der gewöhnlichen Mathematik (z. B. $x=x$) oder eine Definition\index{Definition} der gewöhnlichen Mathematik (z. B. $x\ne y$ bedeutet $\lnot x=y$). Eine \texttt{\$p}-Anweisung ist eine Behauptung, dass eine bestimmte Kombination von mathematischen Symbolen aus früheren Behauptungen folgt, und wird durch einen Beweis ergänzt, der dies zeigt.

Behauptungen können auch in (späteren) Beweisen referenziert werden, um neue Behauptungen aus ihnen abzuleiten. Das Label einer Behauptung wird verwendet, um in einem Beweis auf sie zu verweisen. In Abschnitt~\ref{proof} wird der Beweis im Detail beschrieben.

Behauptungen sind auch das wichtigste Mittel, um Menschen die mathematischen Ergebnisse in der Datenbasis mitzuteilen.  Beweise (wenn sie in geeigneter Weise angezeigt werden) vermitteln Menschen, wie die Ergebnisse zustande gekommen sind.

\subsubsection{Die \texttt{\$a}-Anweisung}
\index{\texttt{\$a}-Anweisung}

Axiomatische Behauptungen (\texttt{\$a}-Anweisungen) stellen die Ausgangspunkte dar, von denen andere Behauptungen (\texttt{\$p}\index{\texttt{\$p}-Anweisung}-Anweisungen) abgeleitet werden.  Ihr offensichtlichster Verwendungszweck ist die Spezifizierung gewöhnlicher mathematischer Axiome\index{Axiom}, aber sie werden auch für zwei andere Zwecke verwendet.

Zunächst muss Metamath\index{Metamath} die Syntax der Symbolfolgen kennen, die gültige mathematische Aussagen darstellen.  Ein Metamath-Beweis muss viel detaillierter aufgeschlüsselt werden als gewöhnliche mathematische Beweise, an die Sie vielleicht gewöhnt sind (sogar die "`vollständigen"' Beweise der formalen Logik\index{formale Logik}).  Dies ist einer der Faktoren, die Metamath zu einer Allzwecksprache machen, die unabhängig von jedem Logiksystem oder sogar irgendeiner Syntax ist.  Wenn Sie einen Substitution für eine Behauptung als Schritt in einem Beweis durchführen wollen, müssen Sie zuerst beweisen, dass die Substitution syntaktisch korrekt ist (oder, wenn Sie es vorziehen, müssen Sie sie "`konstruieren"'), indem Sie zum Beispiel zeigen, dass der Ausdruck, den Sie für eine wff-Metavariable ersetzen, eine gültige wff ist. Die Anweisung \texttt{\$a}\index{\texttt{\$a}-Anweisung} wird verwendet, um die Kombinationen von Symbolen anzugeben, die als syntaktisch gültig angesehen werden, wie z.B. die legalen Formen von wffs.

Zweitens werden \texttt{\$a}-Anweisungen verwendet, um das zu spezifizieren, was man sich normalerweise als Definitionen vorstellt, d.h. \ neue Kombinationen von Symbolen, die andere Kombinationen von Symbolen abkürzen.  Metamath unterscheidet nicht zwischen Axiomen\index{Axiom} und Definitionen\index{Definition}. In der Tat wurde argumentiert, dass eine solche Unterscheidung nicht einmal in der gewöhnlichen Mathematik gemacht werden sollte; siehe Abschnitt~\ref{definitions}, der die Philosophie der Definitionen diskutiert.  In Abschnitt~\ref{hierarchy} werden einige technische Anforderungen an Definitionen erörtert.  In \texttt{set.mm} übernehmen wir die Konvention, den Labels für Axiome \texttt{ax-} und den Labels für Definitionen \texttt{df-}\index{Label} voranzustellen.

Die Ergebnisse, die mit der Metamath-Sprache abgeleitet werden können, sind nur so gut wie die \texttt{\$a}\index{\texttt{\$a}-Anweisung}-Anweisungen, die als deren Ausgangspunkt verwendet werden.  Wir können dies nicht genug betonen.  Metamath wird Sie zum Beispiel nicht daran hindern, $x\neq x$ als ein Axiom der Logik anzugeben.  Es ist wichtig, dass Sie alle \texttt{\$a}-Anweisungen mit großer Sorgfalt prüfen. Da sie eine Quelle potenzieller Fallstricke sind, ist es am besten, keine neuen (normalerweise neue Definitionen) beiläufig hinzuzufügen; vielmehr sollten Sie die Notwendigkeit und die Vorteile jeder einzelnen sorgfältig bewerten.

Wenn Sie alle grundlegenden Axiome\index{Axiom} und Regeln\index{Regel} einer mathematischen Theorie aufgestellt haben, sind die einzigen \texttt{\$a}-Anweisungen, die Sie hinzufügen werden, die so genannten Definitionen.  Im Prinzip sollten Definitionen in gewissem Sinne aus der Sprache einer Theorie eliminierbar sein, und zwar gemäß einer bestimmten Konvention (die normalerweise logische Äquivalenz oder Gleichheit beinhaltet).  Die gebräuchlichste Konvention ist, dass jede Formel, die vor der Einführung der Definition syntaktisch gültig, aber nicht beweisbar war, nach der Einführung der Definition nicht beweisbar wird.  In einer idealen Welt sollten Definitionen überhaupt nicht vorhanden sein, wenn man absolutes Vertrauen in ein mathematisches Ergebnis haben will.  Sie sind jedoch notwendig, um die Mathematik praktikabel zu machen, da die resultierenden Formeln sonst extrem lang und unverständlich wären.  Da es die Natur von Definitionen (im allgemeinsten Sinne) nicht gestattet, dass sie automatisch als "`zulässig"'\index{zulässige Definition}\index{Definition!zulässig} überprüft werden können, ist das Urteil des Mathematikers erforderlich, um dies sicherzustellen.  (In \texttt{set.mm} wurden Anstrengungen unternommen, um fast alle Definitionen direkt eliminierbar zu machen und so die Notwendigkeit eines solchen Urteils zu minimieren.)

Wenn Sie kein Mathematiker sind, ist es vielleicht am besten, keine \texttt{\$a}\index{\texttt{\$a}-Anweisung}-Anweisungen hinzuzufügen oder zu ändern, sondern stattdessen die mathematische Sprache zu verwenden, die bereits in Standarddatenbasen zur Verfügung gestellt wird.  Auf diese Weise wird Metamath nicht zulassen, dass Sie einen Fehler machen (d.h. ein falsches Ergebnis beweisen).

\subsection{Frames}\label{frames}

Wir führen nun das Konzept einer Sammlung zusammengehöriger Metamath-Anweisungen ein, die als Frame bezeichnet wird.  Jede Behauptung (\texttt{\$a}- oder \texttt{\$p}-Anweisung) in der Datenbasis hat einen zugehörigen Frame.

Ein {\bf Frame}\index{Frame} ist eine Folge von \texttt{\$d}-, \texttt{\$f}- und \texttt{\$e}-Anweisungen (keine, eine oder mehrere von jeder), gefolgt von einer \texttt{\$a}- oder \texttt{\$p}-Anweisung, vorbehaltlich bestimmter, im Folgenden beschriebenen Bedingungen.  Der Einfachheit halber nehmen wir an, dass alle verwendeten Token, die mathematischen Symbole darstellen, am Anfang der Datenbasis mit den Anweisungen \texttt{\$c} und \texttt{\$v} deklariert werden (die eigentlich nicht Teil eines Frames sind).  Der Einfachheit halber nehmen wir auch an, dass es nur einfache \texttt{\$d}-Anweisungen gibt (solche mit nur zwei Variablen) und stellen uns alle zusammengesetzten \texttt{\$d}-Anweisungen (solche mit mehr als zwei Variablen) als in einfache zerlegt vor.

Ein Frame fasst die Hypothesen (und \texttt{\$d}-Anweisungen) zusammen, die für eine Behauptung (\texttt{\$a}- oder \texttt{\$p}-Anweisung) relevant sind.  Die Anweisungen in einem Frame können in einer Datenbasis physisch benachbart sein, müssen es aber nicht; wir werden dies in unserer Diskussion über Gültigkeitsbereichsanweisungen in Abschnitt~\ref{scoping} behandeln.

Ein Frame hat die folgenden Eigenschaften:
\begin{enumerate}
 \item Die Menge der in den Anweisungen von \texttt{\$f} enthaltenen Variablen muss mit der Menge der in seinen \texttt{\$e}-, \texttt{\$a}- und/oder \texttt{\$p}-Anweisungen enthaltenen Variablen identisch sein.  Mit anderen Worten: Für jede Variable in einer \texttt{\$e}-, \texttt{\$a}- oder \texttt{\$p}-Anweisung muss in einer \texttt{\$f}-Anweisung ein zugehöriger "`Variablentyp"' definiert sein.
  \item Keine zwei \texttt{\$f}-Anweisungen dürfen die gleiche Variable enthalten.
  \item Jede \texttt{\$f}-Anweisung muss vor einer \texttt{\$e}-Anweisung stehen, in der ihre Variable vorkommt.
\end{enumerate}

Die erste Eigenschaft bestimmt die Menge der in einem Frame vorkommenden Variablen. Dies sind die {\bf obligatorischen Variablen}\index{obligatorische Variable} des Frames.  Die zweite Eigenschaft besagt, dass für eine Variable nur ein Typ angegeben werden darf. Die letzte Eigenschaft ist keine theoretische Anforderung, aber sie erleichtert das Parsen der Datenbasis.

Für unsere Beispiele gehen wir davon aus, dass unsere Datenbasis die folgenden Deklarationen hat:

\begin{verbatim}
$v P Q R $.
$c -> ( ) |- wff $.
\end{verbatim}

Die folgende Folge von Anweisungen, die die Modus ponens Schlussregel beschreibt, ist ein Beispiel für ein Frame: 

\begin{verbatim}
wp  $f wff P $.
wq  $f wff Q $.
maj $e |- ( P -> Q ) $.
min $e |- P $.
mp  $a |- Q $.
\end{verbatim}

Die folgende Folge von Anweisungen ist kein Frame, da \texttt{R} weder in den \texttt{\$e}'s noch in den \texttt{\$a}'s vorkommt:

\begin{verbatim}
wp  $f wff P $.
wq  $f wff Q $.
wr  $f wff R $.
maj $e |- ( P -> Q ) $.
min $e |- P $.
mp  $a |- Q $.
\end{verbatim}

Die folgende Folge von Anweisungen ist kein Frame, da \texttt{Q} nicht in einem \texttt{\$f} vorkommt:

\begin{verbatim}
wp  $f wff P $.
maj $e |- ( P -> Q ) $.
min $e |- P $.
mp  $a |- Q $.
\end{verbatim}

Die folgende Folge von Anweisungen ist kein Frame, da die Anweisung \texttt{\$a} nicht die letzte ist:

\begin{verbatim}
wp  $f wff P $.
wq  $f wff Q $.
maj $e |- ( P -> Q ) $.
mp  $a |- Q $.
min $e |- P $.
\end{verbatim}

Einem Frame ist eine Folge von {\bf obligatorischen Hypothesen}\index{obligatorische Hypothese} zugeordnet.  Dies ist einfach die Menge aller \texttt{\$f}- und \texttt{\$e}-Anweisungen im Frame, in der Reihenfolge, in der sie angegeben werden.  Auf einen Frame kann in einem späteren Beweis über das Label der \texttt{\$a}- oder \texttt{\$p}-Aussage Bezug genommen werden, und der Beweis nimmt eine Zuordnung zu jeder zwingenden Hypothese in der Reihenfolge vor, in der sie angegeben wurde.  Das bedeutet, dass die einmal gewählte Reihenfolge der Hypothesen nicht mehr geändert werden darf, um spätere Beweise, die sich auf die Anweisung des Frames beziehen, nicht zu beeinflussen.  (Der Beweisverifizierer von Metamath wird natürlich einen Fehler anzeigen, wenn ein Beweis dadurch falsch wird.)  Da Beweise die "`umgekehrte Polnische Notation"' verwenden, die in Abschnitt~\ref{proof} beschrieben wird, nennen wir diese Reihenfolge die {\bf RPN-Reihenfolge}\index{RPN-Reihenfolge} der Hypothesen.

Beachten Sie, dass \texttt{\$d}-Anweisungen nicht zur Menge der obligatorischen Hypothesen gehören und ihre Reihenfolge keine Rolle spielt (solange sie die oben beschriebene vierte Eigenschaft für einen Frame erfüllen).  Die \texttt{\$d}-Anweisungen geben Beschränkungen für Variablen an, die erfüllt sein müssen (und vom Beweisverifizierer überprüft werden), wenn Ausdrücke in einem Beweis für sie ersetzt werden, und die \texttt{\$d}-Anweisungen selbst werden in einem Beweis nie direkt referenziert.

Ein Frame mit einer (beweisbaren) \texttt{\$p}-Anweisung erfordert einen Beweis als Teil der \texttt{\$p}-Anweisung.  Manchmal wollen wir in einem Beweis temporäre Variablen oder Dummy-Variablen verwenden, die nicht in der \texttt{\$p}-Anweisung oder ihren obligatorischen Hypothesen vorkommen.  Um dies zu ermöglichen, definieren wir einen {\bf erweiterten Frame}\index{erweiterter Frame} als einen Frame mit keinem, einem oder mehreren \texttt{\$d}- und \texttt{\$f}-Anweisungen, die auf Variablen verweisen, die nicht zu den obligatorischen Variablen des Frames gehören.  Alle neuen Variablen, auf die verwiesen wird, werden als {\bf optionale Variablen}\index{optionale Variable} des erweiterten Frames bezeichnet. Wenn eine \texttt{\$f}-Anweisung auf eine optionale Variable verweist, wird sie als {\bf optionale Hypothese}\index{optionale Hypothese} bezeichnet, und wenn eine oder beide der Variablen in einer \texttt{\$d}-Anweisung optionale Variablen sind, wird sie als {\bf optionale disjunkte Variableneinschränkung}\index{optionale disjunkte Variableneinschränkung} bezeichnet.  Die Eigenschaften 2 und 3 für einen Frame gelten auch für einen erweiterten Frame.

Das Konzept der optionalen Variablen ist für Frames mit \texttt{\$a}-Anweisungen nicht sinnvoll, da diese Anweisungen keine Beweise haben, die von ihnen Gebrauch machen könnten. Es gibt kein Verbot für die Aufnahme optionaler Hypothesen in den erweiterten Frame für eine \texttt{\$a}-Anweisung, aber sie haben keinen Zweck.

Der folgende Satz von Anweisungen ist ein Beispiel für einen erweiterten Frame, das eine optionale Variable \texttt{R} und eine optionale Hypothese \texttt{wr} enthält.  In diesem Beispiel nehmen wir an, dass der Modus ponens kein Axiom ist, sondern als Theorem aus früheren Aussagen abgeleitet wurde (wir lassen den angenommenen Beweis weg). Die Variable \texttt{R} kann, falls gewünscht, in ihrem Beweis verwendet werden (obwohl dies in der Aussagenlogik wahrscheinlich keinen Vorteil hätte).  Beachten Sie, dass die Reihenfolge der obligatorischen Hypothesen in der RPN-Reihenfolge immer noch \texttt{wp}, \texttt{wq}, \texttt{maj}, \texttt{min} lautet (d.h. \texttt{wr} wird weggelassen), und diese Reihenfolge wird immer noch angenommen, wenn in einem nachfolgenden Beweis auf die Behauptung \texttt{mp} verwiesen wird.

\begin{verbatim}
wp  $f wff P $.
wq  $f wff Q $.
wr  $f wff R $.
maj $e |- ( P -> Q ) $.
min $e |- P $.
mp  $p |- Q $= ... $.
\end{verbatim}

Jeder Frame ist ein erweiterter Frame, aber nicht jeder erweiterte Frame ist ein Frame, wie dieses Beispiel zeigt.  Den zugrundeliegenden Frame für einen erweiterten Frame erhält man, indem man einfach alle Anweisungen entfernt, die optionale Variablen enthalten. Jeder Beweis, der sich auf eine Behauptung bezieht, ignoriert alle Erweiterungen ihres Frames, was bedeutet, dass wir optionale Hypothesen nach Belieben hinzufügen oder löschen können, ohne dass dies Auswirkungen auf nachfolgende Beweise hat. 

Die konzeptionell einfachste Art, eine Metamath-Datenbasis zu organisieren, ist eine Folge von erweiterten Frames.  Die Gültigkeitsbereichsanweisungen \texttt{\$\char`\{}\index{\texttt{\$\char`\{} und \texttt{\$\char`\}} Schlüsselwörter} und \texttt{\$\char`\}} können verwendet werden, um den Anfang und das Ende eines erweiterten Frames abzugrenzen, was zu der folgenden möglichen Struktur für eine Datenbasis führt.  \label{framelist} 

\vskip 2ex
\setbox\startprefix=\hbox{\tt \ \ \ \ \ \ \ \ }
\setbox\contprefix=\hbox{}
\startm
\m{\mbox{(\texttt{\$v-} {\em und} \texttt{\$c-}{\em Anweisungen})}}
\endm
\startm
\m{\mbox{\texttt{\$\char`\{}}}
\endm
\startm
\m{\mbox{\texttt{\ \ } {\em erweiterter Frame}}}
\endm
\startm
\m{\mbox{\texttt{\$\char`\}}}}
\endm
\startm
\m{\mbox{\texttt{\$\char`\{}}}
\endm
\startm
\m{\mbox{\texttt{\ \ } {\em erweiterter Frame}}}
\endm
\startm
\m{\mbox{\texttt{\$\char`\}}}}
\endm
\startm
\m{\mbox{\texttt{\ \ \ \ \ \ \ \ \ }}\vdots}
\endm
\vskip 2ex

In der Praxis ist diese Struktur unzweckmäßig, weil wir alle \texttt{\$f}-, \texttt{\$e}- und \texttt{\$d}-Anweisungen immer und immer wieder wiederholen müssen, anstatt sie einmal für die Verwendung durch mehrere Annahmen anzugeben. Die Gültigkeitsbereichsanweisungen, die wir als nächstes besprechen werden, ermöglichen dies.  Im Prinzip kann jede Metamath-Datenbasis in das obige Format konvertiert werden, und das obige Format ist am bequemsten zu verwenden, wenn man eine Metamath-Datenbasis als formales System betrachtet %
%% Uncomment this when uncommenting section {formalspec} below
   (Appendix \ref{formalspec})%
.
Tatsächlich konvertiert Metamath die Datenbasis intern in das oben genannte Format. Der Befehl \texttt{show statement} im Metamath-Programm zeigt Ihnen den Inhalt des Frames für jede \texttt{\$a}- oder \texttt{\$p}-Anweisung sowie die Erweiterung im Falle einer \texttt{\$p}-Anweisung.

%c%(provided that all "`local"' variables and constants with limited scope have
%c%unique names),

Bei der Diskussion von Anweisungen mit Gültigkeitsbereich kann es hilfreich sein, sich die äquivalente Folge von Frames vorzustellen, die beim Parsen der Datenbasis entsteht.  Gültigkeitsbereiche sind (abgesehen von der oben erwähnten begrenzten Verwendung zur Abgrenzung von Frames) keine theoretische Voraussetzung für Metamath, macht den Umgang damit aber bequemer.

\subsection{Gültigkeitsbereichsanweisungen (\texttt{\$\{} und \texttt{\$\}})}\label{scoping}
\index{\texttt{\$\char`\{} und \texttt{\$\char`\}} Schlüsselwörter}\index{Gültigkeitsbereichsanweisung}

%c%Some Metamath statements may be needed only temporarily to
%c%serve a specific purpose, and after we're done with them we would like to
%c%disregard or ignore them.  For example, when we're finished using a variable,
%c%we might want to
%c%we might want to free up the token\index{Token} used to name it so that the
%c%token can be used for other purposes later on, such as a different kind of
%c%variable or even a constant.  In the terminology of computer programming, we
%c%might want to let some symbol declarations be "`local"' rather than "`global."'
%c%\index{local symbol}\index{global symbol}

Die {\bf Gültigkeitsbereich}-Anweisungen, \texttt{\$\char`\{} ({\bf beginn eines Blocks}) und \texttt{\$\char`\}} ({\bf Ende eines Blocks})\index{Block}, bieten ein Mittel zur Steuerung des Teils einer Datenbasis, in dem bestimmte Anweisungstypen erkannt werden.  Die Syntax einer Gültigkeitsbereichsanweisung ist sehr einfach; sie besteht lediglich aus dem Schlüsselwort der Anweisung: 
\begin{center}
\texttt{\$\char`\{}\\
\texttt{\$\char`\}}
\end{center}
\index{\texttt{\$\char`\{} und \texttt{\$\char`\}} Schlüsselwörter}

Betrachten wir zum Beispiel die folgende Datenbasis, in der wir alle Token außer den Schlüsselwörtern der Anweisung entfernt haben.  Für die folgende Diskussion haben wir die Anweisungen mit Indizes (tiefgestellten Ziffern) versehen; diese Indizes erscheinen nicht in der eigentlichen Datenbasis.
\[
 \mbox{\tt \ \$\char`\{}_1
 \mbox{\tt \ \$\char`\{}_2
 \mbox{\tt \ \$\char`\}}_2
 \mbox{\tt \ \$\char`\{}_3
 \mbox{\tt \ \$\char`\{}_4
 \mbox{\tt \ \$\char`\}}_4
 \mbox{\tt \ \$\char`\}}_3
 \mbox{\tt \ \$\char`\}}_1
\]
Zu jeder \texttt{\$\char`\{}-Anweisung in diesem Beispiel {\bf gehört} die \texttt{\$\char`\}}-Anweisung mit demselben Index.  Jedes Paar von so zusammengehörenden Anweisungen definiert einen Bereich der Datenbasis, der als {\bf Block}\index{Block} bezeichnet wird. Blöcke können innerhalb anderer Blöcke {\bf verschachtelt} werden; im Beispiel, ist der Block, der durch $\mbox{\tt \$\char`\{}_4$ und $\mbox{\tt \$\char`\}}_4$ definiert ist, innerhalb des Blocks verschachtelt, der durch $\mbox{\tt \$\char`\{}_3$ und $\mbox{\tt \$\char`\}}_3$ sowie innerhalb des durch $\mbox{\tt \$\char`\{}_1$ und $\mbox{\tt \$\char`\}}_1$ definierten Blocks.  Im Allgemeinen kann ein Block leer sein, er kann nur Anweisungen enthalten, die keine Gültigkeitsbereichsanweisungen sind\footnote{Die Anweisungen, die nicht \texttt{\$\char`\{} und \texttt{\$\char`\}} sind.} oder er kann eine beliebige Mischung aus anderen Blöcken und Anweisungen, die keine Gültigkeitsbereichsanweisungen sind, enthalten.  (Dies wird eine "`rekursive"' Definition\index{rekursive Definition} eines Blocks genannt.)

Jedem Block ist eine Nummer zugeordnet, die als seine {\bf Verschachtelungstiefe}\index{Verschachtelungstiefe} bezeichnet wird und angibt, wie tief der Block verschachtelt ist. Die Verschachtelungstiefe der Blöcke in unserem Beispiel sind wie folgt:
\[
  \underbrace{
    \mbox{\tt \ }
    \underbrace{
     \mbox{\tt \$\char`\{\ }
     \underbrace{
       \mbox{\tt \$\char`\{\ }
       \mbox{\tt \$\char`\}}
     }_{2}
     \mbox{\tt \ }
     \underbrace{
       \mbox{\tt \$\char`\{\ }
       \underbrace{
         \mbox{\tt \$\char`\{\ }
         \mbox{\tt \$\char`\}}
       }_{3}
       \mbox{\tt \ \$\char`\}}
     }_{2}
     \mbox{\tt \ \$\char`\}}
   }_{1}
   \mbox{\tt \ }
 }_{0}
\]
\index{\texttt{\$\char`\{} und \texttt{\$\char`\}} Schlüsselwörter}
Die gesamte Datenbasis wird als ein einziger großer Block (der äußerste Block) mit einer Verschachtelungstiefe von 0 betrachtet. Der äußerste Block wird nicht durch Gültigkeitsbereichsanweisungen eingeklammert.\footnote{Die Sprache wurde deshalb so konzipiert, damit mehrere Quelldateien leichter zusammengefügt werden können.}\index{äußerster Block}

Alle Metamath-Anweisungen, die unabhängig von einem Gültigkeitsbereich sind, werden ab der Stelle, an der sie angegeben werden, gültig oder {\bf aktiv}\index{aktive Anweisung}.\footnote{Um die Dinge etwas zu vereinfachen, machen wir uns nicht die Mühe, den Begriff "`aktiv"' für die Gültigkeitsbereichsanweisungen zu definieren.}  Bestimmte dieser Anweisungstypen werden am Ende des Blocks, in dem sie enthalten sind, inaktiv; diese Anweisungstypen sind:

\begin{center}
  \texttt{\$c}, \texttt{\$v}, \texttt{\$d}, \texttt{\$e}, und \texttt{\$f}.
%  \texttt{\$v}, \texttt{\$f}, \texttt{\$e}, und \texttt{\$d}.
\end{center}
\index{\texttt{\$c}-Anweisung}
\index{\texttt{\$d}-Anweisung}
\index{\texttt{\$e}-Anweisung}
\index{\texttt{\$f}-Anweisung}
\index{\texttt{\$v}-Anweisung}

Die anderen Anweisungstypen bleiben für immer aktiv (d.h. bis zum Ende der Datenbasis); dies sind:
\begin{center}
  \texttt{\$a} und \texttt{\$p}.
%  \texttt{\$c}, \texttt{\$a}, und \texttt{\$p}.
\end{center}
\index{\texttt{\$a}-Anweisung}
\index{\texttt{\$p}-Anweisung}
Jede Anweisung (dieser 7 Typen), die sich im äußersten Block\index{äußerster Block} befindet, bleibt bis zum Ende der Datenbasis aktiv und ist somit effektiv eine "`globale"' Anweisung.\index{globale Anweisung}

Alle \texttt{\$c}-Anweisungen müssen im äußersten Block platziert werden.  Da sie also immer global sind, könnte man sie als zu beiden oben genannten Kategorien gehörig betrachten.

Der {\bf Gültigkeitsbereich}\index{Gültigkeitsbereich} einer Anweisung ist die Menge der Anweisungen, die sie als aktiv erkennen.

%c%The concept of "`active"' is also defined for math symbols\index{math
%c%symbol}.  Math symbols (constants\index{Konstante} and
%c%variables\index{Variable}) become {\bf active}\index{active
%c%math symbol} in the \texttt{\$c}\index{\texttt{\$c}
%c%statement} and \texttt{\$v}\index{\texttt{\$v}-Anweisung} statements that
%c%declare them.  They become inactive when their declaration statements become
%c%inactive.

Der Begriff "`aktiv"' ist auch für mathematische Symbole\index{mathematisches Symbol} definiert.  Mathematische Symbole (Konstanten\index{Konstante} und Variablen\index{Variable}) werden {\bf aktiv}\index{aktives mathematisches Symbol} in den \texttt{\$c}\index{\texttt{\$c}-Anweisung}-Anweisungen und \texttt{\$v}\index{\texttt{\$v}-Anweisung}-Anweisungen, in den sie deklariert werden. Eine Variable wird inaktiv, wenn ihre Deklarationsanweisung inaktiv wird.  Da alle \texttt{\$c}-Anweisungen im äußersten Block stehen müssen, wird eine Konstante niemals inaktiv, nachdem sie deklariert wurde.

\subsubsection{Umdeklarierung von mathematischen Symbolen}
\index{Umdeklarierung von Symbolen}\label{redeclaration}

%c%A math symbol may not be declared a second time while it is active, but it may
%c%be declared again after it becomes inactive.

Eine Variable kann nicht ein zweites Mal deklariert werden, solange sie aktiv ist, aber sie kann erneut deklariert werden, nachdem sie inaktiv geworden ist.  Auf diese Weise lassen sich auf bequeme Weise "`lokale"' Variablen\index{lokale Variable} einführen, d.h. temporäre Variablen, die im Rahmen einer Behauptung oder eines Beweises verwendet werden können, ohne dass man sie für immer beibehalten muss.  Eine zuvor deklarierte Variable kann nicht neu als Konstante deklariert werden.

Eine Konstante darf nicht neu deklariert werden.  Und, wie oben erwähnt, müssen Konstanten im äußersten Block deklariert werden.

Der Grund dafür, dass Variablen einen begrenzten Gültigkeitsbereich haben können, Konstanten jedoch nicht, liegt darin, dass eine Behauptung (\texttt{\$a}- oder \texttt{\$p}-Anweisung) bis zum Ende der Datenbasis für die Verwendung in Beweisen verfügbar bleibt.  Variablen im Rahmen einer Behauptung können in einem Beweisschritt, der sich auf die Behauptung bezieht, durch alles ersetzt werden, was benötigt wird, während Konstanten fest bleiben und durch nichts ersetzt werden können.  Das spezielle Token, das für eine Variable im Rahmen einer Behauptung verwendet wird, ist irrelevant, wenn die Behauptung in einem Beweis referenziert wird, und es spielt keine Rolle, wenn dieses Token außerhalb des Frames der referenzierten Behauptung nicht verfügbar ist. Konstanten hingegen müssen global festgelegt werden.

Theoretisch ist es nicht notwendig, dass Variablen für begrenzte Bereiche aktiv sind, anstatt global zu sein. Es handelt sich lediglich um eine Annehmlichkeit, die es beispielsweise ermöglicht, sie lokal mit den entsprechenden Deklarationen vom \texttt{\$f} Variablentyp zu gruppieren.

%c%If you declare a math symbol more than once, internally Metamath considers it a
%c%new distinct symbol, even though it has the same name.  If you are unaware of
%c%this, you may find that what you think are correct proofs are incorrectly
%c%rejected as invalid, because Metamath may tell you that a constant you
%c%previously declared does not match a newly declared math symbol with the same
%c%name.  For details on this subtle point, see the Comment on
%c%p.~\pageref{spec4comment}.  This is done purposely to allow temporary
%c%constants to be introduced while developing a subtheory, then allow their math
%c%symbol tokens to be reused later on; in general they will not refer to the
%c%same thing.  In practice, you would not ordinarily reuse the names of
%c%constants because it would tend to be confusing to the reader.  The reuse of
%c%names of variables, on the other hand, is something that is often useful to do
%c%(for example it is done frequently in \texttt{set.mm}).  Since variables in an
%c%assertion referenced in a proof can be substituted as needed to achieve a
%c%symbol match, this is not an issue.

% (This section covers a somewhat advanced topic you may want to skip
% at first reading.)
%
% Under certain circumstances, math symbol\index{mathematisches Symbol}
% tokens\index{Token} may be redeclared (i.e.\ the token
% may appear in more than
% one \texttt{\$c}\index{\texttt{\$c}-Anweisung} or \texttt{\$v}\index{\texttt{\$v}
% statement} statement).  You might want to do this say, to make temporary use
% of a variable name without having to worry about its affect elsewhere,
% somewhat analogous to declaring a local variable in a standard computer
% language.  Understanding what goes on when math symbol tokens are redeclared
% is a little tricky to understand at first, since it requires that we
% distinguish the token itself from the math symbol that it names.  It will help
% if we first take a peek at the internal workings of the
% Metamath\index{Metamath} program.
%
% Metamath reserves a memory location for each occurrence of a
% token\index{Token} in a declaration statement (\texttt{\$c}\index{\texttt{\$c}
% statement} or \texttt{\$v}\index{\texttt{\$v}-Anweisung}).  If a given token appears
% in more than one declaration statement, it will refer to more than one memory
% locations.  A math symbol\index{mathematisches Symbol} may be thought of as being one of
% these memory locations rather than as the token itself.  Only one of the
% memory locations associated with a given token may be active at any one time.
% The math symbol (memory location) that gets looked up when the token appears
% in a non-declaration statement is the one that happens to be active at that
% time.
%
% We now look at the rules for the redeclaration\index{Umdeklarierung von Symbolen}
% of math symbol tokens.
% \begin{itemize}
% \item A math symbol token may not be declared twice in the
% same block.\footnote{While there is no theoretical reason for disallowing
% this, it was decided in the design of Metamath that allowing it would offer no
% advantage and might cause confusion.}
% \item An inactive math symbol may always be
% redeclared.
% \item  An active math symbol may be redeclared in a different (i.e.\
% inner) block\index{Block} from the one it became active in.
% \end{itemize}
%
% When a math symbol token is redeclared, it conceptually refers to a different
% math symbol, just as it would be if it were called a different name.  In
% addition, the original math symbol that it referred to, if it was active,
% temporarily becomes inactive.  At the end of the block in which the
% redeclaration occurred, the new math symbol\index{mathematisches Symbol} becomes
% inactive and the original symbol becomes active again.  This concept is
% illustrated in the following example, where the symbol \texttt{e} is
% ordinarily a constant (say Euler's constant, 2.71828...) but
% temporarily we want to use it as a "`local"' variable, say as a coefficient
% in the equation $a x^4 + b x^3 + c x^2 + d x + e$:
% \[
%   \mbox{\tt \$\char`\{\ \$c e \$.}
%   \underbrace{
%     \ \ldots\ %
%     \mbox{\tt \$\char`\{}\ \ldots\ %
%   }_{\mbox{\rm region A}}
%   \mbox{\tt \$v e \$.}
%   \underbrace{
%     \mbox{\ \ \ \ldots\ \ \ }
%   }_{\mbox{\rm region B}}
%   \mbox{\tt \$\char`\}}
%   \underbrace{
%     \mbox{\ \ \ \ldots\ \ \ }
%   }_{\mbox{\rm region C}}
%   \mbox{\tt \$\char`\}}
% \]
% \index{\texttt{\$\char`\{} and \texttt{\$\char`\}} Schlüsselwörter}
% In region A, the token \texttt{e} refers to a constant.  It is redeclared as a
% variable in region B, and any reference to it in this region will refer to this
% variable.  In region C, the redeclaration becomes inactive, and the original
% declaration becomes active again.  In region C, the token \texttt{x} refers to the
% original constant.
%
% As a practical matter, overuse of math symbol\index{mathematisches Symbol}
% redeclarations\index{Umdeklarierung von Symbolen} can be confusing (even though
% it is well-defined) and is best avoided when possible.  Here are some good
% general guidelines you can follow.  Usually, you should declare all
% constants\index{Konstante} in the outermost block\index{äußerster Block},
% especially if they are general-purpose (such as the token \verb$A.$, meaning
% $\forall$ or "`for all"').  This will make them "`globally"' active (although
% as in the example above local redeclarations will temporarily make them
% inactive.)  Most or all variables\index{Variable}, on the other hand, could be
% declared in inner blocks, so that the token for them can be used later for a
% different type of variable or a constant.  (The names of the variables you
% choose are not used when you refer to an assertion\index{Behauptung} in a
% proof, whereas constants must match exactly.  A locally declared constant will
% not match a globally declared constant in a proof, even if they use the same
% token, because Metamath internally considers them to be different math
% symbols.)  To avoid confusion, you should generally avoid redeclaring active
% variables.  If you must redeclare them, do so at the beginning of a block.
% The temporary declaration of constants in inner blocks might be occasionally
% appropriate when you make use of a temporary definition to prove lemmas
% leading to a main result that does not make direct use of the definition.
% This way, you will not clutter up your database with a large number of
% seldom-used global constant symbols.  You might want to note that while
% inactive constants may not appear directly in an assertion (a \texttt{\$a}\index{\texttt{\$a}
% statement} or \texttt{\$p}\index{\texttt{\$p}-Anweisung}
% statement), they may be indirectly used in the proof of a \texttt{\$p} statement
% so long as they do not appear in the final math symbol sequence constructed by
% the proof.  In the end, you will have to use your best judgment, taking into
% account standard mathematical usage of the symbols as well as consideration
% for the reader of your work.
%
% \subsubsection{Reuse of Labels}\index{reuse of labels}\index{Label}
%
% The \texttt{\$e}\index{\texttt{\$e}-Anweisung}, \texttt{\$f}\index{\texttt{\$f}
% statement}, \texttt{\$a}\index{\texttt{\$a}-Anweisung}, and
% \texttt{\$p}\index{\texttt{\$p}
% statement} statement types require labels, which allow them to be
% referenced later inside proofs.  A label is considered {\bf
% active}\index{active label} when the statement it is associated with is
% active.  The token\index{Token} for a label may be reused
% (redeclared)\index{redeclaration of labels} provided that it is not being used
% for a currently active label.  (Unlike the tokens for math symbols, active
% label tokens may not be redeclared in an inner scope.)  Note that the labels
% of \texttt{\$a} and \texttt{\$p} statements can never be reused after these
% statements appear, because these statements remain active through the end of
% the database.
%
% You might find the reuse of labels a convenient way to have standard names for
% temporary hypotheses, such as \texttt{h1}, \texttt{h2}, etc.  This way you don't have
% to invent unique names for each of them, and in some cases it may be less
% confusing to the reader (although in other cases it might be more confusing, if
% the hypothesis is located far away from the assertion that uses
% it).\footnote{The current implementation requires that all labels, even
% inactive ones, be unique.}

\subsubsection{Zurück zu Frames}\index{Frame- und Gültigkeitsbereichanweisungen}

Nachdem wir nun die Gültigkeitsbereiche behandelt haben, werden wir uns ansehen, wie eine beliebige Metamath-Datenbasis in die einfache Folge von erweiterten Frames konvertiert werden kann, die auf S.~\pageref{framelist} beschrieben ist.  Dies ist auch die Art und Weise, wie Metamath die Datenbasis intern speichert, wenn es die Datenbasisquelle einliest.\label{frameconvert} Die Methode ist einfach.  Zunächst werden alle Konstanten- und Variablendeklarationen (\texttt{\$c} und \texttt{\$v}) in der Datenbasis gesammelt, wobei doppelte Deklarationen derselben Variable in verschiedenen Bereichen ignoriert werden.  Dann setzen wir unsere gesammelten \texttt{\$c}- und \texttt{\$v}-Deklarationen an den Anfang der Datenbasis, so dass ihr Gültigkeitsbereich die gesamte Datenbasis ist.  Als Nächstes bestimmen wir für jede Behauptung in der Datenbasis ihren Frame und ihren erweiterten Frame.  Der erweiterte Frame ist einfach die Sammlung der \texttt{\$f}, \texttt{\$e} und \texttt{\$d}-Anweisungen, die aktiv sind.  Der Frame ist der erweiterte Frame, aus dem alle optionalen Hypothesen entfernt wurden.

Eine äquivalente Formulierung ist, dass der erweiterte Frame einer Behauptung die Sammlung aller \texttt{\$f}-, \texttt{\$e}- und \texttt{\$d}-Anweisungen ist, deren Gültigkeitsbereich die Behauptung umfasst. Die Anweisungen \texttt{\$f} und \texttt{\$e} treten in der Reihenfolge auf, in der sie angegeben werden (die Reihenfolge ist für \texttt{\$d}-Anweisungen irrelevant).

%c%, renaming any
%c%redeclared variables as needed so that all of them have unique names.  (The
%c%exact renaming convention is unimportant.  You might imagine renaming
%c%different declarations of math symbol \texttt{a} as \texttt{a\$1}, \texttt{a\$2}, etc.\
%c%which would prevent any conflicts since \texttt{\$} is not a legal character in a
%c%math symbol token.)

\section{Die Anatomie eines Beweises} \label{proof}
\index{Beweis!Metamath, Beschreibung von}

Jede beweisbare Behauptung (\texttt{\$p}\index{\texttt{\$p}-Anweisung}-Anweisung) in einer Datenbasis muss einen {\bf Beweis}\index{Beweis} enthalten.  Der Beweis befindet sich zwischen den Schlüsselwörtern \texttt{\$=}\index{\texttt{\$=} Schlüsselwort} und \texttt{\$.}\ in der \texttt{\$p}-Anweisung.

In der Metamath-Basissprache\index{grundlegende Sprache} ist ein Beweis eine Folge von Anweisungs-Labels.  Diese Label-Sequenz\index{Label-Sequenz} dient als eine Menge von Anweisungen, die das Metamath-Programm verwendet, um eine Reihe von mathematischen Symbolsequenzen zu konstruieren.  Die Konstruktion muss letztlich zu der Foilge mathematischer Symbole führen, die zwischen den Schlüsselwörtern \texttt{\$p}\index{\texttt{\$p}-Anweisung} und \texttt{\$=}\index{\texttt{\$=} Schlüsselwort} der \texttt{\$p}-Anweisung enthalten ist.  Andernfalls wird das Metamath-Programm beim Verifizieren des Beweises diesen als falsch betrachten und Sie mit einer entsprechenden Fehlermeldung darauf hinweisen.\footnote{Um das Laden zu beschleunigen, verifiziert das Metamath-Programm Beweise nicht automatisch, wenn Sie mit \texttt{read} eine Datenbasis einlesen, es sei denn, Sie verwenden die Option \texttt{/verify}.  Nachdem eine Datenbasis eingelesen wurde, können Sie den Befehl \texttt{verify proof *} verwenden, um Beweise zu verifizieren.}\index{\texttt{verify proof}-Befehl} Jedes Label in einem Beweis {\bf referenziert} seine entsprechende Anweisung\index{Label-Referenz}.

Zu jeder Behauptung \index{Behauptung} (\texttt{\$p}- oder \texttt{\$a}-\index{\texttt{\$a}-Anweisung}Anweisung) gehört eine Reihe von Hypothesen (\texttt{\$f}-\index{\texttt{\$f}-Anweisung} oder \texttt{\$e}-\index{\texttt{\$e}-Anweisung}Anweisungen), die in Bezug auf diese Behauptung aktiv sind.  Einige sind obligatorisch, die anderen sind optional.  Sie sollten sich diese Konzepte bei Bedarf nochmals in Erinnerung rufen.

Jedes Label\index{Label} in einem Beweis muss entweder das Label einer vorhergehenden Behauptung (\texttt{\$a}-\index{\texttt{\$a}-Anweisung} oder \texttt{\$p}-\index{\texttt{\$p}-Anweisung}Anweisung) oder das Label einer aktiven Hypothese (\texttt{\$e}- oder \texttt{\$f}\index{\texttt{\$f}-Anweisung}-Anweisung) der \texttt{\$p}-Anweisung sein, die den Beweis enthält.  Labels für Hypothesen können sowohl auf die obligatorischen als auch auf die optionalen Hypothesen der Anweisung \texttt{\$p} verweisen.

Die Label-Sequenz in einem Beweis spezifiziert eine Konstruktion in {\bf umgekehrter polnischer Notation}\index{umgekehrte polnische Notation (RPN)} (RPN).  Sie sind vielleicht mit RPN vertraut, wenn Sie ältere Hewlett-Packard- oder ähnliche Taschenrechner benutzt haben. In der Analogie zum Taschenrechner ist ein Label einer Hypothese\index{Hypothesenlabel} wie eine Zahl und ein Label für eine Behauptung\index{Behauptungslabel} wie eine Operation (genauer gesagt, eine $n$-äre Operation, wenn die Behauptung $n$ \texttt{\$e}-Hypothesen hat) zu verstehen. Auf einem RPN-Rechner nimmt eine Operation eine oder mehrere vorherige Zahlen in einer Eingabefolge, führt eine Berechnung mit ihnen durch und ersetzt diese Zahlen und sich selbst durch das Ergebnis der Berechnung.  Zum Beispiel ergibt die Eingabefolge $2,3,+$ auf einem RPN-Rechner $5$, und die Eingabefolge $2,3,5,{\times},+$ ergibt $2,15,+$, was $17$ letztendlich ergibt.

Zum Verständnis der RPN-Verarbeitung gehört das Konzept eines {\bf Stapels}\index{Stapel}\index{RPN-Stapel}, den man sich als eine Reihe von temporären Speicherplätzen vorstellen kann, die Zwischenergebnisse enthalten.  Wenn Metamath auf ein Label für eine Hypothese stößt, wird die mathematische Symbolfolge der Hypothese auf den Stapel gelegt oder {bf geschoben}\index{schieben}.  Wenn Metamath auf ein Label für eine Behauptung stößt, ordnet es die obersten Stapel-Einträge den {\em obligatorischen} Hypothesen\index{obligatorische Hypothese} der Behauptung zu, und zwar in der Reihenfolge, in der der oberste Stapel-Eintrag der letzten obligatorischen Hypothese der Behauptung zugeordnet ist.  Anschließend wird ermittelt, welche Substitutionen\index{Substitution!Variable}\index{Variablensubstitution} in den Variablen der obligatorischen Hypothesen der Behauptung vorgenommen werden müssen, damit sie mit den zugehörigen Stapel-Einträgen übereinstimmen.  Dann werden die gleichen Substitutionen in der Behauptung selbst vorgenommen.  Schließlich entfernt Metamath die übereinstimmenden Hypothesen vom Stapel und schiebt die substituierte Behauptung auf den Stapel.

Für den Zweck des Abgleichs der obligatorischen Hypothese mit den obersten Stapel-Einträgen ist es unerheblich, ob eine Hypothese eine \texttt{\$e}- oder \texttt{\$f}-Anweisung ist.  Wichtig ist nur, dass es eine Menge von Substitutionen\footnote{In der Metamath-Spezifikation (Abschnitt~\ref{spec}) wird der Begriff "`Substitution"' im Singular verwendet, um sich auf die Menge der Substitutionen zu beziehen, über die wir hier sprechen.} gibt, die eine Übereinstimmung ermöglichen (und wenn nicht, wird der Beweisverifizierer eine Fehlermeldung ausgeben).  Die Metamath-Sprache ist so spezifiziert, dass, wenn eine Menge von Substitutionen existiert, diese eindeutig ist. Insbesondere die Anforderung, dass jede Variable einen Typ hat, der mit einer Anweisung \texttt{\$f} spezifiziert ist, stellt die Eindeutigkeit sicher.

Wir werden dies anhand eines Beispiels veranschaulichen. Betrachten Sie die folgende Metamath-Quelldatei:
\begin{verbatim}
$c ( ) -> wff $.
$v p q r s $.
wp $f wff p $.
wq $f wff q $.
wr $f wff r $.
ws $f wff s $.
w2 $a wff ( p -> q ) $.
wnew $p wff ( s -> ( r -> p ) ) $= ws wr wp w2 w2 $.
\end{verbatim}
Dieses Metamath-Beispiel zeigt die Definition und den Beweis (d.h. die Konstruktion) einer wohlgeformten Formel (wff)\index{wohlgeformte Formel (wff)} in der Aussagenlogik.  (Vielleicht möchten Sie dieses Beispiel in eine Datei eingeben, um mit dem Metamath-Programm zu experimentieren.)  Die ersten beiden Anweisungen deklarieren (führen die Namen ein von) vier Konstanten und vier Variablen.  Die nächsten vier Anweisungen spezifizieren die Variablentypen, nämlich dass jede Variable für eine wff steht.  Die Anweisung \texttt{w2} definiert (postuliert) eine Möglichkeit, um aus zwei gegebenen wffs \texttt{p} und \texttt{q} eine neue wff, \texttt{( p -> q )}, zu erzeugen. Die obligatorischen Hypothesen von \texttt{w2} sind \texttt{wp} und \texttt{wq}. Die Anweisung \texttt{wnew} behauptet, dass \texttt{( s -> ( r -> p ) )} eine wff ist, wenn drei wff \texttt{s}, \texttt{r} und \texttt{p} gegeben sind.  Genauer gesagt behauptet \texttt{wnew}, dass die Folge von zehn Symbolen \texttt{wff ( s -> ( r -> p ) )} aus früheren Behauptungen und den Hypothesen von \texttt{wnew} beweisbar ist.  Metamath weiß nicht oder kümmert sich nicht darum, was eine wff ist, und soweit es sie betrifft, ist der Typcode \texttt{wff} einfach ein beliebiges konstantes Symbol in einer mathematischen Symbolfolge.  Die obligatorischen Hypothesen von \texttt{wnew} sind \texttt{wp}, \texttt{wr}, und \texttt{ws}; \texttt{wq} ist eine optionale Hypothese.  In unserem speziellen Beweis wird die optionale Hypothese nicht referenziert, aber im Allgemeinen könnte jede Kombination von aktiven (d.h. optionalen und obligatorischen) Hypothesen referenziert werden.  Der Beweis der Anweisung \texttt{wnew} ist die Folge von fünf Labels, die mit \texttt{ws} (Schritt~1) beginnt und mit \texttt{w2} (Schritt~5) endet.

Wenn Metamath den Beweis verifiziert, scannt es den Beweis von links nach rechts.  Wir werden untersuchen, was bei jedem Schritt des Beweises passiert.  Der Stapel ist zu Beginn leer.  In Schritt 1 sucht Metamath nach dem Label \texttt{ws} und stellt fest, dass es sich um eine Hypothese handelt, also schiebt es die Symbolfolge der Anweisung \texttt{ws} auf den Stapel:

\begin{center}\begin{tabular}{|l|l|}\hline
{Stapelposition} & {Inhalt} \\ \hline \hline
1 & \texttt{wff s} \\ \hline
\end{tabular}\end{center}

Metamath sieht, dass die Labels \texttt{wr} und \texttt{wp} in den Schritten~2 und 3 ebenfalls Hypothesen sind, also schiebt es sie auf den Stapel.  Nach Schritt~3 sieht der Stapel wie folgt aus:

\begin{center}\begin{tabular}{|l|l|}\hline
{Stapelposition} & {Inhalt} \\ \hline \hline
3 & \texttt{wff p} \\ \hline
2 & \texttt{wff r} \\ \hline
1 & \texttt{wff s} \\ \hline
\end{tabular}\end{center}

In Schritt 4 sieht Metamath, dass das Label \texttt{w2} eine Behauptung ist, also muss es etwas verarbeiten.  Zunächst werden die obligatorischen Hypothesen von \texttt{w2}, nämlich \texttt{wp} und \texttt{wq}, mit den Stapelpositionen~2 und 3 verknüpft, {\em in dieser Reihenfolge}. Metamath stellt fest, dass die einzige Möglichkeit, die Hypothese \texttt{wp} mit dem Inhalt auf Stapelposition~2 und \texttt{wq} mit dem Inhalt auf Stapelposition 3 übereinstimmen zu lassen, darin besteht, die Variable \texttt{p} durch \texttt{r} und \texttt{q} durch \texttt{p} zu ersetzen.  Metamath nimmt diese Substitutionen in \texttt{w2} vor und erhält die Symbolfolge \texttt{wff ( r -> p )}.  Es entfernt die Hypothesen von den Stapelpositionen 2 und 3 und legt das Ergebnis auf der Stapelposition 2 ab:

\begin{center}\begin{tabular}{|l|l|}\hline
{Stapelposition} & {Inhalt} \\ \hline \hline
2 & \texttt{wff ( r -> p )} \\ \hline
1 & \texttt{wff s} \\ \hline
\end{tabular}\end{center}

In Schritt 5 sieht Metamath, dass das Label \texttt{w2} eine Behauptung ist, also muss wieder eine Verarbeitung stattfinden.  Zunächst werden die obligatorischen Hypothesen von \texttt{w2}, d.h. \texttt{wp} und \texttt{wq}, den Stapelpositionen 1 und 2 zugeordnet. Metamath stellt fest, dass die einzige Möglichkeit, die Hypothesen zur Übereinstimmung zu bringen, darin besteht, die Variable \texttt{p} durch \texttt{s} und \texttt{q} durch \texttt{( r -> p )} zu ersetzen.  Metamath führt diese Substitutionen in \texttt{w2} durch und erhält die Symbolfolge \texttt{wff ( s -> ( r -> p ) )}.  Es entfernt die Stapelposition 1 und 2 und legt das Ergebnis auf Stapelposition~1 ab:

\begin{center}\begin{tabular}{|l|l|}\hline
{Stapelposition} & {Inhalt} \\ \hline \hline
1 & \texttt{wff ( s -> ( r -> p ) )} \\ \hline
\end{tabular}\end{center}

Nachdem Metamath die Verarbeitung des Beweises abgeschlossen hat\footnote{Anm. der Übersetzer: Da der Beweis kein weiteres Label enthält.}, prüft es, ob der Stapel genau ein Element enthält und ob dieses Element mit der mathematischen Symbolfolge in der \texttt{\$p}\index{\texttt{\$p}-Anweisung}-Anweisung übereinstimmt.  Dies ist bei unserem Beweis von \texttt{wnew} der Fall, also haben wir \texttt{wnew} erfolgreich bewiesen.  Wenn das Ergebnis davon abweicht, wird Metamath Sie mit einer Fehlermeldung informieren.  Eine Fehlermeldung wird auch ausgegeben, wenn der Stapel am Ende des Beweises mehr als einen Eintrag enthält, oder wenn der Stapel an irgendeiner Stelle des Beweises nicht genügend Einträge enthält, um alle obligatorischen Hypothesen\index{obligatorische Hypothese} einer Behauptung zu erfüllen.  Schließlich wird Metamath Sie mit einer Fehlermeldung benachrichtigen, wenn keine Substitution möglich ist, die die Hypothese einer referenzierten Behauptung mit den Stapeleinträgen übereinstimmen lässt.  Sie können mit den verschiedenen Arten von Fehlern, die Metamath erkennt, experimentieren, indem Sie einige kleine Änderungen am Beweis unseres Beispiels vornehmen. 

Die Notation von Metamath für Beweise wurde in erster Linie entwickelt, um Beweise in einer relativ kompakten Weise auszudrücken, nicht um sie für Menschen lesbar zu machen.  Metamath kann Beweise mit dem Befehl \texttt{show proof}\index{\texttt{show proof}-Befehl} auf verschiedene Arten anzeigen.  Die Option \texttt{/lemmon} zeigt sie in einem Format an, das leichter zu lesen ist, wenn die Beweise kurz sind, und Sie haben Beispiele für seine Verwendung in Kapitel~\ref{using} gesehen.  Bei längeren Beweisen ist es nützlich, die Baumstruktur des Beweises zu sehen.  Eine Baumstruktur wird angezeigt, wenn die Option \texttt{/lemmon} weggelassen wird.  Wenn Sie sich an diese Darstellung gewöhnt haben, werden Sie sie wahrscheinlich bequemer finden. Die Baumdarstellung des Beweises in unserem Beispiel sieht wie folgt aus:\label{treeproof}\index{Baumdarstellung eines Beweises}\index{Beweis!Baumdarstellung}

\begin{verbatim}
1     wp=ws    $f wff s
2        wp=wr    $f wff r
3        wq=wp    $f wff p
4     wq=w2    $a wff ( r -> p )
5  wnew=w2  $a wff ( s -> ( r -> p ) )
\end{verbatim}

Die Zahl links von jeder Zeile ist die Schrittnummer.  Es folgt eine {\bf Hypothesenzuordnung}\index{Hypothesenzuordnung}, bestehend aus zwei Labels\index{Label}, die durch \texttt{=} getrennt sind.  Links von \texttt{=} steht (außer im letzten Schritt) das Label einer Hypothese einer Behauptung, auf die später im Beweis Bezug genommen wird; hier sind die Schritte 1 und 4 die Hypothesenzuordnungen für die Behauptung \texttt{w2}, auf die in Schritt 5 Bezug genommen wird.  Eine Hypothesenzuordnung ist eine Stufe weiter eingerückt als die Behauptung, die sie verwendet. Dadurch ist es einfach, die entsprechende Behauptung zu finden, indem man sich direkt nach unten bewegt, bis die Einrückungsstufe um eine Stufe niedriger ist als die, von der aus man begonnen hat.  Rechts von jedem \texttt{=} befindet sich das Label des Beweisschritts für diesen Schritt.  Das Schlüsselwort der Anweisung im Label des Beweisschritts wird als nächstes aufgeführt, gefolgt vom Inhalt des obersten Stapeleintrags (dem neusten Stapeleintrag), wie er nach der Verarbeitung dieses Beweisschritts vorliegt.  Mit ein wenig Übung sollten Sie keine Probleme haben, Beweise in diesem Format zu lesen.

Metamath-Beweise beinhalten die Syntaxkonstruktion einer Formel. In der Standardmathematik wird diese Art der Konstruktion nicht als Teil des Beweises angesehen, und sie wird nach einer Weile sicherlich ziemlich langweilig. Daher zeigt der Befehl \texttt{show proof}\index{\texttt{show proof}-Befehl} standardmäßig die Syntaxkonstruktion nicht an.
Früher \textit{zeigte} der Befehl \texttt{show proof} die Syntaxkonstruktionen an, und man musste die Option 
\texttt{/essential} hinzufügen, um sie auszublenden, aber heute ist 
\texttt{/essential} der Standard, und man muss 
\texttt{/all} verwenden, um die Syntaxkonstruktionen zu sehen.

Bei der Überprüfung eines Beweises prüft Metamath, dass keine obligatorische \texttt{\$d}\index{\texttt{\$d}-Anweisung}\index{obligatorische \texttt{\$d}-Anweisung}-Anweisung einer Behauptung, auf die in einem Beweis verwiesen wird, verletzt wird, wenn Substitutionen\index{Substitution!Variable}\index{Variablensubstitution} an den Variablen in der Behauptung vorgenommen werden.  Für Einzelheiten siehe Abschnitt~\ref{spec4} oder \ref{dollard}.

\subsection{Das Konzept der Vereinheitlichung} \label{unify}

Wenn Metamath\index{Metamath} während der Überprüfung eines Beweises auf ein Label einer Behauptung\index{Behauptungslabel} stößt, assoziiert es die obligatorischen Hypothesen\index{obligatorische Hypothese} der Behauptung mit den obersten Einträgen des RPN-Stapels\index{Stapel}\index{RPN-Stapel}.  Metamath bestimmt dann, welche Substitutionen\index{Substitution!Variable}\index{Variablensubstitution} es an den Variablen in den obligatorischen Hypothesen der Behauptung vornehmen muss, damit diese Hypothesen mit ihren entsprechenden Stapeleinträgen korrespondieren.  Dieser Vorgang wird als {\bf Vereinheitlichung}\index{Vereinheitlichung} bezeichnet.  (Wir verwenden den Begriff "`Vereinheitlichung"' auch informell, um eine Reihe von Substitutionen zu bezeichnen, die sich aus diesem Prozess ergeben, wie in "`zwei Vereinheitlichungen sind möglich"').  Nachdem die Substitutionen vorgenommen wurden, werden die Hypothesen als {\bf vereinheitlicht} bezeichnet.

Ist eine solche Ersetzung nicht möglich, hält Metamath den Beweis für fehlerhaft und gibt eine Fehlermeldung aus.
% (deleted 3/10/07, per suggestion of Mel O'Cat:)
% The syntax of the
% Metamath language ensures that if a set of substitutions exists, it
% will be unique.

Der in der Literatur beschriebene allgemeine Algorithmus für eine Vereinheitlichung ist etwas komplex. Im Fall von Metamath ist er jedoch absichtlich einfach gehalten. Obligatorische Hypothesen müssen in der Reihenfolge ihres Auftretens auf den Beweisstapel geschoben werden. Darüber hinaus muss der Typ jeder Variablen mit einer \texttt{\$f}-Hypothese spezifiziert werden, bevor sie verwendet wird, und jede \texttt{\$f}-Hypothese muss die eingeschränkte Syntax eines Typcodes (einer Konstanten) gefolgt von einer Variablen aufweisen. Der Typcode in der \texttt{\$f}-Hypothese muss mit dem ersten Symbol des entsprechenden RPN-Stack-Eintrags übereinstimmen (der ebenfalls eine Konstante ist), so dass die einzige mögliche Übereinstimmung für die Variable in der \texttt{\$f}-Hypothese die Folge von Symbolen im Stapeleintrag nach der anfänglichen Konstanten ist. 

Im Beweis-Assistenten\index{Beweis-Assistent} wird ein allgemeinerer Vereinheitlichungsalgorithmus verwendet.  Während ein Beweis entwickelt wird, sind manchmal nicht genügend Informationen verfügbar, um eine eindeutige Vereinheitlichung zu bestimmen.  In diesem Fall bittet Metamath Sie, die richtige zu wählen.\index{mehrdeutige Vereinheitlichung}\index{Vereinheitlichung!mehrdeutig} 

\section{Erweiterungen der Metamath-Sprache}\index{erweiterte Sprache}

\subsection{Kommentare in der Metamath-Sprache}\label{comments}
\index{Auszeichnungsnotation}
\index{Kommentar!Auszeichnungsnotation}

Die Kommentarfunktion ermöglicht es Ihnen, den Inhalt einer Datenbasis mit Anmerkungen zu versehen.  Wie bei den meisten Computersprachen werden Kommentare bei der Interpretation des Inhalts der Datenbasis ignoriert. Kommentare fungieren beim Parsen einer Datenbasis effektiv als zusätzlicher Whitespace\index{Whitespace} zwischen den Token.

Ein Kommentar kann am Anfang, am Ende oder zwischen zwei beliebigen Token\index{Token} in einer Quelldatei stehen.

Kommentare haben die folgende Syntax:
\begin{center}
 \texttt{\$(} {\em text} \texttt{\$)}
\end{center}
Hier ist \index{\texttt{\$(} und \texttt{\$)} Hilfsschlüsselwörter}\index{Kommentar} {\em text} eine, möglicherweise leere, Zeichenkette aus beliebigen Zeichen des Metamath-Zeichensatzes (p.~\pageref{spec1chars}), mit der Ausnahme, dass die Zeichenketten \texttt{\$(} und \texttt{\$)} nicht in {\em text} vorkommen dürfen.  Daher sind verschachtelte Kommentare nicht erlaubt:\footnote{Computersprachen haben unterschiedliche Standards für verschachtelte Kommentare, und anstatt sich für einen zu entscheiden, ist es am einfachsten, sie überhaupt nicht zu erlauben, zumindest in der aktuellen Version (0.177) von Metamath\index{Metamath!Limitationen der Version 0.177}.} Metamath wird sich beschweren, wenn
\begin{center}
  \texttt{\$( This is a \$( nested \$) comment.\ \$)}
 \end{center} 
 in einer Datenbasis vorkommt. Um diese fehlende Verschachtelungsmöglichkeit zu kompensieren, ändere ich oft alle \texttt{\$}'s in \texttt{@}'s in Abschnitten des Metamath-Codes, die ich auskommentieren möchte.

Das Metamath-Programm unterstützt eine Reihe von Auszeichnungsmechanismen und Konventionen, um gut aussehende Ergebnisse in \LaTeX\ und {\sc html} zu generieren, wie unten beschrieben wird. Diese Auszeichnungsfunktionen haben ausschließlich damit zu tun, wie die Kommentare ausgegeben werden, und haben keinen Einfluss darauf, wie Metamath die Beweise in der Datenbasis verifiziert. Ihre unsachgemäße Verwendung kann zu einer falsch angezeigten Ausgabe führen, aber es werden keine Metamath-Fehlermeldungen bei den Befehlen \texttt{read} und \texttt{verify proof} ausgegeben.  (Der Befehl \texttt{write theorem\texttt{\char`\_}list} prüft jedoch als Nebeneffekt seiner {\sc html}-Generierung auf Auszeichnungsfehler.) Abschnitt~\ref{texout} enthält Anweisungen zur Erstellung von \LaTeX-Ausgaben, und Abschnitt~\ref{htmlout} enthält Anweisungen zur Erstellung von {\sc html}\index{HTML}-Ausgaben.

\subsubsection{Überschriften}\label{commentheadings}

Wenn unmittelbar nach dem \texttt{\$(} eine neue Zeile folgt, die mit einer Kennzeichnung für Überschriften beginnt, handelt es sich um eine Überschrift. Diese kann beginnen mit:

\begin{itemize}
 \item[] \texttt{\#\#\#\#} - Hauptteilüberschrift
 \item[] \texttt{\#*\#*} - Abschnittsüberschrift
 \item[] \texttt{=-=-} - Unterabschnittsüberschrift
 \item[] \texttt{-.-.} - Unterunterabschnittsüberschrift
\end{itemize}

Die auf die Zeile mit der Kennzeichnung folgende Zeile wird nach dem Abschneiden der Leerzeichen für den Eintrag im Inhaltsverzeichnisses verwendet. Die nächste Zeile sollte eine weitere Zeile mit einer (abschließenden) passenden Kennzeichnung sein. Jeglicher Text danach, aber vor dem abschließenden \texttt{\$}, wird in die Seite \texttt{mmtheoremsNNN.html} aufgenommen. Dies kann  z. B. eine ausführliche Beschreibung des Abschnitts sein.

Weitere Informationen erhalten Sie, wenn Sie \texttt{help write theorem\char`\_list} ausführen.

\subsubsection{Mathe-Modus}
\label{mathcomments}
\index{\texttt{`} innerhalb von Kommentaren}
\index{\texttt{\char`\~} innerhalb von Kommentaren}
\index{Mathe-Modus}

Innerhalb von Kommentaren wird eine Zeichenkette von Token\index{Token}, die von einfachen Anführungszeichen\index{einfache Anführungszeichen (\texttt{`})} (\texttt{`}) eingeschlossen ist, während des {\sc HTML}\index{HTML} oder \LaTeX-Ausgabesatzes in standardmäßige mathematische Symbole umgewandelt, \index{latex@{\LaTeX}} entsprechend den Informationen in der speziellen \texttt{\$t}\index{\texttt{\$t}-Anweisung}\index{Schriftsatzanweisung}  in der Datenbasis (siehe Abschnitt~\ref{tcomment} für Informationen über den Schriftsatzkommentar und Anhang~\ref{ASCII} für Beispiele seiner Ergebnisse).

Das erste einfache Anführungszeichen \index{einfache Anführungszeichen (\texttt{`})} \texttt{`} veranlasst den Ausgabeprozessor, in den {\bf Mathe-Modus}\index{Mathe-Modus} einzutreten, und der zweite verlässt ihn. In diesem Modus werden die auf \texttt{`} folgenden Zeichen als eine Folge von mathematischen Symbolen interpretiert, die durch Whitespace getrennt sind.  Die Zeichen werden in dem \texttt{\$t}-Kommentar \index{\texttt{\$t}-Anweisung}\index{Schriftsatzanweisung} gesucht und, wenn sie gefunden werden, durch die mathematischen Standardsymbole ersetzt, denen sie entsprechen, bevor sie in die Ausgabedatei geschrieben werden.  Werden sie nicht gefunden, wird das Symbol so ausgegeben, wie es ist, und es wird eine Warnung ausgegeben. Die Token müssen nicht in der Datenbasis aktiv sein, obwohl eine Warnung ausgegeben wird, wenn sie nicht mit den Anweisungen \texttt{\$c} oder \texttt{\$v} deklariert sind.

Zwei aufeinanderfolgende einfache Anführungszeichen \texttt{"`} werden als ein einziges einfaches Anführungszeichen ausgegeben (sowohl innerhalb als auch außerhalb des Mathe-Modus) und führen nicht dazu, dass der Ausgabeprozessor in den Mathe-Modus eintritt oder diesen verlässt.

Hier ist ein Beispiel für seine Anwendung\index{Pierces Axiom}:
\begin{center}
\texttt{\$( Pierce's axiom, ` ( ( ph -> ps ) -> ph ) -> ph ` ,\\
         is not very intuitive. \$)}
\end{center}
wird ausgegeben als
\begin{center}
   \texttt{\$(} Pierce's axiom, $((\varphi \rightarrow \psi)\rightarrow
\varphi)\rightarrow \varphi$, is not very intuitive. \texttt{\$)}
\end{center}

Beachten Sie, dass das mathematische Symbol\index{Token} von Whitespace\index{Whitespace} umgeben sein muss.
%, since there is no context that allows ambiguity to be
%resolved, as is the case with math symbol sequences in some of the Metamath
%statements.
Whitespace sollte auch die Begrenzungszeichen \texttt{`} umgeben.

Die Funktion "`Mathe-Modus"' bietet Ihnen auch eine schnelle und einfache Möglichkeit, Text mit mathematischen Symbolen zu erzeugen, unabhängig vom Verwendungszweck von Metamath.\index{Metamath!Verwendung als Mathe-Editor} Dazu erstellen Sie einfach Ihren Text mit einfachen Anführungszeichen, die Ihre Formeln umgeben, nachdem Sie sichergestellt haben, dass Ihre mathematischen Symbole auf \LaTeX-Symbole abgebildet sind, wie in Anhang~\ref{ASCII} beschrieben.  Es ist einfacher, wenn Sie mit einer Datenbasis mit vordefinierten Symbolen wie \texttt{set.mm} beginnen.  Ersetzen Sie einen vorhandenen Kommentar durch eine mathematische Zeichenkette in einfachen Anführungszeichen und setzen Sie dann die diesem Kommentar entsprechende Anweisung gemäß den Anweisungen des Befehls \texttt{help tex} im Metamath-Programm.  Sie werden dann wahrscheinlich die resultierende Datei mit einem Texteditor bearbeiten wollen, um sie genau auf Ihre Bedürfnisse abzustimmen.

\subsubsection{Label-Modus}\index{Label-Modus}

Außerhalb des Mathe-Modus zeigt eine Tilde\index{Tilde (\texttt{\char`\~})} \verb/~/ dem Ausgabeprozessor von Metamath\index{Metamath} an, dass das folgende Token\index{Token} (d.h. die Zeichen bis zum nächsten Whitespace\index{Whitespace}) ein Label oder eine URL darstellt. Dieser Formatierungsmodus wird als {\bf Label-Modus}\index{Label-Modus} bezeichnet. Wenn anstelle des Label-Modus tatsächlich eine Tilde ausgegeben werden soll (außerhalb des Mathe-Modus), verwenden Sie zwei Tilden in einer Reihe, um sie darzustellen.

Bei der Erzeugung einer \LaTeX-Ausgabedatei wird das folgende Token in der Schriftart \texttt{typewriter} formatiert und die Tilde entfernt, damit es sich vom restlichen Text abhebt. Diese Formatierung wird auf alle Zeichen nach der Tilde bis zum ersten Whitespace\index{Whitespace} angewendet. Es wird nicht geprüft, ob es sich bei dem Token um ein Label für eine Anweisung handelt oder nicht, und das Token muss nicht die korrekte Syntax für ein Label haben; es werden keine Fehlermeldungen ausgegeben.  Die einzige Auswirkung des Label-Modus auf die Ausgabe ist, dass für die Token, die in die Ausgabedatei \LaTeX\ eingefügt werden, eine Schreibmaschinenschrift verwendet wird.

Bei der Erzeugung von {\sc html} {\em müssen} die Token nach der Tilde eine URL (entweder http: oder https:) oder ein gültiges Label sein. Ist dies nicht der Fall, werden bei der Ausgabe Fehlermeldungen ausgegeben. Es wird ein Hyperlink zu dieser URL oder diesem Label erzeugt.

\subsubsection{Querverweis zum Literaturverzeichnis}\index{Zitierungen}%
\index{Querverweis zu Literaturangaben}

Querverweis zum Literaturverzeichnis werden bei der Erstellung von {\sc html} besonders behandelt, wenn sie speziell formatiert sind. Text in der Form \texttt{[}{\em author}\texttt{]} wird als Querverweis zum Literaturverzeichnis betrachtet. Siehe \texttt{help html} und \texttt{help write bibliography} im Metamath-Programm für weitere Informationen. 
% \index{\texttt{\char`\[}\ldots\texttt{]} innerhalb von Kommentaren}
Siehe auch Abschnitte~\ref{tcomment} und \ref{wrbib}.

Die Notation \texttt{[}{\em author}\texttt{]} erzeugt auch einen Eintrag in der Datei für das Literaturverzeichnis, die von \texttt{write bibliography} (Abschnitt~\ref{wrbib}) für {\sc HTML} erzeugt wird. Damit dies richtig funktioniert, muss der umgebende Kommentar wie folgt formatiert sein:
\begin{quote}
    {\em keyword} {\em label} {\em noise-word}
     \texttt{[}{\em author}\texttt{] p.} {\em number}
\end{quote}
zum Beispiel
\begin{verbatim}
     Theorem 5.2 von [Monk] S. 223
\end{verbatim}
Beim {\em keyword} wird nicht zwischen Groß- und Kleinschreibung unterschieden, und es muss einer der folgenden Begriffe verwendet werden\footnote{Anm. der Übersetzer: angepasst an Metamath - Version 0.198 7-Aug-2021}:
\begin{verbatim}    
     Axiom Chapter Claim Compare Conclusion Condition
     Conjecture Corollary Definition Equation Example
     Exercise Fact Figure Introduction Item Lemma Lemmas
     Line Lines Notation Note Observation Paragraph Part
     Postulate Problem Proof Property Proposition Remark
     Result Rule Scheme Scolia Scolion Section Statement
     Subsection Table Theorem
\end{verbatim}
Das optionale {\em label} kann aus mehr als einem Wort (nicht {\em keyword} und nicht {\em noise-word}) bestehen. Das optionale {\em noise-word} ist eines der folgenden:
\begin{verbatim}
     from in of on
\end{verbatim}
und wird bei der Erstellung der Datei für das Literaturverzeichnis ignoriert.  Der Befehl \texttt{write biblio\-graphy} führt eine Fehlerprüfung durch, um das obige Format zu überprüfen.\index{Fehlerprüfung}\footnote{Anm. der Übersetzer: oft soll ein Wort/Text in eckigen Klammern kein Querverweis sein. Dann sollte statt der einfachen öffnenden eckigen Klammer eine doppelte öffnende eckige Klammer verwendet werden, z.B. \texttt{[}\texttt{[}{\em wieder}\texttt{]}. Ansonsten wird ein Fehler gemeldet, wenn zwischen den eckigen Klammern kein Autor (aus dem Literaturverzeichnis) steht.}

\subsubsection{Klammerausdrücke}\label{parentheticals}

Das Ende eines Kommentars kann eine oder mehrere Klammerausdrücke enthalten, d.h. spezielle Beschreibungen, die in Klammern eingeschlossen sind. Das Metamath-Programm sucht nach bestimmten Klammerausdrücken und kann daraufhin Warnungen ausgeben. Diese sind:

\begin{itemize}
 \item[] \texttt{(Contributed by }
   \textit{NAME}\texttt{,} \textit{DATE}\texttt{.)} -
   dokumentiert den Namen des ursprünglichen Verfassers und das Erstellungsdatum.
 \item[] \texttt{(Revised by }
   \textit{NAME}\texttt{,} \textit{DATE}\texttt{.)} -
   dokumentiert den Namen des Mitwirkenden und das Erstellungsdatum, das zu einer signifikanten Überarbeitung geführt hat (nicht nur zu einer automatischen Minimierung oder Kürzung eines Beweises).
 \item[] \texttt{(Proof shortened by }
   \textit{NAME}\texttt{,} \textit{DATE}\texttt{.)} -
   dokumentiert den Namen und das Datum desjenigen, der eine erhebliche Verkürzung des Beweises erzielt hat (nicht nur eine automatische Minimierung).
 \item[] \texttt{(Proof modification is discouraged.)} -
   Hinweis, dass dieser Beweis normalerweise nicht geändert werden sollte.
 \item[] \texttt{(New usage is discouraged.)} -
   Hinweis, dass diese Behauptung normalerweise nicht verwendet werden sollte.
\end{itemize}

Das Datum \textit{DATE} muss in der Form (D)D-MMM-YYYY angegeben werden, wobei MMM die englische Abkürzung für den Monat ist.\footnote{Anm. der Übersetzer: Und (D)D der ein- oder zweistellige Tag im Monat ist.}

\subsubsection{Sonstige Textauszeichnungen}\label{othermarkup}
\index{Auszeichnungsnotation}

Neben dem Mathe-Modus und dem Label-Modus gibt es noch weitere Textauszeichnungen, um ansprechende Ergebnisse zu erzeugen:


 {\em space}\texttt{\char`\_}{\em non-space} (i.e.\ \texttt{\char`\_}
 
\begin{itemize}
 \item[]
         \texttt{\char`\_} (Unterstrich)\index{\texttt{\char`\_} innerhalb von Kommentaren} -
             Kursive Darstellung von Text ab {\em space}\texttt{\char`\_}{\em non-space} (d.h. \texttt{\char`\_} mit einem Leerzeichen davor und einem Nicht-Leerzeichen danach) bis zum nächsten {\em non-space}\texttt{\char`\_}{\em space}.  Normale Interpunktion (z.B. ein nachgestelltes Komma oder ein Punkt) wird bei der Bestimmung von {\em space} ignoriert.
 \item[]
         \texttt{\char`\_} (Unterstrich) - {\em
         non-space}\texttt{\char`\_}{\em non-space-string}, wobei
          {\em non-space-string} eine Zeichenkette aus Nicht-Leerzeichen ist, stellt {\em non-space-string} tiefer.
 \item[]
         \texttt{<HTML>}...\texttt{</HTML>} - konvertiert nicht "`\texttt{<}"' und "`\texttt{>}"' im enthaltenden Text, wenn {\sc HTML} generiert wird. Ansonsten wird die Textauszeichnungen normal verarbeitet. Dies ermöglicht das direkte Einfügen von {\sc html}-Befehlen.
 \item[]
       "`\texttt{\&}ref\texttt{;}"' - fügt eine {\sc HTML}-Zeichenreferenz ein. So können Sie beliebige Unicode-Zeichen einfügen (z. B. Zeichen mit Akzent).  Derzeit nur direkt unterstützt, wenn {\sc HTML} erzeugt wird.
\end{itemize}

Es wird empfohlen, alle \texttt{\char`\~}- und \texttt{`}-Token im Kommentar mit Leerzeichen zu umgeben und ein Leerzeichen an das einem \texttt{\char`\~}-Token folgenden {\em Label} anzuhängen.  Dadurch werden globale Ersetzungen zum Ändern von Labels und Symbolnamen viel einfacher, und auch die Gefahr von Mehrdeutigkeiten wird in Zukunft ausgeschlossen.  Leerzeichen um diese Zeichen herum werden in der endgültigen Ausgabe automatisch entfernt, um den normalen Interpunktionsregeln zu entsprechen; zum Beispiel wird ein Leerzeichen zwischen einem nachgestellten \texttt{`} und einer linken Klammer entfernt.

Eine gute Möglichkeit, sich mit den Textauszeichnungen vertraut zu machen, ist die Betrachtung der umfangreichen Beispiele in der Datenbasis \texttt{set.mm}.

\subsection{Der Schriftsatz-Kommentar (\texttt{\$t})}\label{tcomment}

Der Schriftsatzkommentar \texttt{\$t} in der Datenbasisdatei liefert die erforderlichen Informationen, um gut aussehende Ausgaben zu erzeugen. Er bietet \LaTeX- und {\sc html}-Definitionen für mathematische Symbole sowie Unterstützung und Anpassungen bei der Generierung von Web-Seite. Wenn Sie ein neues Token zu einer Datenbasis hinzufügen und später eine Ausgabe in \LaTeX\ oder {\sc HTML} erstellen möchten, dann sollten Sie auch die \texttt{\$t}-Kommentarinformationen aktualisieren. In der Datenbasisdatei \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} finden Sie ein ausführliches Beispiel für einen \texttt{\$t}-Kommentar, das viele der unten beschriebenen Funktionen verdeutlicht.

Programme, die keine gut aussehenden Ausgaben für eine Präsentation erzeugen müssen, wie z. B. Programme, die nur Metamath-Datenbasen überprüfen, können Schriftsatzkommentare vollständig ignorieren und sie einfach als normale Kommentare behandeln. Selbst das Metamath-Programm konsultiert die \texttt{\$t}-Kommentarinformationen nur dann, wenn es eine gesetzte Ausgabe in \LaTeX\ oder {\sc HTML} erzeugen muss (z. B. wenn Sie eine \LaTeX-Ausgabedatei mit dem Befehl \texttt{open tex} öffnen).

Wir werden zunächst die Syntax von Schriftsatzkommentaren besprechen und dann kurz darauf eingehen, wie diese innerhalb des Metamath-Programms verwendet werden können.

\subsubsection{Übersicht über die Syntax von Schriftsatzkommentaren}

Der Schriftsatzkommentar wird durch das Token \texttt{\$t}\index{\texttt{\$t}-Anweisung}\index{Schriftsatzanweisung} im Kommentar identifiziert, und der Schriftsatzkommentar endet an dem passenden \texttt{\$)}:
\[
  \mbox{\tt \$(\ }
  \mbox{\tt \$t\ }
  \underbrace{
    \mbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
    \cdots
    \mbox{\tt \ \ \ \ \ \ \ \ \ \ \ }
  }_{\mbox{hier befinden sich Schriftsatzdefinitionen}}
  \mbox{\tt \ \$)}
\]

Zwischen dem \texttt{\$(}, mit dem der Kommentar beginnt, und dem Symbol \texttt{\$t} muss ein Whitespace enthalten sein, und zwar ausschließlich, und auf \texttt{\$t} muss wieder ein Whitespace folgen (siehe Abschnitt \ref{whitespace} zur Definition von Whitespace). Der Schriftsatzkommentar wird bis zum Kommentarende-Token \texttt{\$)} fortgesetzt (dem ein Whitespace vorausgehen muss).

In der Version 0.177\index{Metamath!Limitationen der Version 0.177} des Metamath-Programms darf es nur einen \texttt{\$t}-Kommentar in einer Datenbasis geben.  Diese Einschränkung kann in Zukunft aufgehoben werden, um mehrere \texttt{\$t}-Kommentare in einer Datenbasis zu ermöglichen.

Zwischen dem Symbol \texttt{\$t} (und dem folgenden Whitespace) und dem Kommentarende-Token \texttt{\$)} (und dem vorangehenden Whitespace) befindet sich eine Folge von einer oder mehreren Schriftsatzdefinitionen, wobei jede Definition die Form \textit{definition-type arg arg ... ;} hat. Jeder der null oder mehr \textit{arg}-Werte kann entweder ein Schriftsatzdatenwert oder ein Schlüsselwort sein (welche Schlüsselwörter wo erlaubt sind, hängt vom spezifischen \textit{definition-type} ab). Der \textit{definition-type} und jedes Argument \textit{arg} werden durch einen Whitespace getrennt. Jede Definition endet mit einem Semikolon; ein Whitespace ist vor dem abschließenden Semikolon einer Definition nicht erforderlich. Jede Definition sollte in einer neuen Zeile beginnen.\footnote{Diese Einschränkung der aktuellen Version von Metamath (0.177)\index{Metamath!Limitationen der Version 0.177} wird vielleicht in einer zukünftigen Version entfernt, aber man sollte es aus Gründen der Lesbarkeit trotzdem tun.}

Als Beispiel für solch eine Schriftsatzdefinition definiert
\begin{center}
 \verb$latexdef "C_" as "\subseteq";$
\end{center}
für das Token \verb$C_$ das \LaTeX-Symbol $\subseteq$ (was "`Teilmenge"' bedeutet).

Schriftsatzdaten sind eine Folge von einer oder mehreren Zeichenkette in Anführungszeichen (bei mehreren Zeichenkette in Anführungszeichen werden sie durch \texttt{\char`\+} verbunden). Häufig wird eine einzelne Zeichenkette in Anführungszeichen verwendet, um Daten für eine Definition bereitzustellen, wobei entweder doppelte (\texttt{\char`\"}) oder einfache (\texttt{'}) Anführungszeichen verwendet werden. {\em Eine in Anführungszeichen eingeschlossene Zeichenkette darf jedoch keine Zeilenumbrüche enthalten.} Eine in Anführungszeichen gesetzte Zeichenkette kann ein Anführungszeichen enthalten, das mit den eingeschlossenen Anführungszeichen übereinstimmt, indem das Anführungszeichen zweimal wiederholt wird.  Hier sind einige Beispiele:
\\
\\
\begin{tabu}   { l l }
\textbf{Beispiel} & \textbf{Bedeutung} \\
\texttt{\char`\"a\char`\"\char`\"b\char`\"} & \texttt{a\char`\"b} \\
\texttt{'c''d'} & \texttt{c'd} \\
\texttt{\char`\"e''f\char`\"} & \texttt{e''f} \\
\texttt{'g\char`\"\char`\"h'} & \texttt{g\char`\"\char`\"h} \\
\end{tabu}
\\
\\
\\
Schließlich kann eine lange in Anführungszeichen gesetzte Zeichenkette in mehrere in Anführungszeichen gesetzte Zeichenketten aufgeteilt werden (die als Ganzes als eine einzige in Anführungszeichen gesetzte Zeichenkette betrachtet werden) und mit \texttt{\char`\+} verbunden werden. Sie können sogar mehrere Zeilen verwenden, solange sich am Ende jeder Zeile außer der letzten ein '+' befindet. Vor und nach \texttt{\char`\+} sollte ein Whitespace stehen. Also zum Beispiel,
\begin{center}
 \texttt{\char`\"ab\char`\"\ \char`\+\ \char`\"cd\char`\"
    \ \char`\+\ \\ 'ef'}
\end{center}
ist dasselbe wie
\begin{center}
 \texttt{\char`\"abcdef\char`\"}
\end{center}

Kommentare im {\sc c}-Stil \texttt{/*}\ldots\texttt{*/} werden ebenso unterstützt.

In der Praxis werden Sie oft Satzdefinitionen mit \texttt{latexdef}, \texttt{htmldef} und \texttt{althtmldef} wie unten beschrieben hinzufügen wollen, wenn Sie ein neues mathematisches Token ergänzen. Auf diese Weise werden sie alle auf dem neuesten Stand sein. Ob Sie alle drei Definitionen verwenden wollen oder nicht, hängt natürlich davon ab, wie die Datenbasis verwendet werden soll.

Im Folgenden werden die verschiedenen möglichen \textit{definition-type}-Optio\-nen erörtert. Wir zeigen die Daten in doppelten Anführungszeichen (in der Praxis können sie auch in einfachen Anführungszeichen stehen und/oder eine durch \texttt{+}s verbundene Sequenz sein). Wir werden spezifische Namen für die \textit{data} verwenden, um zu verdeutlichen, wofür die Daten verwendet werden, z. B. {\em Mathe-Token} (für ein Metamath-Mathematik-Token), {\em Latex-string} (für eine Zeichenkette, die in einen \LaTeX-Text eingefügt werden soll), {\em {\sc html}-code} (für {\sc html}-Code) und {\em filename} (für einen Dateinamen).

\subsubsection{Schriftsatzkommentar - \LaTeX}

Die Syntax für eine \LaTeX-Definition lautet:
\begin{center}
 \texttt{latexdef \char`\"}{\em math-token}\texttt{\char`\"\ as \char`\"}{\em latex-string}\texttt{\char`\";}
\end{center}
\index{latex definitions@\LaTeX\ Definitionen}%
\index{\texttt{latexdef}-Anweisung}

{\em token-string} und {\em latex-string} sind die Daten (Zeichenketten) für das Token bzw. die \LaTeX-Definition des Tokens.

Diese \LaTeX-Definitionen werden vom Metamath-Programm verwendet, wenn es mit dem Befehl \texttt{write tex} eine \LaTeX-Ausgabe erzeugen soll.

\subsubsection{Schriftsatzkommentar - {\sc html}}

Die wichtigsten Arten von {\sc HTML}-Definitionen haben die folgende Syntax:

\vskip 1ex
    \texttt{htmldef \char`\"}{\em math-token}\texttt{\char`\"\ as \char`\"}{\em
    {\sc html}-code}\texttt{\char`\";}\index{\texttt{htmldef}-Anweisung}

    \texttt{althtmldef \char`\"}{\em math-token}\texttt{\char`\"\ as \char`\"}{\em
{\sc html}-code}\texttt{\char`\";}\index{\texttt{althtmldef}-Anweisung}

\vskip 1ex

Beachten Sie, dass es in {\sc HTML} zwei mögliche Definitionen für mathematische Token gibt. Diese Funktionalität ist nützlich, wenn eine alternative Darstellung von Symbolen gewünscht wird, zum Beispiel eine, die Unicode-Entities verwendet, und eine andere, die {\sc gif}-Bilder verwendet. 

Es gibt viele andere Schrifsatzdefinitionen, die {\sc HTML} steuern können. Dazu gehören:

\vskip 1ex

    \texttt{htmltitle \char`\"}{\em {\sc html}-code}\texttt{\char`\";}%
\index{\texttt{htmltitle}-Anweisung}

    \texttt{htmlhome \char`\"}{\em {\sc html}-code}\texttt{\char`\";}%
\index{\texttt{htmlhome}-Anweisung}

    \texttt{htmlvarcolor \char`\"}{\em {\sc html}-code}\texttt{\char`\";}%
\index{\texttt{htmlvarcolor}-Anweisung}

    \texttt{htmlbibliography \char`\"}{\em filename}\texttt{\char`\";}%
\index{\texttt{htmlbibliography}-Anweisung}

\vskip 1ex

\noindent Der \texttt{htmltitle} ist der {\sc html} Code für einen allgemeinen Titel, wie z.B. "`Metamath Proof Explorer"'.  Das Feld \texttt{htmlhome} ist der Code für einen Link zurück zur Startseite.  \texttt{htmlvarcolor} ist der Code für einen Farbschlüssel, der am unteren Rand jedes Beweises erscheint.  Die durch {\em filename} angegebene Datei ist eine {\sc html}-Datei, die ein \texttt{<A NAME=}\ldots\texttt{>}-Tag für jeden Verweis in das Literaturverzeichnis in den Datenbasiskommentaren enthäten sollte.  Wenn zum Beispiel \texttt{[Monk]}\index{\texttt{\char`\[}\ldots\texttt{]} innerhalb von Kommentaren} im Kommentar für ein Theorem vorkommt, muss \texttt{<A NAME='Monk'>} in der Datei vorhanden sein; andernfalls wird eine Warnmeldung ausgegeben.

Mit \texttt{htmldef} und  \texttt{althtmldef} verbunden sind die Anweisungen

\vskip 1ex

    \texttt{htmldir \char`\"}{\em
      directoryname}\texttt{\char`\";}\index{\texttt{htmldir}-Anweisung}

    \texttt{althtmldir \char`\"}{\em
     directoryname}\texttt{\char`\";}\index{\texttt{althtmldir}-Anweisung}

\vskip 1ex
\noindent geben die Verzeichnisse der {\sc gif}- bzw. Unicode-Versionen an; ihr Zweck ist es, Querverbindungen zwischen den beiden Versionen in den erzeugten Webseiten herzustellen.

Wenn zwei verschiedene Arten von Seiten aus einer einzigen Datenbasis erzeugt werden müssen, wie z.B. der Hilbert Space Explorer, der den Metamath Proof Explorer erweitert, können "`erweiterte"' Variablen in dem \texttt{\$t}-Kommentar deklariert werden:
\vskip 1ex

    \texttt{exthtmltitle \char`\"}{\em {\sc html}-code}\texttt{\char`\";}%
\index{\texttt{exthtmltitle}-Anweisung}

    \texttt{exthtmlhome \char`\"}{\em {\sc html}-code}\texttt{\char`\";}%
\index{\texttt{exthtmlhome}-Anweisung}

    \texttt{exthtmlbibliography \char`\"}{\em filename}\texttt{\char`\";}%
\index{\texttt{exthtmlbibliography}-Anweisung}

\vskip 1ex

\noindent Wenn diese deklariert werden, müssen Sie auch Folgendes deklarieren

\vskip 1ex

    \texttt{exthtmllabel \char`\"}{\em label}\texttt{\char`\";}%
\index{\texttt{exthtmllabel}-Anweisung}

\vskip 1ex 

\noindent welches die Anweisung der Datenbasis identifiziert, mit der der "`erweiterte"' Abschnitt der Datenbasis (in unserem Beispiel der Hilbert Space Explorer) beginnt.  Bei der Generierung von Webseiten für diese erste Anweisung und die nachfolgenden Anweisungen wird der {\sc html}-Code, der \texttt{exthtmltitle} und \texttt{exthtmlhome} zugewiesen ist, anstelle des Codes verwendet, der \texttt{htmltitle} bzw. \texttt{htmlhome} zugewiesen ist.

\begin{sloppy}
\subsection{Zusatzinformationskommentar (\texttt{\$j})} \label{jcomment}
\end{sloppy}

Der Zusatzinformationskommentar, auch bekannt als \texttt{\$j}-Kommentar\index{\texttt{\$j}-Kommentar}\index{zusätzliche Informationen-Kommentar}, bietet eine Möglichkeit, zusätzliche strukturierte Informationen hinzuzufügen, die optional von Systemen geparst werden können.

Der Zusatzinformationskommentar wird auf die gleiche Weise geparst wie der Schriftsatzkommentar (\texttt{\$t}) (siehe Abschnitt \ref{tcomment}). Das heißt, derZusatzinformationskommentar beginnt mit dem Token \texttt{\$j} innerhalb eines Kommentars und wird bis zum Kommentarschluss \texttt{\$)} fortgesetzt. Innerhalb eines Zusatzinformationskommentars befindet sich eine Folge von einem oder mehreren Befehlen der Form \texttt{command arg arg ... ;}, wobei jeder der null oder mehr \texttt{arg}-Werte entweder eine Zeichenkette in Anführungszeichen oder ein Schlüsselwort sein kann. Beachten Sie, dass jeder Befehl mit einem nicht in Anführungszeichen gesetztes Semikolon endet. Wenn ein Prüfprogramm einen Zusatzinformationskommentar parst, aber einen bestimmten Befehl nicht erkennt, muss er den Befehl überspringen, indem er das Ende des Befehls (ein nicht in Anführungszeichen gesetztes Semikolon) sucht.

Eine Datenbasis kann keine, eine oder mehr Zusatzinformationskommentare haben. Beachten Sie jedoch, dass ein Prüfprogramm diese Kommentare vollständig ignorieren oder nur bestimmte Befehle in einem Zusatzinformationskommentar verarbeiten kann. Der \texttt{mmj2} Verifier unterstützt viele Befehle in Zusatzinformationskommentaren. Wir empfehlen Systemen, die Zusatzinformationskommentare verarbeiten, sich abzustimmen, so dass sie denselben Befehl für denselben Effekt verwenden. 

Beispiele für Zusatzinformationskommentare mit verschiedenen Befehlen (aus der Datenbasis \texttt{set.mm}) sind: 

\begin{itemize}
   \item Definition der Syntax und der logischen Typcodes und Deklaration, dass unsere Grammatik eindeutig ist (überprüfbar mit dem KLR-Parser, mit Kompositionstiefe 5).
\begin{verbatim}
  $( $j
    syntax 'wff';
    syntax '|-' as 'wff';
    unambiguous 'klr 5';
  $)
\end{verbatim}

   \item Registrierung von $\lnot$ und $\rightarrow$ als primitive Ausdrücke (ohne Definitionen).
\begin{verbatim}
  $( $j primitive 'wn' 'wi'; $)
\end{verbatim}

   \item Für \texttt{df-bi} gibt es eine besondere Rechtfertigung.
\begin{verbatim}
  $( $j justification 'bijust' for 'df-bi'; $)
\end{verbatim}

   \item Registrierung von $\leftrightarrow$ als eine Gleichheit für seinen Typ (wff).
\begin{verbatim}
  $( $j
    equality 'wb' from 'biid' 'bicomi' 'bitri';
    definition 'dfbi1' for 'wb';
  $)
\end{verbatim}

   \item Theorem \texttt{notbii} ist das Kongruenzgesetz für die Negation.
\begin{verbatim}
  $( $j congruence 'notbii'; $)
\end{verbatim}

   \item Ergänzung von \texttt{setvar} als Typcode.
\begin{verbatim}
  $( $j syntax 'setvar'; $)
\end{verbatim}

   \item Registrierung von $=$ als Gleichheit für seinen Typ (\texttt{class}).
\begin{verbatim}
  $( $j equality 'wceq' from 'eqid' 'eqcomi' 'eqtri'; $)
\end{verbatim}

\end{itemize}


\subsection{Einbindung anderer Dateien in eine Metamath-Quelldatei} \label{include}
\index{\texttt{\$(} und \texttt{\$)} Hilfsschlüsselwörter}

Die Schlüsselwörter \texttt{\$[} und \texttt{\$]} spezifizieren eine einzubindende Datei\index{eingebundene Datei}\index{Dateieinbindung} an dieser Stelle in einer Metamath\index{Metamath}-Quelldatei\index{Quelldatei}.  Die Syntax für die Einbindung einer Datei lautet wie folgt:
\begin{center}
\texttt{\$[} {\em file-name} \texttt{\$]}
\end{center}

Der Dateiname {\em file-name} sollte ein einzelnes Token mit der gleichen Syntax wie ein mathematisches Symbol sein (d. h. alle 93 druckbaren Zeichen ohne Leerzeichen außer \texttt{\$} sind zulässig, vorbehaltlich der Dateinamensbeschränkungen Ihres Betriebssystems). Zwischen den Schlüsselwörtern \texttt{\$[} und \texttt{\$]} können Kommentare stehen.  Eingebundene Dateien können andere Dateien einbinden, die wiederum andere Dateien einbinden können, und so weiter.

Nehmen wir zum Beispiel an, Sie möchten die Datenbasis der Mengenlehre als Ausgangspunkt für Ihre eigene Theorie verwenden.  Die erste Zeile in Ihrer Datei könnte lauten: 
\begin{center} 
  \texttt{\$[ set.mm \$]} 
\end{center} 
Alle Informationen (Axiome, Theoreme usw.) in \texttt{set.mm} und alle Dateien, die {\em sie selbst wiederum} einschließt, stehen dann Ihnen zur Verfügung, damit Sie in Ihrer Datei darauf verweisen können. Dies ermöglicht eine modularen Aufbau Ihrer eigenen Arbeit. Ein Nachteil des Einbebindens von Dateien ist, dass Sie, wenn Sie den Namen eines Symbols oder das Label einer Anweisung ändern, auch daran denken müssen, alle Verweise in jeder Datei, die sie einbindet, zu aktualisieren.

Die Namenskonventionen für eingebundene Dateien entsprechen denen Ihres Betriebssystems.\footnote{Auf dem Macintosh, vor Mac OS X, wird ein Doppelpunkt verwendet, um Laufwerke- und Ordnernamen von Ihrem Dateinamen zu trennen.  Zum Beispiel bezieht sich {\em volume}\texttt{:}{\em file-name} auf das Stammverzeichnis, {\em volume}\texttt{:}{\em folder-name}\texttt{:}{\em file-name} auf einen Ordner im Stammverzeichnis, und {\em volume}\texttt{:}{\em folder-name}\texttt{:}\ldots\texttt{:}{\em file-name} auf einen Unterordner.  Ein einfacher {\em Dateiname} verweist auf eine Datei in dem Ordner, aus dem Sie die Metamath-Anwendung starten.  Unter Mac OS X und später wird das Metamath-Programm unter der Terminal-Anwendung ausgeführt, die den Unix-Namenskonventionen entspricht.}\index{Macintosh-Dateinamen}\index{Dateinamen!Macintosh}\label{includef} Um die Kompatibilität zwischen verschiedenen Betriebssystemen zu gewährleisten, sollten Sie die Dateinamen so einfach wie möglich halten.  Eine gute Konvention ist {\em file}\texttt{.mm}, wobei {\em file} aus acht Zeichen oder weniger in Kleinbuchstaben besteht. 

Es gibt keine Begrenzung für die Verschachtelungstiefe von eingebundenen Dateien.  Sie sollten jedoch beachten, dass, wenn zwei eingebundene Dateien selbst eine gemeinsame dritte Datei einbinden, diese nur beim {\em ersten} Verweis auf diese gemeinsame Datei eingelesen wird.  Dies ermöglicht es Ihnen, zwei oder mehr Dateien einzubinden, die auf einer gemeinsamen Ausgangsdatei aufbauen, ohne sich um Label- und Symbolkonflikte sorgen zu müssen, die auftreten würden, wenn die gemeinsame Datei mehr als einmal eingelesen würde.  (Wenn eine Datei sich selbst einbindet, wobei das natürlich nicht sinnvoll wäre, wird die Selbstreferenz ignoriert).  Dieses Vorgehen bedeutet jedoch auch, dass das Ergebnis möglicherweise nicht das ist, was Sie erwarten, wenn Sie versuchen, eine gemeinsame Datei in mehreren inneren Blöcken einzubinden, da nur die erste Referenz durch die eingebundene Datei ersetzt wird (im Gegensatz zur include-Anweisung in den meisten anderen Computersprachen).  Daher würden Sie normalerweise gemeinsame Dateien nur im äußersten Block einbinden\index{äußerster Block}. 

\subsection{Komprimiertes Beweisformat}\label{compressed1}\index{komprimierter Beweis}\index{Beweis!komprimiert}

Die in Abschnitt~\ref{proof} vorgestellte Beweisschreibweise wird als {\bf normaler Beweis}\index{normaler Beweis}\index{Beweis!normal} bezeichnet und ist im Prinzip ausreichend, um jeden Beweis vollständig zu beschreiben.  Beweise enthalten jedoch oft Schritte und Unterbeweise, die identisch sind.  Dies gilt insbesondere für typische Metamath\index{Metamath}-Anwendungen, da Metamath verlangt, dass die mathematische Symbolfolge (die in der Regel eine Formel enthält) bei jedem Schritt separat konstruiert, d. h. Stück für Stück aufgebaut wird. Daraus ergibt sich oft eine große Anzahl von Wiederholungen.  Das {\bf komprimierte Beweisformat} ermöglicht es Metamath, diese Redundanz zu nutzen, um Beweise zu verkürzen.

Die Spezifikation für das komprimierte Format der Beweise ist in Anhang~\ref{compressed} enthalten. 

Normalerweise brauchen Sie sich nicht mit den Details des komprimierten Beweisformats zu befassen, da das Programm Metamath eine bequeme Konvertierung vom normalen Format in das komprimierte Format ermöglicht und auch automatisch vom komprimierten Format in das normale Format konvertiert, wenn Beweise angezeigt werden. Die allgemeine Struktur des komprimierten Formats ist wie folgt:
\begin{center}
  \texttt{\$= ( } {\em label-list} \texttt{) } {\em compressed-proof\ }\ \texttt{\$.}
\end{center}
\index{\texttt{\$=} Schlüsselwort}

Die  erste Klammer \texttt{(} dient als Kennzeichen für Metamath, dass ein komprimierter Beweis folgt.  Die {\em label-list} enthält alle Anweisungen, auf die sich der Beweis bezieht, mit Ausnahme der obligatorischen Hypothesen\index{obligatorische Hypothese}.  Das {\em compressed-proof} ist eine kompakte Kodierung des Beweises unter Verwendung von Großbuchstaben und kann als eine große ganze Zahl zur Basis 26 angesehen werden.  Das Whitespace\index{Whitespace} innerhalb eines {\em compressed-proof} ist optional und wird ignoriert.

Es ist wichtig zu beachten, dass die Reihenfolge der obligatorischen Hypothesen der zu beweisenden Anweisung nicht geändert werden darf, wenn das komprimierte Beweisformat verwendet wird, da der Beweis sonst falsch wird.  Der Grund dafür ist, dass die obligatorischen Hypothesen im komprimierten Beweis nicht explizit erwähnt werden, um die Komprimierung effizienter zu gestalten. Wenn Sie die Reihenfolge der obligatorischen Hypothesen ändern möchten, müssen Sie den Beweis zunächst wieder in das normale Format konvertieren, indem Sie die Anweisung \texttt{save proof} \texttt{{\em statement} /normal}\index{\texttt{save proof}-Befehl} ausführen. Später können Sie mit dem Befehl \texttt{save proof} \texttt{{\em statement} /compressed} wieder in das komprimierte Format wechseln. 

Bei der Fehlerprüfung mit dem Befehl \texttt{verify proof} kann ein in einem komprimierten Beweis gefundener Fehler auf ein Zeichen in {\em compressed-proof} verweisen, das für Sie möglicherweise nicht sehr aussagekräftig ist.  Versuchen Sie in diesem Fall zuerst \texttt{save proof /normal} und führen Sie dann den Befehl \texttt{verify proof} erneut aus.  Im Allgemeinen ist es am besten sich zu vergewissern, dass ein Beweis korrekt ist, bevor man ihn im komprimierten Format speichert, da schwere Fehler mit geringerer Wahrscheinlichkeit wiederhergestellt werden können als im normalen Format. 

\subsection{Unbekannte Beweise oder Teilbeweise}\label{unknown}

In einem in Entwicklung befindlichen Beweis kann jeder Schritt oder Teilbeweis, der noch nicht bekannt ist, mit einem einzelnen \texttt{?} dargestellt werden.  Beim Parsen des Beweises wird bei einem \texttt{?}\index{\texttt{]}@\texttt{?}\ innerhalb von Beweisen} ein einzelner Eintrag auf den RPN-Stapel geschoben, als wäre es eine Hypothese.  Während der Entwicklung eines Beweises mit dem Beweis-Assistenten\index{Beweis-Assistent} kann ein teilweise entwickelter Beweis mit dem Befehl \texttt{save new{\char`\_}proof}\index{\texttt{save new{\char`\_}proof}-Befehl} gespeichert werden, und die \texttt{?}'s werden an die entsprechenden Stellen gesetzt. 

Für alle \texttt{\$p}\index{\texttt{\$p}-Anweisung}-Anweisungen müssen Beweise vorliegen, auch wenn sie völlig unbekannt sind.  Bevor Sie einen Beweis mit dem Beweis-Assistenten erstellen, sollten Sie einen völlig unbekannten Beweis wie folgt angeben: 
\begin{center}
  {\em label} \texttt{\$p} {\em statement} \texttt{\$= ?\ \$.}
\end{center}
\index{\texttt{\$=} Schlüsselwort}
\index{\texttt{]}@\texttt{?}\ innerhalb von Beweisen}

Der Befehl \texttt{verify proof}\index{\texttt{verify proof}-Befehl} prüft die bekannten Teile eines Teilbeweises auf Fehler, warnt Sie aber, dass die Anweisung nicht bewiesen ist. 

Beachten Sie, dass teilweise entwickelte Beweise auf Wunsch im komprimierten Format gespeichert werden können.  In diesem Fall sehen Sie einen oder mehrere \texttt{?}'s im Teil {\em compressed-proof}\index{komprimierter Beweis}\index{Beweis!komprimiert}.

\section{Axiome vs. Definitionen}\label{definitions}

Die Metamath \textit{zugrunde liegende} Sprache und das Metamath\index{Metamath}-Programm unterscheiden nicht zwischen Axiomen\index{Axiom} und Definitionen.\index{Definition} Die \texttt{\$a}\index{\texttt{\$a}-Anweisung}-Anweisung wird für beides verwendet.  Auf den ersten Blick mag dies seltsam erscheinen.  In den Augen vieler Mathematiker ist die Unterscheidung klar, sogar offensichtlich, und kaum eine Diskussion wert.  Eine Definition wird lediglich als eine Abkürzung betrachtet, die durch den Ausdruck, für den sie steht, ersetzt werden kann; wenn man dies jedoch nicht tut, sollte man sagen, dass ein Theorem\index{Theorem} eine Folge der Axiome {\em und} der Definitionen ist, die bei der Formulierung des Theorems verwendet werden \cite[S.~20]{Behnke}.\index{Behnke, H.}

\subsection{Was ist eine Definition?}

Was ist eine Definition?  In ihrer einfachsten Form führt eine Definition ein neues Symbol ein und liefert eine eindeutige Regel zur Umwandlung eines Ausdrucks, der das neue Symbol enthält, in einen Ausdruck ohne dieses Symbol.  Das Konzept einer "`zulässigen Definition"'\index{zulässige Definition}\index{Definition!zulässig} (im Gegensatz zu einer kreativen Definition)\index{kreative Definition}\index{Definition!kreativ}, auf das man sich in der Regel einigt, ist, dass (1) die Definition die Sprache nicht mächtiger machen sollte und (2) alle durch die Definition eingeführten Symbole aus der Sprache eliminierbar sein sollten \cite{Nemesszeghy}\index{Nemesszeghy, E. Z.}.  Mit anderen Worten, sie sind bloße typografische Bequemlichkeiten, die nicht zum System gehören und theoretisch überflüssig sind.  Dies mag offensichtlich erscheinen, aber in der Tat kann die Natur von Definitionen subtil sein und erfordert manchmal komplexe Metatheoreme, um zu beweisen, dass sie nicht kreativ sind. 

Eine konservativere Haltung vertrat der Logiker S. Le\'{s}niewski.\index{Le\'{s}niewski, S.} 
\begin{quote}
  Le\'{s}niewski betrachtet Definitionen als Thesen des Systems.  In dieser Hinsicht unterscheiden sie sich weder von den Axiomen noch von den Theoremen, d.h. von den Thesen, die dem System auf der Grundlage der Substitutionsregel oder der Abtrennregel [Modus ponens] hinzugefügt werden.  Sobald Definitionen als Thesen des Systems akzeptiert wurden, müssen sie als wahre Sätze in demselben Sinne betrachtet werden, in dem auch Axiome wahr sind
  \cite{Lejewski}.
\end{quote}\index{Lejewski, Czeslaw} 

Sehen wir uns einige einfache Beispiele für Definitionen in der Aussagenlogik an.  Betrachten wir die Definition des logischen {\sc or} (Disjunktion):\index{Disjunktion ($\vee$)} "`$P\vee Q$ steht für $\neg P \rightarrow Q$ (nicht $P$ impliziert $Q$)"'.  Eine Anweisung, die von dieser Definition Gebrauch macht, ist sehr leicht zu erkennen, weil sie das neue Symbol $\vee$ verwendet, das es vorher in der Sprache nicht gab.  Es ist leicht zu erkennen, dass sich aus dieser Definition keine neuen Theoreme der ursprünglichen Sprache ergeben. 

Betrachten wir nun eine Definition, bei der die Klammern entfallen:  "`$P \rightarrow Q \rightarrow R$ bedeutet $P\rightarrow (Q \rightarrow R)$."' Dies ist subtiler, da keine neuen Symbole eingeführt werden.  Der Grund, warum diese Definition als richtig angesehen wird, ist, dass sich aus der Definition keine neuen Symbolfolgen ergeben, die in der ursprünglichen Sprache gültige wffs (wohlgeformte Formeln)\index{wohlgeformte Formel (wff)} sind, da "`$P \rightarrow Q\rightarrow R$"' keine wff in der ursprünglichen Sprache ist.  Wir machen hier implizit Gebrauch von der Tatsache, dass es ein Entscheidungsverfahren gibt, mit dem wir feststellen können, ob eine Symbolfolge eine wff ist oder nicht, und diese Tatsache erlaubt es uns, Symbolfolgen, die keine wffs sind, zu verwenden, um andere Dinge (wie wffs) mit Hilfe der Definition darzustellen.  Um jedoch zu rechtfertigen, dass die Definition nicht kreativ ist, müssen wir beweisen, dass "`$P \rightarrow Q\rightarrow R$"' in der ursprünglichen Sprache tatsächlich keine wff ist, und das ist schwieriger als in dem Fall, in dem wir einfach ein neues Symbol einführen. 

%Now let's take this reasoning to an extreme.  Propositional calculus is a
%decidable theory,\footnote{This means that a mechanical algorithm exists to
%determine whether or not a wff is a theorem.} so in principle we could make use
%of symbol sequences that are not theorems to represent other things (say, to
%encode actual theorems in a more compact way).  For example, let us extend the
%language by defining a wff "`$P$"' in the extended language as the theorem
%"`$P\rightarrow P$"'\footnote{This is one of the first theorems proved in the
%Metamath database \texttt{set.mm}.}\index{set
%theory database (\texttt{set.mm})} in the original language whenever "`$P$"' is
%not a theorem in the original language.  In the extended language, any wff
%"`$Q$"' thus represents a theorem; to find out what theorem (in the original
%language) "`$Q$"' represents, we determine whether "`$Q$"' is a theorem in the
%original language (before the definition was introduced).  If so, we're done; if
%not, we replace "`$Q$"' by "`$Q\rightarrow Q$"' to eliminate the definition.
%This definition is therefore eliminable, and it does not "`strengthen"' the
%language because any wff that is not a theorem is not in the set of statements
%provable in the original language and thus is available for use by definitions.
%
%Of course, a definition such as this would render practically useless the
%communication of theorems of propositional calculus; but
%this is just a human shortcoming, since we can't always easily discern what is
%and is not a theorem by inspection.  In fact, the extended theory with this
%definition has no more and no less information than the original theory; it just
%expresses certain theorems of the form "`$P\rightarrow P$"'
%in a more compact way.
%
%The point here is that what constitutes a zulässigen Definitionnition is a matter of
%judgment about whether a symbol sequence can easily be recognized by a human
%as invalid in some sense (for example, not a wff); if so, the symbol sequence
%can be appropriated for use by a definition in order to make the extended
%language more compact.  Metamath\index{Metamath} lacks the ability to make this
%judgment, since as far as Metamath is concerned the definition of a wff, for
%example, is arbitrary.  You define for Metamath how wffs\index{wohlgeformte Formel (wff)} are constructed according to your own preferred style.  The
%concept of a wff may not even exist in a given formal system\index{formal
%system}.  Metamath treats all definitions as if they were new axioms, and it
%is up to the human mathematician to judge whether the definition is "`proper"'
%'\index{zulässige Definition}\index{Definition!zulässig} in some agreed-upon way.

Was eine Definition\index{Definition} von einem Axiom\index{Axiom}\index{Axiom vs. Definition} unterscheidet ist in der mathe\-ma\-tischen Literatur manchmal willkürlich.  Zum Beispiel werden die Junktoren $\vee$ ({\sc oder}), $\wedge$ ({\sc und}) und $\leftrightarrow$ (äquivalent zu) in der Aussagenlogik gewöhnlich als definierte Symbole betrachtet, die als Abkürzungen für Ausdrücke verwendet werden können, die die "`primitiven"' Junktoren $\rightarrow$ und $\neg$ enthalten.  So werden sie auch in der Standard-Datenbasis für Logik und Mengenlehre \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})} behandelt.  Die ersten drei Junktoren können jedoch auch als "`primitiv"' betrachtet werden, und es wurden Axiomensysteme entwickelt, die alle diese Junktoren als solche behandeln.  So enthält z. B. \cite[S.~35]{Goodstein}\index{Goodstein, R. L.} 15 Axiome, von denen einige mit dem übereinstimmen, was wir in \texttt{set.mm} als Definitionen bezeichnet haben.  In bestimmten Teilmengen der klassischen Aussagenlogik, wie dem intuitionistischen Fragment\index{Intuitionismus}, kann man zeigen, dass man nicht nur mit $\rightarrow$ und $\neg$ auskommen kann, sondern zusätzliche Junktoren als primitiv behandeln muss, damit das System einen Sinn ergibt.\footnote{Zwei schöne Systeme, die den Übergang von dem intuitionistischen und anderen schwachen Fragmenten zur klassischen Logik nur durch Hinzufügen von Axiomen schaffen, sind in \cite{Robinsont}\index{Robinson, T. Thacher} angegeben.}

\subsection{Der Ansatz für Definitionen in \texttt{set.mm}}

In der Mengenlehre definieren rekursive Definitionen ein neu eingeführtes Symbol in Bezug auf sich selbst. Die Begründung rekursiver Definitionen mit Hilfe mehrerer "`Rekursionstheoreme"' ist normalerweise einer der ersten anspruchsvollen Beweise, mit denen ein Student beim Erlernen der Mengenlehre konfrontiert wird, und hinter einer rekursiven Definition steckt eine beträchtliche Menge impliziter Metalogik, obwohl die Definition selbst normalerweise einfach zu formulieren ist.

Metamath selbst hat keine eingebauten technischen Einschränkungen, die mehrteilige rekursive Definitionen im traditionellen Lehrbuchstil verhindern. Da die rekursive Definition jedoch eine fortgeschrittene Metalogik erfordert, um sie zu begründen, ist die Eliminierung einer rekursiven Definition sehr schwierig und wird in Lehrbüchern oft nicht einmal gezeigt. 

\subsubsection{Direkte Definitionen anstelle von rekursiven Definitionen}

Es ist jedoch möglich, eine Art von Komplexität durch eine andere zu ersetzen.  Wir können die Notwendigkeit einer metalogischen Begründung vermeiden, indem wir die Operation direkt mit einem expliziten (aber komplizierten) Ausdruck definieren und dann die rekursive Definition direkt als Theorem ableiten, indem wir ein Rekursionstheorem "`in die andere Richtung"' verwenden. Die Eliminierung einer direkten Definition erfolgt diurch eine einfache mechanische Substitution. Wir tun dies in \texttt{set.mm} wie folgt.

In \texttt{set.mm} war es unser Ziel, fast alle Definitionen in Form von zwei Ausdrücken einzuführen, die entweder durch $\leftrightarrow$ oder $=$ verbunden sind, wobei das Definierte nicht auf der rechten Seite erscheint.  Quine nennt diese Form "`eine echte oder direkte Definition"' \cite[S. 174]{Quine}\index{Quine, Willard Van Orman}, wodurch die Definitionen sehr leicht zu eliminieren sind und die Metalogik\index{Metalogik}, die zu ihrer Rechtfertigung erforderlich ist, so einfach wie möglich ist. Anders ausgedrückt: Unser Ziel war es, alle Definitionen durch direkte mechanische Substitutionen zu eliminieren und die Fundiertheit der Definitionen leicht zu überprüfen. 

\subsubsection{Beispiel für direkte Definitionen}

Wir haben dieses Ziel in fast allen Fällen in \texttt{set.mm} erreicht. Manchmal macht dies die Definitionen komplexer und weniger intuitiv. Die traditionelle Art, die Addition natürlicher Zahlen zu definieren, besteht zum Beispiel darin, eine Operation namens {\em Nachfolger}\index{Nachfolger} zu definieren (was "`plus eins"' bedeutet und mit "`${\rm suc}$"' bezeichnet wird), dann die Addition rekursiv zu definieren\index{rekursive Definition} mit den beiden Definitionen $n + 0 = n$ und $m + {\rm suc}\,n = {\rm suc} (m + n)$.  Obwohl diese Definition einfach und offensichtlich erscheint, ist die Methode zur Eliminierung der Definition nicht offensichtlich: Im zweiten Teil der Definition wird die Addition in Bezug auf sich selbst definiert.  Mit der Eliminierung der Definition ist nicht gemeint, dass man sie wiederholt auf bestimmte $m$ und $n$ anwendet, sondern dass man den expliziten, in sich geschlossenen mengentheoretischen Ausdruck angibt, den $m + n$ darstellt, der für beliebige $m$ und $n$ gilt und der kein $+$-Zeichen auf der rechten Seite hat.  Damit eine rekursive Definition wie diese nicht zirkulär (kreativ) ist, müssen wir einige versteckte, zugrundeliegende Annahmen machen, zum Beispiel, dass die natürlichen Zahlen eine bestimmte Ordnung haben. 

In \texttt{set.mm} haben wir uns entschieden, mit der direkten (wenn auch komplexen und nicht intuitiven) Definition zu beginnen und daraus die rekursive Standarddefinition abzuleiten. Die geschlossene Definition, die in \texttt{set.mm} für die Additionsoperation von Ordinalzahlen\index{ordinale Addition}\index{Addition!von Ordinalen} (von denen die natürlichen Zahlen eine Teilmenge sind) verwendet wird, lautet beispielsweise 

\setbox\startprefix=\hbox{\tt \ \ df-oadd\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{+_o}\m{=}\m{(}\m{x}\m{\in}\m{{\rm On}}\m{,}\m{y}\m{\in}\m{{\rm
On}}\m{\mapsto}\m{(}\m{{\rm rec}}\m{(}\m{(}\m{z}\m{\in}\m{{\rm
V}}\m{\mapsto}\m{{\rm suc}}\m{z}\m{)}\m{,}\m{x}\m{)}\m{`}\m{y}\m{)}\m{)}
\endm
\noindent welche vom Operator ${\rm rec}$ (siehe folgenden Abschnitt) abhängt.

\subsubsection{Rekursionsoperatoren}

Die obige Definition von \texttt{df-oadd} hängt von der Definition von ${\rm rec}$ ab, einem "`Rekursionsoperator"'\index{Rekursionsoperator} mit der Definition \texttt{df-rdg}: 

\setbox\startprefix=\hbox{\tt \ \ df-rdg\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{{\rm
rec}}\m{(}\m{F}\m{,}\m{I}\m{)}\m{=}\m{\mathrm{recs}}\m{(}\m{(}\m{g}\m{\in}\m{{\rm
V}}\m{\mapsto}\m{{\rm if}}\m{(}\m{g}\m{=}\m{\varnothing}\m{,}\m{I}\m{,}\m{{\rm
if}}\m{(}\m{{\rm Lim}}\m{{\rm dom}}\m{g}\m{,}\m{\bigcup}\m{{\rm
ran}}\m{g}\m{,}\m{(}\m{F}\m{`}\m{(}\m{g}\m{`}\m{\bigcup}\m{{\rm
dom}}\m{g}\m{)}\m{)}\m{)}\m{)}\m{)}\m{)}
\endm

\noindent die anhand der Definitionen in Abschnitt~\ref{setdefinitions} weiter heruntergebrochen werden könnte.

Diese Definition von ${\rm rec}$ definiert einen rekursiven Definitionsgenerator auf ${\rm On}$ (der Klasse der Ordinalzahlen) mit charakteristischer Funktion $F$ und Anfangswert $I$. Diese Operation erlaubt es uns, mit kompakten direkten Definitionen Funktionen zu definieren, die normalerweise in Lehrbüchern mit rekursiven Definitionen definiert werden. Der Preis, den wir mit unserem Ansatz zahlen, ist die Komplexität unserer ${\rm rec}$-Operation (insbesondere, wenn {\tt df-recs}, auf dem sie aufbaut, ebenfalls eliminiert werden soll). Aber sobald wir diese Hürde überwunden haben, werden Definitionen, die sonst rekursiv wären, relativ einfach, wie zum Beispiel {\tt oav}, aus dem wir die rekursive Lehrbuchdefinition als Theoreme {\tt oa0}, {\tt oasuc} und {\tt oalim} beweisen (mit Hilfe der Theoreme {\tt rdg0}, {\tt rdgsuc} und {\tt rdglim2a}).  Wir können die ${\rm rec}$-Operation auch einschränken, um rekursive Funktionen auf den natürlichen Zahlen $\omega$ zu definieren; siehe {\tt fr0g} und {\tt frsuc}.  Unsere ${\rm rec}$-Operation taucht in der veröffentlichten Literatur offenbar nicht auf, obwohl sie eng mit der Definition 25.2 von [Quine] S. 177 verwandt ist, die er verwendet, "`um eine Rekursion in eine echte oder direkte Definition zu verwandeln"' (S. 174).  Man beachte, dass die ${\rm if}$-Operationen (siehe {\tt df-if}) Fälle danach auswählen, ob der Definitionsbereich von $g$ die leere Menge, ein Nachfolger oder eine Grenzordinale ist. 

Eine wichtige Anwendung dieser Definition ${\rm rec}$ ist der rekursive Sequenzgenerator {\tt df-seq} auf den natürlichen Zahlen (als Teilmenge der komplexen unendlichen Sequenzen, wie der Fakultätsfunktion {\tt df-fac} und den ganzzahligen Potenzen {\tt df-exp}). 

Die Definition von ${\rm rec}$ hängt von ${\rm recs}$ ab. Von der direkten Verwendung des mächtigeren (und primitiveren) ${\rm recs}$-Konstrukts wird abgeraten, es ist aber bei Bedarf verfügbar. Dies definiert eine Funktion $\mathrm{recs} ( F )$ auf ${\rm On}$, der Klasse der Ordinalzahlen, durch transfinite Rekursion unter der Voraussetzung einer Regel $F$, die den nächsten Wert unter Berücksichtigung aller bisherigen Werte bestimmt. Im Gegensatz zu {\tt df-rdg}, das die Aktualisierungsregel darauf beschränkt, nur den vorherigen Wert zu verwenden, erlaubt diese Version der Aktualisierungsregel, alle vorherigen Werte zu verwenden, weshalb sie als "`stark"' bezeichnet wird, obwohl sie eigentlich primitiver ist.  Siehe {\tt recsfnon} und {\tt recsval} für die primären Eigenschaften dieser Definition. Sie ist definiert als: 

\setbox\startprefix=\hbox{\tt \ \ df-recs\ \$a\ }
\setbox\contprefix=\hbox{\tt \ \ \ \ \ \ \ \ \ \ \ \ \ }
\startm
\m{\vdash}\m{\mathrm{recs}}\m{(}\m{F}\m{)}\m{=}\m{\bigcup}\m{\{}\m{f}\m{|}\m{\exists}\m{x}\m{\in}\m{{\rm
On}}\m{(}\m{f}\m{{\rm
Fn}}\m{x}\m{\wedge}\m{\forall}\m{y}\m{\in}\m{x}\m{(}\m{f}\m{`}\m{y}\m{)}\m{=}\m{(}\m{F}\m{`}\m{(}\m{f}\m{\restriction}\m{y}\m{)}\m{)}\m{)}\m{\}}
\endm

\subsubsection{Abschließende Bemerkungen zu direkten Definitionen}

Aus diesen direkten Definitionen wird die einfachere, intuitivere rekursive Definition als eine Reihe von Theoremen abgeleitet.\index{natürliche Zahlen}\index{Addition}\index{rekursive Definition}\index{ordinale Addition} Das Endergebnis ist dasselbe, aber wir können dadurch vollständig auf die recht komplexe Metalogik verzichten, die die rekursive Definition rechtfertigt. 

Rekursive Definitionen werden oft als effizienter und intuitiver angesehen als direkte Definitionen, sobald die Metalogik erlernt oder möglicherweise einfach als korrekt akzeptiert wurde.  Man war jedoch der Ansicht, dass die direkte Definition in \texttt{set.mm} die Strenge maximiert, indem sie die Metalogik minimiert.  Eine solche Definition kann mühelos eliminiert werden, was bei einer rekursiven Definition nur schwer möglich ist. 

Auch hier gilt, dass Metamath selbst keine eingebauten technischen Einschränkungen hat, die mehrteilige rekursive Definitionen im traditionellen Lehrbuchstil verhindern. Stattdessen ist es unser Ziel, alle Definitionen mit direkter mechanischer Substitution zu eliminieren und die Fundiertheit der Definitionen leicht zu überprüfen. 

\subsection{Hinzufügen von Einschränkungen für Definitionen}

Die Metamath-Basissprache und das Metamath-Programm haben keine eingebauten einschrämkungen für Definitionen, da sie nur \texttt{\$a}-Anweisungen sind. 

Nichts hindert jedoch ein Verifikationssystem daran, zusätzliche Regeln zu verifizieren, um weitere Einschränkungen für Definitionen vorzunehmen. Das \texttt{mmj2}\index{mmj2}-Programm unterstützt zum Beispiel verschiedene Arten von zusätzlichen Informationskommentaren (siehe Abschnitt \ref{jcomment}). Eine ihrer Verwendungen ist die optionale Überprüfung zusätzlicher Einschränkungen, einschließlich der Überprüfung, ob Definitionen bestimmte Anforderungen erfüllen. Diese zusätzlichen Prüfungen werden von der kontinuierlichen Integration (CI)\index{kontinuierliche Integration (CI)} der \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}\index{Metamath Proof Explorer} Datenbasis benötigt. Dieser Ansatz ermöglicht es uns, optional zusätzliche Anforderungen an Definitionen zu stellen, wenn wir dies wünschen, ohne dass diese Regeln notwendigerweise für alle Datenbasen gelten oder von allen Verifikationssystemen verlangen zu müssen diese zu prüfen. Außerdem können wir auf diese Weise spezielle, auf eine Datenbasis zugeschnittene Einschränkungen vornehmen, ohne dass andere Systeme diese speziellen Einschränkungen berücksichtigen müssen. 

Es gibt zwei solcher Einschränkungen in der Datenbasis \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}\index{Metamath Proof Explorer}, die meit dem Programm \texttt{mmj2}\index{mmj2} geprüft werden, die es wert sind, hier besprochen zu werden: eine Syntax-Prüfung und eine Prüfung der Fundiertheit von Definitionen.

% On February 11, 2019 8:32:32 PM EST, saueran@oregonstate.edu wrote:
% The following addition to the end of set.mm is accepted by the mmj2
% parser and definition checker and the metamath verifier(at least it was
% when I checked, you should check it too), and creates a contradiction by
% proving the theorem |- ph.
% ${
% wleftp $a wff ( ( ph ) $.
% wbothp $a wff ( ph ) $.
% df-leftp $a |- ( ( ( ph ) <-> -. ph ) $.
% df-bothp $a |- ( ( ph ) <-> ph ) $.
% anything $p |- ph $=
%   ( wbothp wn wi wleftp df-leftp biimpi df-bothp mpbir mpbi simplim ax-mp)
%   ABZAMACZDZCZMOEZOCQAEZNDZRNAFGSHIOFJMNKLAHJ $.
% $}
%
% This particular problem is countered by enabling, within mmj2,
% SetParser,mmj.verify.LRParser

Erstens aktivieren wir in \texttt{mmj2} (über den Befehl \texttt{SetParser}) eine Syntax-Prüfung, die vorschreibt, dass alle neuen Definitionen für einen KLR(5)-Parser kein mehrdeutiges Ergebnis erzeugen dürfen. Dies verhindert einige Fehler wie z. B. Definitionen mit unausgeglichenen Klammern. 

Zweitens führen wir eine Definitionsprüfung durch, die spezifisch für \texttt{set.mm} oder ähnliche Datenbasen ist (über das Makro \texttt{definitionCheck}). Einige \texttt{\$a}-Anweisungen (einschließlich aller ax-*-Statements) sind von diesen Prüfungen ausgenommen, da sie diese einfache Prüfung immer nicht bestehen werden, aber sie sind für die meisten Definitionen geeignet. Diese Prüfung erzwingt eine Reihe von zusätzlichen Regeln: 

\begin{enumerate}

\item Neue Definitionen müssen mit $=$ oder $\leftrightarrow$ eingeführt werden.

\item Keine vor dieser Anweisung eingeführte \texttt{\$a}-Anweisung darf das in dieser Definition definierte Symbol verwenden, und die Definition darf sich selbst nicht verwenden (außer einmal im Definiendum).

\item Die im Definiens verwendeten Variablen müssen distinkt sein.

\item Alle Dummy-Variablen im Definiendum müssen untereinander und mit den Variablen im Definiendum distinkt sein. Um dies festzustellen, sucht das System in der Datenbasis nach einem "`Rechtfertigungssatz"'\footnote{Anm. der Übersetzer: Ein "`Rechtfertigungssatz"' ("`justification theorem"') ist ein Theorem, dass die Korrektheit der Definition rechtfertigt. Der Name des Theorems ist der Teil des Namens der Definition nach "`df-"' ergänzt um "`just"', siehe z.B. {\tt df-mo} und {\tt mojust}.}. Wenn dieser nicht vorhanden ist, versucht es intern, für jede Dummy-Variable x $( \varphi \rightarrow \forall x \varphi )$ zu beweisen.

\item Jede Dummy-Variable sollte eine Mengenvariable sein, es sei denn, es gibt einen Rechtfertigungssatz.

\item Jede Dummy-Variable muss gebunden sein (wenn das System dies nicht bestimmen kann, muss ein Rechtfertigungssatz angegeben werden).

\end{enumerate}

\subsection{Zusammenfassung des Metamath-Ansatzes für\\ Definitionen}

Kurz gesagt, bei einem rigorosen Vorgehen stellt sich heraus, dass Definitionen subtil sein können und manchmal schwierige Metatheoreme erfordern, um zu beweisen, dass sie nicht kreativ sind. 

Anstatt solche Komplikationen in die Metamath-Sprache selbst einzubauen, behandeln die grundlegende Metamath-Sprache und das Programm die traditionellen Axiome und Definitionen einheitlich als \texttt{\$a}-Anweisungen. Wir haben dann verschiedene Werkzeuge entwickelt, die es jedem ermöglichen, für seine spezifischen, selbst angelegten Datenbasen zusätzliche, selbst festgelegte Bedingungen zu überprüfen, ohne die grundlegenden Eigenschaften und Funktionalitäten von Metamath zu verkomplizieren. 

\chapter{Das Metamath-Programm}\label{commands}

Dieses Kapitel ist als ein Referenzhandbuch für das Metamath-Programm zu verstehen.\index{Metamath!Befehle}

Aktuelle Anweisungen für den Bezug und die Installation des Metamath-Programms finden Sie auf der Website \url{http://metamath.org}. Für Windows gibt es eine vorkompilierte Version namens \texttt{metamath.exe}.  Für Unix, Linux und Mac OS X (die wir zusammenfassend als "`Unix"' bezeichnen) kann das Metamath-Programm aus seinem Quellcode mit dem Befehl 
\begin{verbatim} 
gcc *.c -o metamath 
\end{verbatim} 
unter Verwendung des auf diesen Systemen verfügbaren \texttt{gcc} {\sc c}-Compilers kompiliert werden. 

In den nachfolgenden Beschreibungen der Befehlssyntax sind die in eckige Klammern [\ ] eingeschlossenen Angaben optional.  Dateinamen können optional in einfache oder doppelte Anführungszeichen gesetzt werden.  Dies ist nützlich, wenn der Dateiname Leerzeichen oder Schrägstriche (\texttt{/}) enthält, wie z.B. in Unix-Pfadnamen, \index{Unix-Dateinamen}\index{Dateinamen!Unix}, die mit Metamath-Befehlszeilenparameter verwechselt werden könnten.\index{Unix-Dateinamen}\index{Dateinamen!Unix}

\section{Aufruf von Metamath}

Unix, Linux und Mac OS X verfügen über eine Befehlszeilenschnittstelle, die  {\em Bash Shell}.  (Unter Mac OS X wählen Sie das Programm Terminal aus Anwendungen/Dienstprogramme.) Um Metamath von der Bash-Shell-Eingabeaufforderung aus aufzurufen, geben Sie Folgendes ein, vorausgesetzt das Metamath-Programm befindet sich im aktuellen Verzeichnis: 
\begin{verbatim} 
bash$ ./metamath 
\end{verbatim} 

Um Metamath von einem Windows-Konsolenfenster aus aufzurufen, geben Sie Folgendes ein, vorausgesetzt das Metamath-Programm befindet sich im aktuellen Verzeichnis (oder in einem Verzeichnis, das in der Systemumgebungsvariablen Path enthalten ist): 
\begin{verbatim} 
C:\metamath>metamath 
\end{verbatim} 

Um Befehlszeilenargumente beim Aufruf zu verwenden, sollten die Befehlszeilenargumente eine Liste von Metamath-Befehlen sein, die von Anfüh\-rungszeichen umgeben sind, wenn sie Leerzeichen enthalten.  Unter Windows müssen die umgebenden Anführungszeichen doppelte (nicht einfache) Anführungszeichen sein.  Um zum Beispiel die Datenbasisdatei \texttt{set.mm} zu lesen, alle Beweise zu überprüfen und das Programm zu beenden, geben Sie (unter Unix) Folgendes ein:
\begin{verbatim} 
bash$ ./metamath 'read set.mm' 'verify proof *' exit 
\end{verbatim} Beachten Sie, dass unter Unix jeder Verzeichnispfad mit \texttt{/}'s von Anführungszeichen umgeben sein muss, damit Metamath das \texttt{/} nicht als Befehlszeilenparameter interpretiert.  Wenn also \texttt{set.mm} im Verzeichnis \texttt{/tmp} liegt, verwenden Sie für das obige Beispiel 
\begin{verbatim} 
bash$ ./metamath 'read "/tmp/set.mm"' 'verify proof *' exit 
\end{verbatim} 

Wenn die Befehlszeile nur ein Argument und keine Leerzeichen enthält, wird implizit angenommen, dass der Befehl \texttt{read} lautet.  In diesem einen Sonderfall werden \texttt{/} nicht als Befehlszeilenparameter interpretiert, so dass Sie keine Anführungszeichen um einen Unix-Dateinamen herum benötigen.  Also 
\begin{verbatim} 
bash$ ./metamath /tmp/set.mm 
\end{verbatim} und 
\begin{verbatim} 
bash$ ./metamath "read '/tmp/set.mm'" 
\end{verbatim} sind gleichwertig. 


\section{Steuerung von Metamath}

Das Metamath-Programm wurde zuerst auf einem {\sc vax/vms}-System entwickelt, und einige Aspekte seines Befehlszeilenverhaltens spiegeln dieses Erbe wider. Wir hoffen, dass Sie es einigermaßen benutzerfreundlich finden, sobald Sie sich daran gewöhnt haben. 

Jede Befehlszeile besteht aus einer Folge englischsprachiger Wörter, die durch Leerzeichen getrennt sind, wie in \texttt{show settings}.  Bei Befehlswörtern wird nicht zwischen Groß- und Kleinschreibung unterschieden, und es werden nur so viele Buchstaben benötigt, wie nötig sind, um Mehrdeutigkeiten auszuschließen; so würde beispielsweise bereits \texttt{sh se} für die Ausführung des Befehls \texttt{show settings} ausreichen.  In einigen Fällen sind Argumente wie Dateinamen, Label von Anweisungen oder Symbolnamen erforderlich; bei diesen wird zwischen Groß- und Kleinschreibung unterschieden (obwohl Dateinamen auf einigen Betriebssystemen möglicherweise nicht unterschieden werden). 

Eine Befehlszeile wird eingegeben, indem man sie eintippt und dann die {\em Return-} ({\em Enter-})Taste drückt.  Um herauszufinden, welche Befehle verfügbar sind, geben Sie \texttt{?} an der Eingabeaufforderung \texttt{MM>} ein.  Um herauszufinden, welche Möglichkeiten Sie an einer beliebigen Stelle eines Befehls haben, drücken Sie {\em return} und Sie werden dazu aufgefordert eine angegebene Möglichkeit auszuwählen.  Die Standardauswahl (diejenige, die ausgewählt wird, wenn Sie nur {\em Return} drücken) wird in Klammern angezeigt (\texttt{<>}). 

Sie können auch \texttt{?} anstelle eines Befehlsworts eingeben, um Metamath dazu zu bringen, Ihnen die verfügbaren Möglichkeiten mitzuteilen.  Die Methode \texttt{?} funktioniert allerdings nicht, wenn an dieser Stelle ein Argument erwartet wird, das kein Schlüsselwort ist, wie z. B. ein Dateiname, weil das Programm dann das \texttt{?} als Wert des Arguments interpretiert. 

Einige Befehle haben einen oder mehrere optionale Parameter, die das Verhalten des Befehls beeinflussen.  Parameter werden mit einem Schrägstrich (\texttt{/}) eingeleitet, wie z. B. in \texttt{read set.mm / verify}.  Leerzeichen um das \texttt{/} sind optional.  Wenn Sie ein Leerzeichen oder einen Schrägstrich in einem Befehlsargument verwenden müssen, wie in einem Unix-Dateinamen, setzen Sie das Befehlsargument in einfache oder doppelte Anführungszeichen. 

Der Befehl \texttt{open log} speichert alles, was Sie auf dem Bildschirm sehen, und ist nützlich, wenn Sie etwas wiederherstellen wollen, falls bei einem Beweis etwas schief geht, oder wenn Sie einen Fehler dokumentieren wollen. 

Wenn ein Befehl mit mehr Zeilen als auf einen Bildschirm passen antwortet, werden Sie aufgefordert, \texttt{<return> zum Fortfahren, Q zum Beenden oder S zum Scrollen zum Ende} einzugeben.  \texttt{Q} oder \texttt{q} (Groß- und Kleinschreibung wird nicht beachtet) führt den Befehl intern zu Ende, unterdrückt aber weitere Ausgaben bis zur nächsten Eingabeaufforderung \texttt{MM>}.  \texttt{s} unterdrückt weitere Pausen bis zur nächsten Eingabeaufforderung \texttt{MM>}.  Nach der ersten Bildschirmseite haben Sie auch die Möglichkeit, mit \texttt{b} eine Bildschirmseite zurückzugehen.  Beachten Sie, dass \texttt{b} auch an der Eingabeaufforderung \texttt{MM>} unmittelbar nach einem Befehl eingegeben werden kann, um durch die Ausgabe dieses Befehls zurückzublättern. 

Eine in Anführungszeichen eingeschlossene Befehlszeile wird von Ihrem Betriebssystem ausgeführt. Siehe Abschnitt~\ref{oscmd}. 

{Warnung:} Wenn Sie {\sc ctrl-c} drücken, wird das Metamath-Programm sofort abgebrochen.  Das bedeutet, dass alle nicht gespeicherten Daten verloren gehen. 


\subsection{\texttt{exit}-Befehl}\index{\texttt{exit}-Befehl}

Syntax:  \texttt{exit} [\texttt{/force}]

Mit diesem Befehl verlässt man Metamath.  Wenn mit den Befehlen \texttt{proof} oder \texttt{save new{\char`\_}proof} Änderungen am Quelltext vorgenommen wurden, erhalten Sie die Möglichkeit, mit \texttt{write source} die Änderungen dauerhaft zu speichern. 

Im Modus "`Beweis-Assistent"'\index{Beweis-Assistent} kehrt man mit dem Befehl \texttt{exit} zur Eingabeaufforderung \verb/MM>/ zurück. Wenn Änderungen am Beweis vorgenommen wurden, erhalten Sie die Möglichkeit, den neuen Beweis mit \texttt{save new{\char`\_}proof} zu speichern. 

Der Befehl \texttt{quit} ist ein Synonym für \texttt{exit}.

Optionaler Befehlszeilenparameter:
\texttt{/force} - Keine Eingabeaufforderung, wenn Änderungen nicht gespeichert wurden.  Dieser Qualifizierer ist in \texttt{submit}-Befehlsdateien (siehe Abschnitt~\ref{sbmt}) nützlich, um ein vorhersehbares Verhalten zu gewährleisten. 


\subsection{\texttt{open log}-Befehl}\index{\texttt{open log}-Befehl}

Syntax:  \texttt{open log} {\em Dateiname}

Mit diesem Befehl wird eine Protokolldatei geöffnet, in der alles gespeichert wird, was Sie auf dem Bildschirm sehen.  Sie ist nützlich, um einen Fehler während einer langen Sitzung mit dem Beweis-Assistenten zu beheben oder um Fehler zu dokumentieren.\index{Metamath!Bug} 

Die Protokolldatei kann mit \texttt{close log} geschlossen werden.  Sie wird automatisch beim Beenden von Metamath geschlossen. 


\subsection{\texttt{close log}-Befehl}\index{\texttt{close log}-Befehl}

Syntax:  \texttt{close log}

Der Befehl \texttt{close log} schließt eine Protokolldatei, falls eine geöffnet ist.  Siehe auch \texttt{open log}. 


\subsection{\texttt{submit}-Befehl}\index{\texttt{submit}-Befehl}\label{sbmt}

Syntax:  \texttt{submit} {\em Dateiname}

Dieser Befehl bewirkt, dass weitere Befehlszeilen aus der angegebenen Datei entnommen und ausgeführt werden.  Beachten Sie, dass jede Zeile, die mit einem Ausrufezeichen (\texttt{!}) beginnt, als Kommentar behandelt (d.h. ignoriert) wird.  Beachten Sie auch, dass die Bildschirmausgabe kontinuierlich durchläuft, so dass Sie eventuell eine Protokolldatei öffnen sollten (siehe \texttt{open log}), um die auf dem Bildschirm vorbeiziehenden Ergebnisse aufzuzeichnen. Nachdem alle Befehlszeilen in der Datei ausgeführt wurden, kehrt Metamath in den normalen Modus der Benutzeroberfläche zurück. 

Der Befehl \texttt{submit} kann rekursiv aufgerufen werden (d.h. ebenfalls innerhalb einer \texttt{submit} Befehlsdatei). 

Optionaler Befehlszeilenparameter:
\texttt{/silent} - unterdrückt die Bildschirmausgabe, zeichnet die Ausgabe aber dennoch in einer Protokolldatei auf, falls eine solche geöffnet ist.  


\subsection{\texttt{erase}-Befehl}\index{\texttt{erase}-Befehl}

Syntax:  \texttt{erase}

Dieser Befehl setzt Metamath auf seinen Ausgangszustand zurück und löscht alle Datenbasen, die mit \texttt{read} eingelesen wurden.  Wenn mit den Befehlen \texttt{save proof} oder \texttt{save new{\char`\_}proof} Änderungen an der Quelldatei vorgenommen wurden, wird Ihnen die Möglichkeit gegeben, \texttt{write source} zu verwenden, um die Änderungen dauerhaft zu speichern. 


\subsection{\texttt{set echo}-Befehl}\index{\texttt{set echo}-Befehl}

Syntax:  \texttt{set echo on} or \texttt{set echo off}

Der Befehl \texttt{set echo on} bewirkt, dass die Befehlszeilen mit erweiterten Abkürzungen wiedergegeben werden.  Beim Erlernen der Metamath-Befehle zeigt Ihnen diese Funktion genau den Befehl an, dem Ihre abgekürzte Eingabe entspricht. 


\subsection{\texttt{set scroll}-Befehl}\index{\texttt{set scroll}-Befehl}

Syntax:  \texttt{set scroll prompted} oder \texttt{set scroll continuous}

Die Metamath-Befehlszeilenschnittstelle startet im Modus \texttt{prompted}, was bedeutet, dass Sie nach jedem Vollbild in einer langen Auflistung zum Fortfahren oder Beenden aufgefordert werden.  Im Modus \texttt{continuous} werden lange Auflistungen ohne Pause durchlaufen. 


\subsection{\texttt{set width}-Befehl}\index{\texttt{set
width}-Befehl}

Syntax:  \texttt{set width} {\em Zahl}

Metamath geht davon aus, dass die Breite Ihres Bildschirms 79 Zeichen beträgt (dies wurde gewählt, weil die Eingabeaufforderung in Windows XP einen Umbruchfehler bei Spalte 80 aufweist).  Wenn Ihr Bildschirm breiter oder schmaler ist, können Sie mit diesem Befehl die Standardbreite des Bildschirms ändern.  Eine größere Breite ist vorteilhaft für die Protokollierung von Beweisen in einer Ausgabedatei, die auf einem breiten Drucker gedruckt werden soll.  Auf manchen Terminals kann eine geringere Breite erforderlich sein; in diesem Fall kann der Umbruch der Informationsmeldungen jedoch manchmal etwas unnatürlich wirken.  In \LaTeX\index{latex@{\LaTeX}!Zeichen pro Zeile} gibt es normalerweise maximal 61 Zeichen pro Zeile mit Schreibmaschinenschrift (die Beispiele in diesem Buch wurden mit 61 Zeichen pro Zeile erstellt). 


\subsection{\texttt{set height}-Befehl}\index{\texttt{set
height}-Befehl}

Syntax:  \texttt{set height} {\em Zahl}

Metamath geht davon aus, dass Ihre Bildschirmhöhe 24 Zeilen an Zeichen beträgt.  Wenn Ihr Bildschirm größer oder kleiner ist, können Sie mit diesem Befehl die Anzahl der Zeilen ändern, bei denen die Anzeige pausiert und Sie zum Fortfahren auffordert. 


\subsection{\texttt{beep}-Befehl}\index{\texttt{beep}-Befehl}

Syntax:  \texttt{beep}

Bei diesem Befehl ertönt ein Piepton.  Wenn Sie ihn vor dem Start eines lang laufenden Befehls eingeben, werden Sie darauf hingewiesen, dass der Befehl beendet ist.  Der Einfachheit halber ist \texttt{b} eine Abkürzung für \texttt{beep}. 

Hinweis: Wenn \texttt{b} an der Eingabeaufforderung \texttt{MM>} unmittelbar nach dem Ende einer mehrseitigen Anzeige mit der Aufforderung "`\texttt{Press <return> for more}..."' eingegeben wird, kehrt der \texttt{b} zur vorherigen Seite zurück, anstatt den Befehl \texttt{beep} auszuführen. In diesem Fall müssen Sie die ungekürzte \texttt{beep}-Form des Befehls eingeben. 


\subsection{\texttt{more}-Befehl}\index{\texttt{more}-Befehl}

Syntax:  \texttt{more} {\em Dateiname}

Dieser Befehl zeigt den Inhalt einer {\sc ascii}-Datei auf dem Bildschirm an.  

(Dieser Befehl dient der Bequemlichkeit, ist aber nicht sehr leistungsfähig.  Siehe Abschnitt~\ref{oscmd}, um den entsprechenden Befehl Ihres Betriebssystems aufzurufen, z. B. den Befehl \texttt{more} unter Unix). 


\subsection{Betriebssystem-Befehle}\index{Betriebssystem-Befehl}\label{oscmd}

Eine in einfache oder doppelte Anführungszeichen eingeschlossene Zeile wird vom Betriebssystem Ihres Computers ausgeführt, wenn dieses über eine Befehlszeilenschnittstelle verfügt.  Auf einem {\sc vax/vms}-System wird beispielsweise \verb/MM> 'dir'/ den Inhalt des Festplattenverzeichnisses ausgeben.  Beachten Sie, dass diese Funktion auf Macintosh-Systemen vor Mac OS X, die keine Befehlszeilenschnittstelle haben, nicht funktioniert.  

Der Einfachheit halber ist das Anführungszeichen am Ende optional. 


\subsection{Größenbeschränkungen in Metamath}

Im Allgemeinen gibt es keine festen, vordefinierten Grenzen\index{Metamath!Memory-Limits} dafür, wie viele Labels, Token\index{Token}, Anweisungen usw. Sie in einer Datenbasisdatei verwenden können.  Das Metamath-Programm verwendet 32-Bit-Variablen (64-Bit auf 64-Bit-CPUs) als Indizes für fast alle internen Arrays, die bei Bedarf dynamisch zugewiesen werden.  


\section{Lesen und Schreiben von Dateien}

Die folgenden Befehle erstellen neue Dateien: die \texttt{open}-Befehle; die \texttt{write}-Befehle; die Optionen \texttt{/html}, \texttt{/alt{\char`\_}html}, \texttt{/brief{\char`\_}html}, \texttt{/brief{\char`\_}alt{\char`\_}html} von \texttt{show statement}, und \texttt{midi}.  Die folgenden Befehle werden an zuvor geöffnete Dateien angehängt: die Option \texttt{/tex} von \texttt{show proof} und \texttt{show new{\char`\_}proof}; die Optionen \texttt{/tex} und \texttt{/simple{\char`\_}tex} von \texttt{show statement}; die Befehle \texttt{close}; und alle Bildschirmdialoge zwischen \texttt{open log} und \texttt{close log}. 

Die Befehle, die neue Dateien erstellen, überschreiben keine vorhandenen {\em Dateinamen}, sondern benennen die vorhandene Datei in {\em Dateiname}\texttt{{\char`\~}1} um.  Ein vorhandener {\em Dateiname}\texttt{{\char`\~}1} wird umbenannt in {\em Dateiname}\texttt{{\char`\~}2}, usw.\ bis zu {\em Dateiname}\texttt{{\char`\~}9}.  Ein vorhandener {\em Dateiname}\texttt{{\char`\~}9} wird gelöscht.  Dies erleichtert die Wiederherstellung nach Fehlern, bringt aber auch Unordnung in Ihr Verzeichnis, so dass Sie gelegentlich diese \texttt{{\char`\~}}$n$-Dateien bereinigen (löschen) sollten. 


\subsection{\texttt{read}-Befehl}\index{\texttt{read}-Befehl}

Syntax:  \texttt{read} {\em Dateiname} [\texttt{/verify}]

Mit diesem Befehl wird eine Quelldatei in der Metamath-Sprache und alle darin referenzierten Dateien eingelesen.  Normalerweise ist es das erste, was Sie tun, wenn Sie mit Metamath beginnen. Die Syntax der Anweisungen wird überprüft, die Syntax der Beweise jedoch nicht. Beachten Sie, dass der Dateiname in einfache oder doppelte Anführungszeichen eingeschlossen werden kann; dies ist nützlich, wenn der Dateiname Schrägstriche enthält, wie es unter Unix der Fall sein kann. 

Falls Sie eine "`\texttt{?Expected VERIFY}"' Fehlermeldung erhalten, wenn Sie versuchen einen Unix-Dateinamen mit Schrägstrichen zu lesen, haben Sie ihn wahrscheinlich nicht in Anführungszeichen gesetzt.\index{Unix-Dateinamen}\index{Dateinamen!Unix}

Wenn Sie zur Eingabe des Dateinamens aufgefordert werden (durch Drücken von {\em Enter} nach \texttt{read}), sollten Sie ihn {\em nicht} in Anführungszeichen setzen, auch wenn es sich um einen Unix-Dateinamen mit Schrägstrichen handelt. 

Optionaler Befehlszeilenparameter:

    \texttt{/verify} - Überprüft alle Beweise beim Einlesen der Datenbasis.  Diese Option verlangsamt das Einlesen der Datei.  Siehe \texttt{verify proof} für weitere Informationen zur Fehlerprüfung von Dateien.

Siehe auch \texttt{erase}.


\subsection{\texttt{write source}-Befehl}\index{\texttt{write source}-Befehl}

Syntax:  \texttt{write source} {\em filename}
[\texttt{/rewrap}]
[\texttt{/split}]
% TeX doesn't handle this long line with tt text very well,
% so force a line break here.
[\texttt{/keep\_includes}] {\\}
[\texttt{/no\_versioning}]

Mit diesem Befehl wird der Inhalt einer Metamath-Datenbasis\index{Datenbasis} in eine Datei\index{Quelldatei} geschrieben.

Optionale Befehlszeilenparameter:

\texttt{/rewrap} - Formatiert Anweisungen und Kommentare entsprechend der in der set.mm-Datenbasis verwendeten Konvention um. Es hebt den Zeilenumbruch im Kommentar vor jeder \texttt{\$a}- und \texttt{\$p}-Anweisung auf und bricht die Zeile dann neu um.  Sie sollten die Ausgabe mit dem Original vergleichen, um sicherzustellen, dass der gewünschte Effekt erzielt wird; falls nicht, gehen Sie zurück zum Original.  Die Länge der umgebrochenen Zeile berücksichtigt den aktuell gültigen Parameter \texttt{set width}.  

Hinweis: Text, der in \texttt{<HTML>}...\texttt{</HTML>}-Tags eingeschlossen ist, wird durch den Qualifier \texttt{/rewrap} nicht verändert. Beweise selbst werden nicht umformatiert; verwenden Sie dazu \texttt{save proof * / compressed}. Eine isolierte Tilde (\~{}) wird immer in derselben Zeile wie das folgende Symbol gehalten, so dass Sie alle Kommentarverweise auf ein Symbol finden können, indem Sie nach \~{}, gefolgt von einem Leerzeichen und dem Symbol, suchen (dies ist nützlich, um Querverweise zu finden). Übrigens, \texttt{save proof} beachtet auch den derzeit gültigen Parameter \texttt{set width}.

\texttt{/split} - 
Dateien, die mit dem Ausdruck \$[ \textit{inclfile} \$] in den Quelltext inkludiert werden, werden in separate Dateien geschrieben, anstatt in eine einzige Ausgabedatei aufgenommen zu werden.  Der Name jeder separat geschriebenen Datei ist das Argument \textit{inclfile} des Include-Befehls. 

\texttt{/keep\_includes} - 
Wenn eine Quelldatei inkludierte Dateien hat, aber durch Weglassen von \texttt{/split} als einzelne Datei geschrieben wird, werden die inkludierten Dateien standardmäßig gelöscht (eigentlich nur mit einem Suffix \char`\~1 umbenannt, es sei denn, \texttt{/no\_versioning} ist gesetzt), um die möglicherweise verwirrende Quelldateiduplikation sowohl in der Ausgabedatei als auch in der inkludierten Datei zu verhindern. Die Option \texttt{/keep\_includes} verhindert diese Löschung. 

\texttt{/no\_versioning} - 
Sicherungsdateien mit dem Suffix \char`\~1 werden nicht erstellt.


\section{Anzeige von Status und Anweisungen}

\subsection{\texttt{show settings}-Befehl}\index{\texttt{show settings}-Befehl}

Syntax:  \texttt{show settings}

Dieser Befehl zeigt den Zustand verschiedener Parameter an.

\subsection{\texttt{show memory}-Befehl}\index{\texttt{show memory}-Befehl}

Syntax:  \texttt{show memory}

Dieser Befehl zeigt den noch verfügbaren Speicher an.  Er ist auf den meisten modernen Betriebssystemen, die über virtuellen Speicher verfügen, nicht aussagekräftig.\index{Metamath!Memory-Nutzung} 

\subsection{\texttt{show labels}-Befehl}\index{\texttt{show labels}-Befehl}

Syntax:  \texttt{show labels} {\em label-match} [\texttt{/all}]
   [\texttt{/linear}]

Dieser Befehl zeigt die Labels von \texttt{\$a}- und \texttt{\$p}-Anweisungen an, die auf {\em label-match} passen.  Ein \verb$*$ in {label-match} ist ein Platzhalter für null oder mehr beliebige Zeichen.  Zum Beispiel passt \verb$*abc*def$ auf alle Labels, die \verb$abc$ enthalten und mit \verb$def$ enden. 

Optionale Befehlszeilenparameter:

   \texttt{/all} - 
    Übereinstimmungen für \texttt{\$e}- und \texttt{\$f}-Anweisungslabels einschließen.

   \texttt{/linear} - 
    Nur ein Label pro Zeile anzeigen.  Dies kann für die Erstellung von Skripten in Verbindung mit den Dienstprogrammen unter dem Befehl \texttt{tools}\index{\texttt{tools}-Befehl} nützlich sein. 


\subsection{\texttt{show statement}-Befehl}\index{\texttt{show statement}-Befehl}

Syntax:  \texttt{show statement} {\em label-match} [{\em qualifiers} (siehe unten)]

Dieser Befehl liefert Informationen über eine Anweisung.  Es können nur Anweisungen mit Labels (\texttt{\$f}\index{\texttt{\$f}-Anweisung}, 
\texttt{\$e}\index{\texttt{\$e}-Anweisung}, 
\texttt{\$a}\index{\texttt{\$a}-Anweisung}, und 
\texttt{\$p}\index{\texttt{\$p}-Anweisung}) angegeben werden. 
Wenn {\em label-match} Platzhalterzeichen (\verb$*$) enthält, werden alle übereinstimmenden Anweisungen in der Reihenfolge angezeigt, in der sie in der Datenbasis vorkommen. 

Optionale Befehlszeilenparameter ({\em qualifiers}, es ist jeweils nur ein Parameter zulässig):

    \texttt{/comment} - 
    Diese Option schließt den Kommentar ein, der der Anweisung unmittelbar vorausgeht.

    \texttt{/full} - 
    Zeigt vollständige Informationen zu jeder Anweisung an, und zwar für alle Anweisungen, die mit {\em label} übereinstimmen (einschließlich der \texttt{\$e}- und \texttt{\$f}-Anweisungen).

    \texttt{/tex} - 
    Diese Option schreibt die Anweisungsinformationen in die \LaTeX-Datei, die zuvor mit \texttt{open tex} geöffnet wurde.  Siehe Abschnitt~\ref{texout}.

    \texttt{/simple{\char`\_}tex} - 
    Wie \texttt{/tex} mit dem Unterschied, dass \LaTeX-Makros nicht für die Formatierung von Gleichungen verwendet werden, was eine einfachere manuelle Bearbeitung der Ausgabe für Folienpräsentationen usw. ermöglicht.

    \texttt{/html}\index{HTML generierung@{\sc html} generation},
    \texttt{/alt{\char`\_}html}, \texttt{/brief{\char`\_}html},
    \texttt{/brief{\char`\_}alt{\char`\_}html} -
    Diese Optionen aktivieren einen speziellen Modus von \texttt{show statement}, der eine Webseite für die Anweisung erstellt.  Sie dürfen nicht zusammen mit einem anderen Qualifizierer verwendet werden.  Siehe Abschnitt~\ref{htmlout} oder \texttt{help html} im Programm. 


\subsection{\texttt{search}-Befehl}\index{\texttt{search}-Befehl}

Syntax:  search {\em label-match}
\texttt{\char`\"}{\em symbol-match}\texttt{\char`\"} [\texttt{/all}] [\texttt{/comments}]
[\texttt{/join}]

Dieser Befehl durchsucht alle \texttt{\$a}- und \texttt{\$p}-Anweisungen, die mit {\em label-match} übereinstimmen, nach Vorkommen von {\em symbol-match}.  Ein \verb@*@ in {\em label-match} entspricht einem beliebigen Label-Zeichen.  Ein \verb@$*@ in {\em symbol-match} passt auf eine beliebige Folge von Symbolen.  Die Symbole in {\em symbol-match} müssen durch einen Whitespace getrennt sein.  Die Anführungszeichen, die {\em symbol-match} umgeben, können einfache oder doppelte Anführungszeichen sein.  Zum Beispiel listet \texttt{search b}\verb@* "-> $* ch"@ alle Anweisungen auf, deren Label mit \texttt{b} beginnen und die Symbole \verb@->@ und \texttt{ch} enthalten, die eine beliebige Symbolfolge umgeben (einschließlich keiner Symbolfolge).  Die Platzhalter \texttt{?} und \texttt{\$?} sind auch verfügbar, um einzelne Zeichen in Labels bzw. Symbolen zu finden; siehe \texttt{help search} im Metamath-Programm für Details zu ihrer Verwendung. 

Optionale Befehlszeilenparameter:

    \texttt{/all} - Suche auch nach \texttt{\$e}- und \texttt{\$f}-Anweisungen.

    \texttt{/comments} - Sucht auch in dem Kommentar, der jeder Anweisung mit Label-Matching unmittelbar vorausgeht, nach {\em symbol-match}.  In diesem Fall ist {\em symbol-match} eine beliebige, nicht von Groß- und Kleinschreibung abhängige Zeichenkette.  Anführungszeichen um {\em symbol-match} sind optional, wenn es keine Mehrdeutigkeit gibt.

    \texttt{/join} - Im Falle einer \texttt{\$a}- oder \texttt{\$p}-Anweisung werden deren \texttt{\$e}-Hypothesen für die Suche vorangestellt. Die Option \texttt{/join} hat im Modus \texttt{/comments} keine Wirkung.


\section{Anzeigen und Verifizieren von Beweisen}

\subsection{\texttt{show proof}-Befehl}\index{\texttt{show proof}-Befehl}

Syntax:  \texttt{show proof} {\em label-match} [{\em qualifiers} (siehe unten)]

Mit diesem Befehl wird der Beweis der angegebenen \texttt{\$p}-Anweisung\index{\texttt{\$p}-Anweisung} in verschiedenen Formaten angezeigt. Der Parameter {\em label-match} kann Platzhalterzeichen (\verb@$*@) enthalten, um mehrere Anweisungen anzuzeigen.  Ohne Optionen ({\em qualifiers}) werden nur die logischen Schritte in einem eingerückten Format angezeigt (d.h. die Syntaxkonstruktionsschritte werden weggelassen). 

In den meisten Fällen werden Sie \texttt{show proof} {\em label} verwenden, um nur die Beweisschritte zu sehen, die logischen Schlussfolgerungen entsprechen. 

Optionale Befehlszeilenparameter:

    \texttt{/essential} - Der Beweisbaum wird vor der Anzeige um alle Hypothesen (\texttt{\$f}-Anweisungen\index{\texttt{\$f}-Anweisung}) bereinigt.  (Dies ist die Voreinstellung und muss deshalb nicht angegeben werden).

    \texttt{/all} - Der Beweisbaum wird vor der Anzeige nicht von allen \texttt{\$f}-Hypothesen bereinigt.  \texttt{/essential} und \texttt{/all} schließen sich gegenseitig aus.

    \texttt{/from{\char`\_}step} {\em step} - Die Anzeige beginnt mit dem angegebenen Schritt.  Wird diese Option weggelassen, beginnt die Anzeige beim ersten Schritt.

    \texttt{/to{\char`\_}step} {\em step} - Die Anzeige endet mit dem angegebenen Schritt.  Wird diese Option weggelassen, endet die Anzeige beim letzten Schritt.

    \texttt{/tree{\char`\_}depth} {\em number} - Es werden nur Schritte angezeigt, die weniger als die angegebene Tiefe des Beweisbaums haben.  Manchmal nützlich, um einen Überblick über den Beweis zu erhalten.

    \texttt{/reverse} - Die Schritte werden in umgekehrter Reihenfolge angezeigt.

    \texttt{/renumber} - Bei Verwendung mit \texttt{/essential} werden die Schritte neu nummeriert und entsprechen nur den wesentlichen Schritten.

    \texttt{/tex} - Der Beweis wird in \LaTeX\ konvertiert und\index{latex@{\LaTeX}} in der mit \texttt{open tex} geöffneten Datei gespeichert.  Siehe Abschnitt~\ref{texout} oder \texttt{help tex} im Programm.

    \texttt{/lemmon} - Der Beweis wird in einem nicht eingerückten Format angezeigt, das als Lemmon-Stil bekannt ist, mit expliziten Verweisen auf vorherige Schrittnummern. Wird diese Option weggelassen, werden die Schritte in einem Baumformat eingerückt.

    \texttt{/start{\char`\_}column} {\em number} - Setzt die Standardspalte (16) außer Kraft, bei der die Formelanzeige in einer Lemmon-Anzeige beginnt.  Kann nur in Verbindung mit \texttt{/lemmon} verwendet werden.

    \texttt{/normal} - Der Beweis wird in einem normalen Format angezeigt, das sich zur Aufnahme in eine Metamath-Quelldatei eignet.  Darf nicht mit einer anderen Option verwendet werden.

    \texttt{/compressed} - Der Beweis wird in einem komprimierten Format angezeigt, das sich zur Aufnahme in eine Metamath-Quelldatei eignet.  Darf nicht mit einer anderen Option verwendet werden.

    \texttt{/statement{\char`\_}summary} - Gibt einen Überblick über alle Anweisungen (wie mit \texttt{show statement}), die im Beweis verwendet werden.  Er darf nicht mit einer anderen Option außer \texttt{/essential} verwendet werden.

    \texttt{/detailed{\char`\_}step} {\em step} - Zeigt an, was in einem bestimmten Schritt des Beweises im Einzelnen geschieht.  Darf nicht mit einer anderen Option verwendet werden.  Der Schritt {\em step} ist die Schrittnummer, die angezeigt wird, wenn ein Beweis ohne die Option \texttt{/renumber} dargestellt wird.


\subsection{\texttt{show usage}-Befehl}\index{\texttt{show usage}-Befehl}

Syntax:  \texttt{show usage} {\em label-match} [\texttt{/recursive}]

Dieser Befehl listet die Anweisungen auf, deren Beweise sich direkt auf die angegebene Anweisung beziehen.

Optionaler Befehlszeilenparameter:

    \texttt{/recursive} - Dazu gehören auch Anweisungen, deren Beweise letztlich von der angegebenen Anweisung abhängen. 


\subsection{\texttt{show trace\_back}-Befehl}\index{\texttt{show
       trace{\char`\_}back}-Befehl}
   
Syntax:  \texttt{show trace{\char`\_}back} {\em label-match} [\texttt{/essential}] [\texttt{/axioms}]
    [\texttt{/tree}] {\\} [\texttt{/depth} {\em number}]

Dieser Befehl listet alle Anweisungen auf, von denen der Beweis der durch {\em label-match} angegebenen Anweisung(en) abhängt. 
    
Optionale Befehlszeilenparameter:

    \texttt{/essential} - Beschränkt die Rückverfolgung auf \texttt{\$e}\index{\texttt{\$e}-Anweisung}-Hypothesen von Beweisbäumen.

    \texttt{/axioms} - Führt nur die Axiome auf, von denen der Beweis letztlich abhängt.

    \texttt{/tree} - Anzeige der Rückverfolgung in einem eingerückten Baumformat.

    \texttt{/depth} {\em number} - Schränkt die \texttt{/tree}-Rückverfolgung auf die angegebene Einrückungstiefe ein.

    \texttt{/count{\char`\_}steps} - Zählt die Anzahl der Schritte, die der Beweis bis zu den Axiomen zurückführt.  Wenn \texttt{/essential} angegeben ist, werden Expansionen von Hypothesen vom Variablentyp (Syntaxkonstruktionen) nicht gezählt. 


\subsection{\texttt{verify proof}-Befehl}\index{\texttt{verify proof}-Befehl}

Syntax:  \texttt{verify proof} {\em label-match} [\texttt{/syntax{\char`\_}only}]

Mit diesem Befehl werden die Beweise der angegebenen Aussagen überprüft.  Die Option {\em label-match} kann Platzhalterzeichen (\texttt{*}) enthalten, um mehr als einen Beweis zu überprüfen; zum Beispiel wird \verb/*abc*def/ auf alle Labels passen, die \texttt{abc} enthalten und mit \texttt{def} enden. Der Befehl \texttt{verify proof *} prüft alle Beweise in der Datenbasis. 

Optionaler Befehlszeilenparameter:

    \texttt{/syntax{\char`\_}only} - Mit dieser Option wird nur auf Syntax- und RPN-Stack-Verletzungen geprüft.  Es wird nicht geprüft, ob der Beweis korrekt ist.  Diese Option ist nützlich um schnell festzustellen, welche Beweise unvollständig sind (d.h. in der Entwicklung sind und \texttt{?}'s in ihnen enthalten sind).

{\em Anmerkung:} \texttt{read}, gefolgt von \texttt{verify proof *}, stellt sicher, dass die Datenbasis frei von Fehlern in der Metamath-Sprache ist, überprüft aber nicht die Auszeichnungsnotation in Kommentaren. Sie können die Auszeichnungsnotation auch überprüfen, indem Sie \texttt{verify markup *} ausführen, wie in Abschnitt~\ref{verifymarkup} beschrieben; siehe auch die Diskussion über die Erzeugung von {\sc HTML} in Abschnitt~\ref{htmlout}. 


\subsection{\texttt{verify markup}-Befehl}\index{\texttt{verify markup}-Befehl}\label{verifymarkup}

Syntax:  \texttt{verify markup} {\em label-match}
[\texttt{/date{\char`\_}skip}]
[\texttt{/top{\char`\_}date{\char`\_}skip}] {\\}
[\texttt{/file{\char`\_}skip}]
[\texttt{/verbose}]

Dieser Befehl überprüft Kommentarauszeichnungen und andere informelle Konventionen, die wir festgesetzt haben.  Er prüft die latexdef-, htmldef- und althtmldef-Anweisungen in der \texttt{\$t}-Anweisung einer Metamath-Quelldatei auf Fehler. Es prüft alle \texttt{`}...\texttt{`}, \texttt{\char`\~}~\textit{Label} und bibliographischen Markierungen in Anweisungsbeschreibungen auf Fehler. Es wird geprüft, ob \texttt{\$p}- und \texttt{\$a}-Anweisungen den gleichen Inhalt haben, wenn ihre Labels mit "`ax"' bzw. "`ax-"' beginnen, aber ansonsten identisch sind, zum Beispiel ax4 und ax-4. Er überprüft auch die Datumsübereinstimmung von "`(Contributed by...)"', "`(Revised by...)"' und "`(Proof shortened by...)"' in dem Kommentar über jeder \texttt{\$a}- und \texttt{\$p}-Anweisung. 

Optionale Befehlszeilenparameter:

    \texttt{/date{\char`\_}skip} - Mit dieser Option wird die Prüfung der Datums\-über\-ein\-stimmung übersprungen, die normalerweise für andere Datenbasen als \texttt{set.mm} nicht erforderlich ist.

    \texttt{/top{\char`\_}date{\char`\_}skip} - Mit dieser Option wird die Datumsübereinstimmung geprüft, mit der Ausnahme, dass das Versionsdatum am Anfang der Datenbasisdatei nicht geprüft wird.  Es kann nur eine der beiden Optionen \texttt{/date{\char`\_}skip} und \texttt{/top{\char`\_}date{\char`\_}skip} angegeben werden.

    \texttt{/file{\char`\_}skip} - Mit dieser Option werden Prüfungen übersprungen, die das Vorhandensein externer Dateien voraussetzen, wie z. B. die Überprüfung des Vorhandenseins von GIFs und bibliografischen Links zu mmset.html oder Ähnlichem.  Dies ist nützlich, um eine schnelle Prüfung aus einem Verzeichnis ohne diese Dateien durchzuführen.

    \texttt{/verbose} - Liefert mehr Informationen.  Gegenwärtig wird eine Liste der Übereinstimmungen zwischen axXXX und ax-XXX angezeigt.


\subsection{\texttt{save proof}-Befehl}\index{\texttt{save proof}-Befehl}

Syntax:  \texttt{save proof} {\em label-match} [\texttt{/normal}]
   [\texttt{/compressed}]

   Der Befehl \texttt{save proof} formatiert einen Beweis in einem von zwei Formaten neu und ersetzt den vorhandenen Beweis im Quellpuffer\index{Quellpuffer}.  Er ist nützlich, um zwischen verschiedenen Formaten von Beweisen zu konvertieren.  Beachten Sie, dass ein Beweis erst dann dauerhaft gespeichert wird, wenn Sie den Befehl \texttt{write source} ausführen. 

Optionale Befehlszeilenparameter:

    \texttt{/normal} - Der Beweis wird im normalen Format gespeichert (d. h. als eine Folge von Labels, was dem definierten Format der Metamath-Basissprache entspricht).\index{grundlegende Sprache}  Dies ist das Standardformat, das verwendet wird, wenn keine Option angegeben wird.

    \texttt{/compressed} - Der Beweis wird im komprimierten Format gespeichert, was den Speicherbedarf für eine Datenbasis reduziert. Siehe Anhang~\ref{compressed}.


\section{Beweise erstellen}\label{pfcommands}\index{Beweis-Assistent}

Bevor Sie den Beweis-Assistenten verwenden, müssen Sie (mit einem Texteditor) eine \texttt{\$p}-Anweisung in Ihre Quelldatei einfügen, der die zu beweisende Aussage enthält.  Der Beweis sollte aus einem einzigen \texttt{?} bestehen, was "`unbekannter Schritt"' bedeutet.  Beispiel:
\begin{verbatim}
equid $p x = x $= ? $.
\end{verbatim}

Um den Beweis-Assistenten aufzurufen, geben Sie \texttt{prove} {\em label} ein, z.B. \texttt{prove equid}.  Metamath antwortet mit der Eingabeaufforderung \texttt{MM-PA>}.

Beweise werden ausgehend von der zu beweisenden Anweisung rückwärts erstellt, wobei hauptsächlich eine Reihe von \texttt{assign}-Befehlen verwendet wird.  Ein Beweis ist vollständig, wenn allen Schritten Anweisungen zugewiesen sind und alle Schritte vereinheitlicht wurden und vollständig bekannt sind.  Während der Erstellung eines Beweises lässt Metamath nur Operationen zu, die aufgrund der bis dahin bekannten Daten zulässig sind.  So wird zum Beispiel kein \texttt{assign} mit einer Anweisung zugelassen, die nicht in den unbekannten Beweisschritt, für den die Zuweisung erfolgen soll, eingesetzt werden kann. 

{\em Wichtig:} Der Beweis-Assistent ist kein Werkzeug, das Ihnen hilft, Beweise zu finden.  Er ist nur ein Hilfsmittel, das Ihnen hilft, Beweise zur Datenbasis hinzuzufügen.  Eine Anleitung dazu finden Sie in Abschnitt~\ref{frstprf}. Um die Verwendung des Beweis-Assistenten zu üben, können Sie ein bestehendes Theorem mit  \texttt{prove} bearbeiten, dann alle Schritte mit \texttt{delete all} löschen und den Bewqeis dann mit dem Beweis-Assistenten neu erstellen, während Sie den (vor dem Löschen) angezeigten Beweises betrachten. Es kann sinnvoll sein, die ersten Beweise vollständig selbst zu erarbeiten und von Hand aufzuschreiben, bevor Sie den Beweis-Assistenten benutzen, auch wenn das nicht für jeden geeignet ist. 

{\em Wichtig:} Der Befehl \texttt{undo} ist sehr hilfreich bei der Eingabe eines Beweises, da Sie damit einen zuvor eingegebenen Schritt rückgängig machen können. Außerdem empfehlen wir Ihnen, Ihre Arbeit in einer Protokolldatei (\texttt{open log}) festzuhalten und sie regelmäßig zu speichern (\texttt{save new{\char`\_}proof}, \texttt{write source}). Sie können \texttt{delete} verwenden, um ein \texttt{assign} rückgängig zu machen. Sie können auch \texttt{delete floating{\char`\_}hypotheses}, dann \texttt{initialize all} und dann \texttt{unify all /interactive} verwenden, um ungewollte Vereinheitlichungen, die versehentlich oder durch unpassende \texttt{assign}s gemacht wurden, zu reinitialisieren.  Sie können ein \texttt{delete} nicht rückgängig machen, es sei denn, Sie verwenden ein entsprechendes \texttt{undo} oder \texttt{exit /force} und rufen dann den Beweis-Assistenten erneut auf, um den letzten \texttt{save new{\char`\_}proof} wiederherzustellen.

Die folgenden Befehle stehen im Proof-Assistenten (an der Eingabeaufforderung \texttt{MM-PA>}) zur Verfügung, um Sie bei der Erstellung Ihres Beweises zu unterstützen.  Siehe die einzelnen Befehle für weitere Details. 

\begin{itemize}
\item[]
    \texttt{show new{\char`\_}proof} [\texttt{/all},...] - Zeigt den aktuellen Beweis an.  Sie werden diesen Befehl häufig verwenden; siehe \texttt{help show new{\char`\_}proof}, um sich mit seinen Optionen vertraut zu machen.  Die Optionen \texttt{/unknown} und \texttt{/not{\char`\_}unified} sind nützlich, um die noch zu erledigende Arbeit anzuzeigen.  Die Kombination \texttt{/all/unknown} ist nützlich, um Dummy-Variablen zu identifizieren, die zugewiesen werden müssen, oder Versuche, ungültige Syntax zu verwenden, wenn \texttt{improve all} nicht in der Lage ist, die Syntaxkonstruktionen abzuschließen.  Unbekannte Variablen werden als \texttt{\$1}, \texttt{\$2}, ... angezeigt.
\item[]
    \texttt{assign} {\em step} {\em label} - Weist einem noch nicht zugeordneten Beweisschritt mit der {\em step}-Nummer die durch {\em label} angegebene Anweisung zu.
\item[]
    \texttt{let variable} {\em variable}
        \texttt{= \char`\"}{\em symbol sequence}\texttt{\char`\"}
          - Erzwingt die Ersetzung einer unbekannten Variablen (z. B. \texttt{\$1}) in einem Beweis durch eine Symbolfolge. Dies ist nützlich, um schwierige Vereinheitlichungen zu erleichtern, und es ist notwendig, wenn Sie Dummy-Variablen nutzen, denen schließlich ein Name zugewiesen werden muss.
\item[]
    \texttt{let step} {\em step} \texttt{= \char`\"}{\em symbol sequence}\texttt{\char`\"} - Erzwingt, dass eine Symbolsequenz den Inhalt eines Beweisschritts ersetzt, sofern sie mit dem vorhandenen Schrittinhalt vereinheitlicht werden kann.  (Ich verwende dies selten.)
\item[]
    \texttt{unify step} {\em step} (oder \texttt{unify all}) - Vereinheitlicht die Quelle und das Ziel eines Schrittes.  Wenn Sie einen bestimmten Schritt angeben, werden Sie aufgefordert, eine der möglichen Vereinheitlichungen auszuwählen.  Wenn Sie \texttt{all} angeben, werden alle Schritte mit eindeutigen Vereinheitlichungen vereinheitlicht, aber nur diese Schritte.  \texttt{unify all /interactive} geht durch alle nicht vereinheitlichten Schritte.
\item[]
    \texttt{initialize} {\em step} (oder \texttt{all}) - Entkoppelt das Ziel und die Quelle eines Schritts (oder aller Schritte) sowie die Hypothesen der Quelle und macht alle Variablen in der Quelle unbekannt.  Nützlich, um einen \texttt{assign}- oder \texttt{let}-Fehler zu beheben, der zu falschen Vereinheitlichungen führte.
\item[]
    \texttt{delete} {\em step} (oder \texttt{all} oder \texttt{floating{\char`\_}hypotheses}) - Löscht den/die angegebenen Schritt(e).  \texttt{delete floating{\char`\_}hypotheses}, dann\linebreak
    \texttt{initialize all}, dann \texttt{unify all /interactive} ist nützlich, um Fehler zu beheben, bei denen falsche Vereinheitlichungen den Variablen falsche mathematische Symbolfolgen zugewiesen haben.
\item[]
    \texttt{improve} {\em step} (oder \texttt{all}) - Erstellt automatisch einen Beweis für Schritte (ohne unbekannte Variablen), deren Beweis keine Anweisungen mit \texttt{\$e}-Hypothesen erfordert.  Nützlich zum Ausfüllen von Beweisen für \texttt{\$f}-Hypothesen.  Die Option \texttt{/depth} versucht dies auch mit Anweisungen, deren \texttt{\$e}-Hypothesen keine neuen Variablen enthalten.  {Warnung:} Speichern Sie Ihre Arbeit (mit \texttt{save new{\char`\_}proof} und dann \texttt{write source}), bevor Sie \texttt{/depth = 2} oder größer verwenden, da die Suchzeit exponentiell ansteigt und möglicherweise nie in einer angemessenen Zeit beendet wird, und Sie können die Suche nicht unterbrechen.  Ich habe festgestellt, dass \texttt{/depth = 3} oder größer nur selten nützlich ist.
 \item[]
    \texttt{save new{\char`\_}proof} - Speichert den laufenden Beweis im internen Datenbasispuffer des Programms.  Um ihn dauerhaft in der Datenbasisdatei zu speichern, verwenden Sie \texttt{write source} nach \texttt{save new{\char`\_}proof}.  Um zum letzten \texttt{save new{\char`\_}proof} zurückzukehren, beenden Sie mit \texttt{exit /force} den Beweis-Assistenten und starten Sie ihn dann erneut.
 \item[]
    \texttt{match step} {\em step} (oder \texttt{match all}) - Zeigt an, welche Anweisungen für die Anweisung \texttt{assign} möglich sind. (Dieser Befehl ist in seiner jetzigen Form nicht sehr nützlich und wird hoffentlich in Zukunft verbessert werden.  Verwenden Sie in der Zwischenzeit die Anweisung \texttt{search} für Kandidaten, die auf bestimmte Kombinatiuonen von mathematische Token passen.)
 \item[]
 \texttt{minimize{\char`\_}with}\index{\texttt{minimize{\char`\_}with}-Befehl}
% 3/10/07 Note: line-breaking the above results in duplicate index entries
     - Nachdem ein Beweis abgeschlossen ist, können mit diesem Befehl andere Datenbasistheoreme mit dem Beweis abgeglichen werden, um damit ggf. die Größe des Beweises zu verringern.  Siehe \texttt{help minimize{\char`\_}with} im Metamath-Programm für seine Verwendung.
 \item[]
 \texttt{undo}\index{\texttt{undo}-Befehl}
    - Macht die Wirkung eines den Beweis verändernden Befehls rückgängig (alle Befehle außer den oben genannten \texttt{show} und \texttt{save}).
 \item[]
 \texttt{redo}\index{\texttt{redo}-Befehl}
    - Macht ein vorheriges \texttt{undo} wieder rückgängig.
\end{itemize}

Die folgenden Befehle setzen Parameter, die für Ihren Beweis relevant sein können. Konsultieren Sie die einzelnen \texttt{help set}... Befehle. \begin{itemize}
   \item[] \texttt{set unification{\char`\_}timeout}
 \item[]
    \texttt{set search{\char`\_}limit}
  \item[]
    \texttt{set empty{\char`\_}substitution} - Beachten Sie, dass der Standardwert \texttt{off} ist.
\end{itemize}

Geben Sie \texttt{exit} ein, um die Eingabeaufforderung \texttt{MM-PA>} zu verlassen und zur Eingabeaufforderung \texttt{MM>} zurückzukehren. Ein weiteres \texttt{exit} beendet dann Metamath komplett. 


\subsection{\texttt{prove}-Befehl}\index{\texttt{prove}-Befehl}

Syntax:  \texttt{prove} {\em label}

Mit diesem Befehl wird der Beweis-Assistent aufgerufen, mit dem Sie den Beweis der angegebenen Aussage erstellen oder bearbeiten können. Die Eingabeaufforderung in der Befehlszeile ändert sich von \texttt{MM>} zu \texttt{MM-PA>}. 

Hinweis: In der aktuellen Version (0.177) von Metamath\index{Metamath!Limitationen der Version 0.177} prüft der Beweis-Assistent nicht, ob die Einschränkungen für \texttt{\$d}\index{\texttt{\$d}-Anweisung}-Anweisungen eingehalten werden, während ein Beweis erstellt wird.  Nachdem Sie einen Beweis abgeschlossen haben, sollten Sie \texttt{save new{\char`\_}proof} gefolgt von \texttt{verify proof} {\em label} (wobei {\em label} die Anweisung ist, die Sie mit dem Befehl \texttt{prove} beweisen) eingeben, um die \texttt{\$d}-Einschränkungen zu überprüfen. 

Siehe auch: \texttt{exit}


\subsection{\texttt{set unification\_timeout}-Befehl}\index{\texttt{set
unification{\char`\_}timeout}-Befehl}

Syntax:  \texttt{set unification{\char`\_}timeout} {\em number}

(Dieser Befehl ist auch außerhalb des Beweis-Assistenten verfügbar, wirkt sich aber nur auf den Beweis-Assistenten\index{Beweis-Assistent} aus). 

Manchmal meldet der Beweis-Assistent, dass eine Zeitüberschreitung beim Vereinheitlichen aufgetreten ist.  Dies kann passieren, wenn Sie versuchen, Formeln mit vielen temporären Variablen\index{temporäre Variable} (\texttt{\$1}, \texttt{\$2}, usw.) zu vereinheitlichen, da die Zeit für die Berechnung aller möglichen Vereinheitlichungen exponentiell mit der Anzahl der Variablen wachsen kann.  Wenn Sie möchten, dass Metamath sich mehr Mühe gibt (und Sie bereit sind, länger zu warten), können Sie diesen Parameter erhöhen.  \texttt{show settings} zeigt Ihnen den aktuellen Wert an. 


\subsection{\texttt{set empty\_substitution}-Befehl}\index{\texttt{set
empty{\char`\_}substitution}-Befehl}
% These long names can't break well in narrow mode, and even "`sloppy"'
% is not enough. Work around this by not demanding justification.

\begin{flushleft}
Syntax:  \texttt{set empty{\char`\_}substitution on} oder \texttt{set
empty{\char`\_}substitution off}
\end{flushleft}

(Dieser Befehl ist auch außerhalb des Proof-Assistenten verfügbar, wirkt sich aber nur auf den Beweis-Assistenten\index{Beweis-Assistent} aus). 

Die Metamath-Sprache erlaubt es, Variablen durch leere Symbolfolgen\index{leere Substitution} zu ersetzen\index{Substitution!Variable}\index{Variablensubstitution}.  In vielen formalen Systemen\index{formales System} wird dies jedoch nie in einem gültigen Beweis vorkommen.  Die Berücksichtigung dieser Möglichkeit erhöht die Wahrscheinlichkeit mehrdeutiger Vereinheitlichungen\index{mehrdeutige Vereinheitlichung}\index{Vereinheitlichung!mehrdeutig} während der Beweiserstellung. Standardmäßig sind leere Substitutionen nicht erlaubt; für formale Systeme, die sie erfordern, müssen Sie \texttt{set empty{\char`\_}substitution on} setzen. Ein Beispiel, bei dem dieser Parameter \texttt{on} sein muss, wäre ein System, das eine Deduktionsregel implementiert und in dem Deduktionen von leeren Annahmelisten zulässig wären.  Das im Anhang~\ref{MIU} beschriebene MIU-System\index{MIU-System} ist ein weiteres Beispiel.

Es ist besser, diesen Befehl auszuschalten (auf \texttt{off} zu setzen oder zu belassen), wenn Sie mit \texttt{set.mm} arbeiten. Beachten Sie, dass dieser Befehl keinen Einfluss darauf hat, wie Beweise mit dem Befehl \texttt{verify proof} überprüft werden.  Außerhalb des Beweis-Assistenten ist die Ersetzung von leeren Sequenzen für mathematische Symbole immer erlaubt. 


\subsection{\texttt{set search\_limit}-Befehl}\index{\texttt{set
search{\char`\_}limit}-Befehl} 

Syntax:  \texttt{set search{\char`\_}limit} {\em number}

(Dieser Befehl ist auch außerhalb des Proof-Assistenten verfügbar, wirkt sich aber nur auf den Beweis-Assistenten\index{Beweis-Assistent} aus). 

Dieser Befehl legt einen Parameter fest, der bestimmt, wann der Befehl \texttt{improve} im Modus Beweis-Assistent seine Suche nach Vereinheitlichungen beendet.  Wenn Sie möchten, dass \texttt{improve} intensiver sucht, können Sie den Wert erhöhen.  Der Befehl \texttt{show settings} zeigt Ihnen den aktuellen Wert an. 


\subsection{\texttt{show new\_proof}-Befehl}\index{\texttt{show new{\char`\_}proof}-Befehl}

Syntax:  \texttt{show new{\char`\_}proof} [{\em Optionen} (siehe unten)]

Dieser Befehl (nur im Modus Beweis-Assistent verfügbar) zeigt den aktuellen Beweis an.  Er ist identisch mit dem Befehl \texttt{show proof} mit dem Unterschied, dass es kein Argument für die Aussage gibt (da es sich um die zu beweisende Aussage handelt). Außerdem sind die folgenden Optionen nicht verfügbar: 

    \texttt{/statement{\char`\_}summary}

    \texttt{/detailed{\char`\_}step}

Es sind aber die folgenden zusätzlichen Optionen verfügbar:

    \texttt{/unknown} - Zeigt nur Schritte an, denen keine Anweisung zugewiesen ist.

    \texttt{/not{\char`\_}unified} - Zeigt nur Schritte an, die noch nicht vereinheitlicht wurden.

Beachten Sie, dass \texttt{/essential}, \texttt{/depth}, \texttt{/unknown} und \texttt{/not{\char`\_}unified} in jeder beliebigen Kombination verwendet werden können; jede von ihnen filtert effektiv zusätzliche Schritte aus der Beweisanzeige heraus.

Siehe auch:  \texttt{show proof}


\subsection{\texttt{assign}-Befehl}\index{\texttt{assign}-Befehl}

Syntax:   \texttt{assign} {\em step} {\em label} [\texttt{/no{\char`\_}unify}]

   und:   \texttt{assign first} {\em label}

   und:   \texttt{assign last} {\em label}

Dieser Befehl, der nur im Beweis-Assistenten verfügbar ist, ordnet einem unbekannten (d.h. noch nicht zugeordneten) Schritt (einen mit \texttt{?} in der Auflistung \texttt{show new{\char`\_}proof}) die durch {\em label} angegebene Anweisung zu.  Die Zuordnung wird nicht zugelassen, wenn die Anweisung nicht mit dem Schritt vereinheitlicht werden kann. 

Wenn \texttt{last} anstelle der {\em step}-Nummer angegeben wird, wird der letzte Schritt, der von \texttt{show new{\char`\_}proof /unknown} angezeigt wird, verwendet.  Dies kann für die Erstellung eines Beweises mit einer Befehlsdatei nützlich sein (siehe \texttt{help submit}).  Es beschleunigt auch das Erstellen von Beweisen, wenn Sie die Zuordnung für den letzten Schritt kennen. 

Wenn \texttt{first} anstelle der {\em step}-Nummer angegeben wird, wird der erste Schritt verwendet, der durch \texttt{show new{\char`\_}proof /unknown} angezeigt wird. 

Wenn {\em step} 0 oder negativ ist, wird der -{\em step}-te von dem letzten unbekannten Schritt, wie durch \texttt{show new{\char`\_}proof /unknown} gezeigt, verwendet.  \texttt{assign -1} {\em label} weist den vorletzten unbekannten Schritt zu, \texttt{assign -2} {\em label} den vorvorletzten, und \texttt{assign 0} {\em label} ist dasselbe wie \texttt{assign last} {\em label}. 

Optionaler Befehlszeilenparameter:

    \texttt{/no{\char`\_}unify} - der Benutzer wird nicht aufgefordert, eine Vereinheitlichung zu wählen, wenn es mehr als eine Möglichkeit gibt.  Dies ist nützlich für nicht-interaktive Befehlsdateien.  Später kann der Benutzer \texttt{unify all /interactive} wählen. (Die Zuweisung wird immer noch automatisch vereinheitlicht, wenn es nur eine Möglichkeit gibt, und wird abgelehnt, wenn eine Vereinheitlichung nicht möglich ist).


\subsection{\texttt{match}-Befehl}\index{\texttt{match}-Befehl}

Syntax:  \texttt{match step} {\em step} [\texttt{/max{\char`\_}essential{\char`\_}hyp}
{\em number}]

    und:  \texttt{match all} [\texttt{/essential}]
          [\texttt{/max{\char`\_}essential{\char`\_}hyp} {\em number}]

Dieser Befehl, der nur im Beweis-Assistenten verfügbar ist, zeigt an, welche Anweisungen mit dem/den angegebenen Schritt(en) vereinigt werden können.  {\em Hinweis:} In seiner jetzigen Form ist dieser Befehl nicht sehr nützlich, da er eine große Anzahl von Übereinstimmungen anzeigt. Er kann in Zukunft verbessert werden.  In der Zwischenzeit kann der Befehl \texttt{search} oft eine bessere Möglichkeit für das Auffinden von Theoremen von Interesse bieten. 

Optionale Befehlszeilenparameter:

    \texttt{/max{\char`\_}essential{\char`\_}hyp} {\em number} - filtert aus der Liste alle Anweisungen mit mehr als der angegebenen Anzahl von \texttt{\$e}\index{\texttt{\$e}-Anweisung}-Anweisungshypothesen heraus.

    \texttt{/essential{\char`\_}only} - in der Anweisung \texttt{match all} werden nur die Schritte abgeglichen, die in der Anzeige \texttt{show new{\char`\_}proof /essential} aufgelistet wären.


\subsection{\texttt{let}-Befehl}\index{\texttt{let}-Befehl}

Syntax: \texttt{let variable} {\em variable} = \texttt{\char`\"}{\em symbol-sequence}\texttt{\char`\"}

  und: \texttt{let step} {\em step} = \texttt{\char`\"}{\em symbol-sequence}\texttt{\char`\"}

Diese Befehle, die nur im Beweis-Assistenten\index{Beweis-Assistent} verfügbar sind, weisen einer temporären Variable\index{temporäre Variable} oder einem unbekannten Schritt eine bestimmte Symbolfolge zu.  Sie sind während der Erstellung eines Beweises nützlich, wenn Sie wissen, was in dem Beweisschritt enthalten sein soll, der Vereinheitlichungsalgorithmus aber noch nicht genügend Informationen hat, um die temporären Variablen vollständig zu ermitteln.  Eine "`temporäre Variable"' ist eine Variable, die in der Beweisanzeige die Form \texttt{\$}{\em nn} hat, wie z.B. \texttt{\$1}, \texttt{\$2}, usw.  Die {\em Symbolfolge} kann auch andere unbekannte Variablen enthalten, falls gewünscht.  Beispiele: 

    \verb/let variable $32 = "A = B"/

    \verb/let variable $32 = "A = $35"/

    \verb/let step 10 = '|- x = x'/

    \verb/let step -2 = "|- ( $7 = ph )"/

Für den Befehl \texttt{let variable} wird jede beliebige Symbolfolge akzeptiert.  Für \texttt{let step} werden nur solche Symbolfolgen akzeptiert, die mit dem Schritt vereinheitlicht werden können. 

Die \texttt{let}-Befehle "`knallen"' Informationen in den Beweis, die nur verifiziert werden können, wenn der Beweis weiter aufgebaut wird.  Wenn Sie einen \mbox{Fehler} machen, kann die Befehlssequenz \texttt{delete floating{\char`\_}hypotheses},
\texttt{initialize all} und \texttt{unify all /interactive} eine falsche \texttt{let}-Zuweisung rückgängig machen. 

Wenn {\em step} 0 oder negativ ist, wird der -{\em step}-te vom letzten unbekannten Schritt, wie durch \texttt{show new{\char`\_}proof /unknown} gezeigt, verwendet.  Der Befehl \texttt{let step 0} = \texttt{\char`\"}{\em symbol-sequence}\texttt{\char`\"} verwendet den letzten unbekannten Schritt, \texttt{let step -1} = \texttt{\char`\"}{\em symbol-sequence}\texttt{\char`\"} den vorletzten, usw. Wenn {\em step} positiv ist, kann \texttt{let step} verwendet werden, um sowohl bekannte (im Sinne von zuvor mit \texttt{assign} ein Label zugewiesen) als auch unbekannte Schritte zuzuweisen. 

Einfache oder doppelte Anführungszeichen können {\em symbol-sequence} um\-ge\-ben, solange sie sich von allen Anführungszeichen innerhalb einer {\em symbol-sequence} unterscheiden.  Wenn {\em symbol-sequence} beide Arten von Anführungs\-zeichen enthält: siehe die Anweisungen am Ende von \texttt{help let} im Metamath-Programm. 


\subsection{\texttt{unify}-Befehl}\index{\texttt{unify}-Befehl}

Syntax:  \texttt{unify step} {\em step}

      und:   \texttt{unify all} [\texttt{/interactive}]

Diese Befehle, die nur im Beweis-Assistenten verfügbar sind, vereinheitlichen die Quelle und das Ziel des/der angegebenen Schrittes/Schritte. Wenn Sie einen bestimmten Schritt angeben, werden Sie aufgefordert, eine der möglichen Vereinheitlichungen auszuwählen.  Wenn Sie \texttt{all} angeben, werden nur die Schritte mit eindeutigen Vereinheitlichungen vereinheitlicht. 

Optionaler Befehlszeilenparameter für \texttt{unify all}:

    \texttt{/interactive} - Sie werden aufgefordert, eine der möglichen Vereinheitlichungen für alle Schritte auszuwählen, die keine eindeutigen Vereinheitlichungen haben.  (Andernfalls wird \texttt{unify all} diese Schritte übergehen).

Siehe auch \texttt{set unification{\char`\_}timeout}.  Der Standardwert ist 100000, aber eine Erhöhung auf 1000000 kann in problematischen Fällen helfen.  Die manuelle Zuweisung einiger oder aller unbekannten Variablen mit dem Befehl \texttt{let variable} hilft ebenfalls in schwierigen Fällen. 


\subsection{\texttt{initialize}-Befehl}\index{\texttt{initialize}-Befehl}

Syntax:  \texttt{initialize step} {\em step}

    und: \texttt{initialize all}

Diese Befehle, die nur im Beweis-Assistenten\index{Beweis-Assistent} verfügbar sind, "`ent-unifizie\-ren"' das Ziel und die Quelle eines Schrittes (oder aller Schritte), sowie die Hypothesen der Quelle, und machen alle Variablen in der Quelle und die Hypothesen der Quelle unbekannt.  Dieser Befehl ist nützlich, um einen Beweis nach einer falsche Vereinheitlichungen, die durch ein falsches \texttt{assign}, ein falsches \texttt{let} oder einer falschen automatischen Zuordnung entstanden sind, wiederherzustellen.  Ein Teil oder die gesamte Befehlssequenz \texttt{delete floating{\char`\_}hypotheses}, \texttt{initialize all} und \texttt{unify all /interactive}\linebreak
wird den Beweis nach falschen Vereinheitlichungen wiederherstellen.

Siehe auch:  \texttt{unify} und \texttt{delete}


\subsection{\texttt{delete}-Befehl}\index{\texttt{delete}-Befehl}
Syntax:  \texttt{delete step} {\em step}

   und:      \texttt{delete all} -- {\em Achtung: Gefährlich!}

   und:      \texttt{delete floating{\char`\_}hypotheses}

Diese Befehle sind nur im Beweis-Assistenten verfügbar.

Der Befehl \texttt{delete step} löscht den Abschnitt des Beweisbaums, der von dem angegebenen Schritt abzweigt, und lässt den Schritt unbekannt werden. \texttt{delete all} ist äquivalent zu \texttt{delete step} {\em step}, wobei {\em step} der letzte Schritt im Beweis ist (d.h. \ der Anfang des Beweisbaums). 

In den meisten Fällen ist der Befehl \texttt{undo} die beste Methode, um einen vorherigen Schritt rückgängig zu machen. Eine Alternative ist, den letzten Beweis zu speichern, indem Sie den Beweis-Assistenten verlassen und erneut aufrufen. Damit dies funktioniert, sollten Sie eine Protokolldatei öffnen, um Ihre Arbeit zu protokollieren, und den Befehl \texttt{save new{\char`\_}proof} häufig ausführen, insbesondere vor \texttt{delete}. 

\texttt{delete floating{\char`\_}hypotheses} löscht alle Abschnitte des Beweises, die von \texttt{\$f}\index{\texttt{\$f}-Anweisung}-Anweisungen abzweigen.  Es ist manchmal nützlich, dies vor einem \texttt{initialize}-Befehl zu tun, um einen Fehler zu beheben.  Sobald ein Beweis\-schritt mit einer \texttt{\$f}-Hypothese als Ziel vollständig bekannt ist, kann der Befehl \texttt{improve} normalerweise den Beweis für diesen Schritt ausfüllen.  Im Gegensatz zum Löschen von logischen Schritten ist \texttt{delete} \texttt{floating{\char`\_}hypotheses} ein relativ sicherer Befehl, nach dem der Beweis normalerweise leicht wiederhergestellt werden kann. 


\subsection{\texttt{improve}-Befehl}\index{\texttt{improve}-Befehl}
\label{improve}

Syntax:  \texttt{improve} {\em step} [\texttt{/depth} {\em number}]
                                               [\texttt{/no{\char`\_}distinct}]

   und:   \texttt{improve first} [\texttt{/depth} {\em number}]
                                              [\texttt{/no{\char`\_}distinct}]

   und:   \texttt{improve last} [\texttt{/depth} {\em number}]
                                              [\texttt{/no{\char`\_}distinct}]

   und:   \texttt{improve all} [\texttt{/depth} {\em number}]
                                              [\texttt{/no{\char`\_}distinct}]

Diese Befehle, die nur im Beweis-Assistenten\index{Beweis-Assistent} verfügbar sind, versuchen, automatisch Beweise für unbekannte Schritte zu finden, deren Symbolfolgen vollständig bekannt sind.  Sie sind in erster Linie zum Ausfüllen von Beweisen für \texttt{\$f}\index{\texttt{\$f}-Anweisung}-Hypothesen nützlich.  Die Suche wird auf Anweisungen beschränkt, die keine \texttt{\$e}\index{\texttt{\$e}-Anweisung}-Hypothesen enthalten. 

\begin{sloppypar} % narrow
Hinweis: Wenn der Speicher begrenzt ist, kann \texttt{improve all} bei einem großen Beweis den Speicher überlaufen lassen.  Wenn Sie \texttt{set unification{\char`\_}timeout 1} vor \texttt{improve all} verwenden, wird in der Regel eine ausreichende Verbesserung erzielt, um den Beweis später auf einem größeren Computer leicht wiederherzustellen und mittels \texttt{improve} zu vervollständigen.  Warnung:  Wenn der Speicher einmal übergelaufen ist, gibt es keine Möglichkeit für eine Wiederherstellung mehr.  Speichern Sie im Zweifelsfall den Zwischenbeweis (\texttt{save new{\char`\_}proof} und danach \texttt{write source}) vor \texttt{improve all}. 
\end{sloppypar}

Wenn \texttt{last} anstelle von {\em step} number angegeben wird, wird der letzte Schritt, der durch \texttt{show new{\char`\_}proof /unknown} angezeigt wird, verwendet. 

Wenn \texttt{first} anstelle der {\em step} Nummer angegeben wird, wird der erste Schritt verwendet, der durch \texttt{show new{\char`\_}proof /unknown} angezeigt wird. 

Wenn {\em step} 0 oder negativ ist, wird der -{\em step}-te von dem letzten unbekannten Schritt, wie durch \texttt{show new{\char`\_}proof /unknown} gezeigt, verwendet.  \texttt{improve -1} verwendet den vorletzten unbekannten Schritt, \texttt{improve -2} {\em label} den vorvorletzten, und \texttt{improve 0} ist dasselbe wie \texttt{improve last}. 

Optionaler Befehlszeilenparameter:

    \texttt{/depth} {\em number} - Diese Option bewirkt, dass bei der Suche auch Anweisungen mit \texttt{\$e}-Hypothesen (aber keine neuen Variablen in den \texttt{\$e}-Hypothesen) berücksichtigt werden, sofern das Backtracking die angegebene Tiefe nicht überschritten hat. {\em Warnung:}  Versuchen Sie \texttt{/depth 1}, dann \texttt{2}, dann \texttt{3} usw. der Reihe nach wegen möglicher exponentieller Blowups.  Speichern Sie Ihre Arbeit, bevor Sie \texttt{/depth} größer als \texttt{1} ausprobieren!

    \texttt{/no{\char`\_}distinct} - Überspringt Anweisungen, welche \texttt{\$d}\index{\texttt{\$d}-Anweisung}-Anforderungen haben. Diese Option verhindert Zuweisungen, die gegen \texttt{\$d}-Anforderungen verstoßen könnten, aber er könnten dann auch mögliche legale Zuweisungen übersehen werden.

Siehe auch: \texttt{set search{\char`\_}limit}

\subsection{\texttt{save new\_proof}-Befehl}\index{\texttt{save
new{\char`\_}proof}-Befehl}

Syntax:  \texttt{save new{\char`\_}proof} {\em label} [\texttt{/normal}]
   [\texttt{/compressed}]

Der Befehl \texttt{save new{\char`\_}proof} ist nur im Beweis-Assistenten verfügbar.  Er speichert den laufenden Beweis in den Quellpuffer\index{Quellpuffer}.  \texttt{save new{\char`\_}proof} kann verwendet werden, um einen fertigen Beweis zu speichern, oder um einen sich in Bearbeitung befindenden Beweis zu speichern, um ihn später weiter zu bearbeiten.  Wenn ein unvollständiger Beweis gespeichert wird, gehen alle Benutzerzuweisungen mit \texttt{let step} oder \texttt{let variable} verloren, ebenso wie alle mehrdeutigen Vereinheitlichungen\index{mehrdeutige Vereinheitlichung}\index{Vereinheitlichung!mehrdeutig}, die manuell aufgelöst wurden. Um die Wiederherstellung zu erleichtern, kann es hilfreich sein, \texttt{improve all} vor \texttt{save new{\char`\_}proof} zu verwenden, damit der unvollständige Beweis so viele Informationen wie möglich enthält. 

Beachten Sie, dass der Beweis erst dann dauerhaft gespeichert wird, wenn der Befehl \texttt{write source} aufgwerufen wird. 

Optionale Befehlszeilenparameter:

    \texttt{/normal} - Der Beweis wird im normalen Format gespeichert (d. h. als eine Folge von Labels, was dem definierten Format der Metamath-Basissprache entspricht)\index{grundlegende Sprache}.  Dies ist das Standardformat, das verwendet wird, wenn ein Qualifier weggelassen wird.

    \texttt{/compressed} - Der Beweis wird im komprimierten Format gespeichert, was den Speicherbedarf für eine Datenbasis reduziert. (Siehe Anhang~\ref{compressed}.)


\section{Erstellen von \LaTeX-Ausgaben}\label{texout}\index{latex@{\LaTeX}}

Sie können \LaTeX-Ausgaben anhand der Informationen in einer Datenbasis erzeugen. Die Datenbasis muss bereits die erforderlichen Schriftsatzinformationen enthalten (siehe Abschnitt \ref{tcomment} für die Bereitstellung dieser Informationen). 

Die Befehle \texttt{show statement} und \texttt{show proof} haben jeweils einen spe\-zi\-el\-len \texttt{/tex} Befehlszeilenparameter, der eine \LaTeX-Ausgabe erzeugt (Der Befehl \texttt{show statement} verfügt auch über die Option \texttt{/simple{\char`\_}tex} für eine Ausgabe, die leichter von Hand zu bearbeiten ist).  Bevor Sie diese Befehle verwenden können, müssen Sie eine \LaTeX-Datei öffnen, an die Sie ihre Ausgabe senden können.  Eine typische vollständige Sitzung verwendet diese Abfolge von Metamath-Befehlen: 

\begin{verbatim}
read set.mm
open tex example.tex
show statement a1i /tex
show proof a1i /all/lemmon/renumber/tex
show statement uneq2 /tex
show proof uneq2 /all/lemmon/renumber/tex
close tex
\end{verbatim}

Siehe Abschnitt~\ref{mathcomments} für Informationen über Kommentarauszeichnungen und Anhang~\ref{ASCII} für Informationen darüber, wie die Übersetzung von mathematischen Symbolen angegeben wird. 

Um den \LaTeX-Quelltext zu formatieren und zu drucken, benötigen Sie das Programm \LaTeX\, das auf den meisten Linux-Installationen standardmäßig vorhanden und für Windows verfügbar ist.  Um unter Linux eine pdf-Datei zu erstellen, geben Sie normalerweise an der Shell-Eingabeaufforderung Folgendes ein 
\begin{verbatim}
$ pdflatex example.tex
\end{verbatim}

\subsection{\texttt{open tex}-Befehl}\index{\texttt{open tex}-Befehl}

Syntax:  \texttt{open tex} {\em Dateiname} [\texttt{/no{\char`\_}header}]

Dieser Befehl öffnet eine Datei zum Schreiben von \LaTeX-Quelltext\index{latex@{\LaTeX}} und schreibt einen \LaTeX-Header in die Datei. \LaTeX-Quelltext kann mit den Befehlen \texttt{show proof}, \texttt{show new{\char`\_}proof} und \texttt{show statement} unter Verwendung der Option \texttt{/tex} geschrieben werden. 

Die Zuordnung zu \LaTeX-Symbolen wird in einem speziellen Kommentar definiert, der ein \texttt{\$t}-Token enthält, so wie im Anhang~\ref{ASCII} beschrieben. 

Es gibt einen optionalen Befehlszeilenparameter:

    \texttt{/no{\char`\_}header} - Diese Option verhindert, dass ein standardmäßiger \LaTeX-Header und -Trailer in den ausgegebenen \LaTeX-Code aufgenommen wird.


\subsection{\texttt{close tex}-Befehl}\index{\texttt{close tex}-Befehl}

Syntax:  \texttt{close tex}

Dieser Befehl schreibt einen Trailer in jede \LaTeX-Datei\index{latex@{\LaTeX}}, die mit \texttt{open tex} geöffnet wurde (sofern nicht \texttt{/no{\char`\_}header} mit \texttt{open tex} verwendet wurde) und schließt die \LaTeX-Datei. 


\section{Erstellen von {\sc HTML}-Ausgaben}\label{htmlout}

Sie können anhand der Informationen in einer Datenbasis Webseiten generieren. Die Datenbasis muss bereits die notwendigen Schriftsatzinformationen enthalten (siehe Abschnitt \ref{tcomment}, wie man diese Informationen bereitstellt). Die Fähigkeit, {\sc html}-Webseiten zu erzeugen, wurde in Metamath Version 0.07.30 hinzugefügt. 

Um (eine) {\sc html} Ausgabedatei(en) für \texttt{\$a}- oder \texttt{\$p}-Anweisung(en) zu erstellen, verwenden Sie
\begin{quote}
\texttt{show statement} {\em label-match} \texttt{/html}
\end{quote}
Die Ausgabedatei erhält für jede Übereinstimmung den Namen\linebreak
{\em label-match}\texttt{.html}.  Wenn {\em label-match} Platzhalterzeichen (\texttt{*}) enthält, werden für alle Anweisungen mit übereinstimmenden Labels {\sc html}-Dateien erzeugt.  Wenn {\em label-match} einen Platzhalter (\texttt{*}) enthält, werden außerdem zwei zusätzliche Dateien, \texttt{mmdefinitions.html} und \texttt{mmascii.html}, erzeugt.  Um nur diese beiden zusätzlichen Dateien zu erzeugen, können Sie anstelle von {\em label-match} \texttt{?*} verwenden, das mit keinem Label einer Anweisung übereinstimmt. 

Es gibt drei weitere Optionen für \texttt{show statement}, die ebenfalls {\sc HTML}-Code erzeugen.  Diese sind \texttt{/alt{\char`\_}html}, \texttt{/brief{\char`\_}html} und \texttt{/brief{\char`\_}alt{\char`\_}html}, welche im nächsten Abschnitt beschrieben werden. 

Der Befehl 
\begin{quote}
\texttt{show statement} {\em label-match} \texttt{/alt{\char`\_}html}
\end{quote}
bewirkt das Gleiche wie \texttt{show statement} {\em label-match} \texttt{/html}, außer dass der {\sc html}-Code für die Symbole aus \texttt{althtmldef}-Anweisungen anstelle von \texttt{htmldef}-Anweisungen im \texttt{\$t}-Kommentar entnommen wird. 

Der Befehl 
\begin{verbatim} 
show statement * /brief_html 
\end{verbatim} 
ruft einen speziellen Modus auf, der nur Definitions- und Theoremlisten zusammen mit den zugehörigen Symbolen in einem Format ausgibt, das sich zum Kopieren und Einfügen in eine andere Webseite eignet (z. B. in die Tutorial-Seiten auf der Metamath-Website). 

Der Befehl 
\begin{verbatim}
show statement * /brief_alt_html 
\end{verbatim}
bewirkt schließlich dasselbe wie \texttt{show statement * / brief{\char`\_}html} für die alternative {\sc html} Darstellung des Symbols. 

Der Kommentar einer Anweisung kann eine spezielle Notation enthalten, die eine gewisse Kontrolle über die {\sc HTML}-Version des Kommentars bietet.  Siehe Abschnitt~\ref{mathcomments} (p.~\pageref{mathcomments}) für die Kommentarauszeichnungsfunktionen. 

Die Befehle \texttt{write theorem{\char`\_}list} und \texttt{write bibliography}, die im Folgenden beschrieben werden, bieten als Nebeneffekt eine vollständige Fehlerprüfung für alle in diesem Abschnitt beschriebenen Funktionen.\index{Fehlerprüfung} 

\subsection{\texttt{write theorem\_list}
-Befehl}\index{\texttt{write theorem{\char`\_}list}-Befehl}

Syntax:  \texttt{write theorem{\char`\_}list}
[\texttt{/theorems{\char`\_}per{\char`\_}page} {\em number}]

Dieser Befehl schreibt eine Liste aller \texttt{\$a}- und \texttt{\$p}-Anweisungen in der Datenbasis in eine Webseitendatei namens \texttt{mmtheorems.html}. Wenn weitere Dateien benötigt werden, heißen sie \texttt{mmtheorems2.html}, \texttt{mmtheorems3.html}, usw. 

Optionaler Befehlszeilenparameter:

    \texttt{/theorems{\char`\_}per{\char`\_}page} {\em number} - Diese Option gibt die Anzahl der Anweisungen an, die pro Webseite geschrieben werden sollen.  Der Standardwert ist 100.

{\em Anmerkung:} In Version 0.177\index{Metamath!Limitationen der Version 0.177} von Metamath setzen die "`Nearby theorems"'-Links auf den einzelnen Webseiten 100 Theoreme pro Seite voraus, wenn sie auf eine Seite mit einer Theoremliste verweisen.  Daher führt die Option \texttt{/theorems{\char`\_}per{\char`\_}page}, wenn sie eine andere Zahl als 100 angibt, dazu, dass die einzelnen Webseiten nicht mehr synchron sind, und sollte nicht verwendet werden, um die Haupttheoremliste für die Website zu erzeugen.  Dieses Problem wird möglicherweise in einer zukünftigen Version behoben. 


\subsection{\texttt{write bibliography}\label{wrbib}
-Befehl}\index{\texttt{write bibliography}-Befehl}

Syntax:  \texttt{write bibliography} {\em filename}

Dieser Befehl liest eine bestehende bibliografische Querverweisdatei ein, die normalerweise \texttt{mmbiblio.html} heißt, und aktualisiert sie anhand der bibliografischen Links in den Datenbasiskommentaren.  Die Datei wird zwischen den {\sc html} Kommentarzeilen \texttt{<!-- {\char`\#}START{\char`\#} -->} und \texttt{<!-- {\char`\#}END{\char`\#} -->} aktualisiert.  Die ursprüngliche Eingabedatei wird in {\em Dateiname}\texttt{{\char`\~}1} umbenannt. 

Ein bibliografischer Verweis wird mit dem Namen der Referenz in Klammern angegeben, z. B. \texttt{Theorem 3.1 aus [Monk] S.\ 22}. Siehe Abschnitt~\ref{htmlout} (p.~\pageref{htmlout}) für Einzelheiten zur Syntax. 


\subsection{\texttt{write recent\_additions}
-Befehl}\index{\texttt{write recent{\char`\_}additions}-Befehl}

Syntax:  \texttt{write recent{\char`\_}additions} {\em filename}
[\texttt{/limit} {\em number}]

Dieser Befehl liest eine vorhandene Datei "`Recent Additions"' {\sc html} ein, die normalerweise \texttt{mmrecent.html} heißt, und aktualisiert sie mit den Beschreibungen der Theoreme, die der Datenbasis zuletzt hinzugefügt wurden.  Die Datei wird zwischen den {\sc html} Kommentarzeilen \texttt{<!-- {\char`\#}START{\char`\#} -->} und \texttt{<!-- {\char`\#}END{\char`\#} -->} aktualisiert.  Die ursprüngliche Eingabedatei wird in {\em Dateiname}\texttt{{\char`\~}1} umbenannt. 

Optionaler Befehlszeilenparameter:

    \texttt{/limit} {\em number} - Dieser Qualifier gibt die Anzahl der neuesten Theoreme an, die in die Ausgabedatei geschrieben werden sollen.  Der Standardwert ist 100.


\section{Text File Utilities}

\subsection{\texttt{tools}-Befehl}\index{\texttt{tools}-Befehl}

Syntax:  \texttt{tools}

Dieser Befehl ruft ein einfach zu bedienendes, universelles Dienstprogramm zur Bearbeitung des Inhalts von Textdateien auf.  Nach der Eingabe von \texttt{tools} ändert sich die Eingabeaufforderung in \texttt{TOOLS>}, bis Sie \texttt{exit} eingeben.  Mit den \texttt{tools}-Befehlen können Sie einfache, globale Änderungen an einer Ein-/Ausgabedatei vornehmen, z. B. eine Zeichenkettenersetzung in jeder Zeile vornehmen, eine Zeichenkette zu jeder Zeile hinzufügen usw.  Eine typische Verwendung dieses Dienstprogramms ist die Erstellung einer \texttt{submit}-Eingabedatei, um eine allgemeine Operation an einer Liste von Anweisungen durchzuführen, die mittels \texttt{show label} oder \texttt{show usage} erzeugt wurde. 

Die Aktionen der meisten \texttt{tools}-Befehle können auch mit äquivalenten (und leistungsfähigeren) Unix-Shell-Befehlen ausgeführt werden, und manche Benutzer finden diese vielleicht effizienter.  Aber für Windows-Benutzer oder Benutzer, die mit Unix nicht vertraut sind, bietet \texttt{tools} eine leicht zu erlernende Alternative, die für die meisten Aufgaben der Skripterstellung ausreicht, die für die effektive Nutzung des Metamath-Programms erforderlich sind. 


\subsection{\texttt{help}-Befehl (in \texttt{tools})}

Syntax:  \texttt{help}

Der Befehl \texttt{help} listet die im Dienstprogramm \texttt{tools} verfügbaren Befehle zusammen mit einer kurzen Beschreibung auf.  Für jeden Befehl gibt es wiederum eine eigene Hilfe, wie z. B. \texttt{help add}.  Wie bei der \texttt{MM>}-Eingabeaufforderung von Metamath kann ein kompletter Befehl auf einmal eingegeben werden, oder es kann nur das Befehlswort eingegeben werden, woraufhin das Programm nach jedem Argument fragt. 

\vskip 1ex
\noindent Befehle für eine zeilenweise Bearbeitung:

  \texttt{add} - Fügt eine angegebene Zeichenkette zu jeder Zeile einer Datei hinzu.

  \texttt{clean} - Schneidet Leerzeichen und Tabulatoren in jeder Zeile einer Datei ab; konvertiert Zeichen.

  \texttt{delete} - Löschen eines Abschnitts jeder Zeile in einer Datei.

  \texttt{insert} - Fügt eine Zeichenkette in einer bestimmten Spalte in jeder Zeile einer Datei ein.

  \texttt{substitute} - Führt eine einfache Ersetzung in jeder Zeile der Datei durch.

  \texttt{tag} - Wie \texttt{add}, aber beschränkt auf einen Bereich von Zeilen.

  \texttt{swap} - Vertauscht die beiden Hälften jeder Zeile in einer Datei.

\vskip 1ex
\noindent Andere Befehle zur Dateiverarbeitung:

  \texttt{break} - Zerlegt (tokenisiert) eine Datei in eine Liste von Token (eines pro Zeile).

  \texttt{build} - Erzeugt eine Datei mit mehreren Token pro Zeile aus einer Liste.

  \texttt{count} - Zählt die Vorkommen einer bestimmten Zeichenfolge in einer Datei.

  \texttt{number} - Erstellt eine Liste von Zahlen.

  \texttt{parallel} - Schaltet zwei Dateien nebeneinander.

  \texttt{reverse} - Kehrt die Reihenfolge der Zeilen in einer Datei um.

  \texttt{right} - Richtet Zeilen in einer Datei rechtsbündig aus (nützlich vor dem Sortieren von Zahlen).

%  \texttt{tag} - Tag edit updates in a program for revision control.

  \texttt{sort} - Sortiert die Zeilen in einer Datei nach dem Schlüssel, der mit der angegebenen Zeichenfolge beginnt.

  \texttt{match} - Extrahiert Zeilen, die eine bestimmte Zeichenfolge enthalten (oder nicht).

  \texttt{unduplicate} - Eliminiert doppelt vorkommende Zeilen in einer Datei.

  \texttt{duplicate} - Extrahiert das erste Vorkommen einer Zeile, die mehr als \ \ \ einmal in einer Datei vorkommt, und verwirft Zeilen, die genau einmal vorkommen.

  \texttt{unique} - Extrahiert Zeilen, die genau einmal in einer Datei vorkommen.

  \texttt{type} (10 Zeilen) - Zeigt die ersten paar Zeilen einer Datei an. Ähnlich wie bei Unix \texttt{head}.

  \texttt{copy} - Ähnlich wie Unix \texttt{cat}, aber sicher (gleiche Eingabe- und Ausgabedatei erlaubt).

  \texttt{submit} - Führt ein Skript aus, das \texttt{tools} Befehle enthält.

\vskip 1ex

\noindent Hinweis:
\texttt{unduplicate}, \texttt{duplicate} und \texttt{unique} sortieren als Nebeneffekt auch die Zeilen.


\subsection{Verwendung von \texttt{tools} zur Erstellung von Metamath \texttt{submit}-Skripten}

Der Befehl \texttt{break} Befehl wird normalerweise verwendet, um eine Reihe von Anweisungs-Labels, wie z.B. die Ausgabe von Metamaths \texttt{show usage}, in ein Label pro Zeile aufzubrechen.  Die anderen \texttt{tools}-Befehle können dann verwendet werden, um Zeichenketten vor und nach jedem Label einer Anweisung hinzuzufügen, um Befehle anzugeben, die für die Anweisung ausgeführt werden sollen.  Der Befehl \texttt{parallel} ist nützlich, wenn ein Label für eine Anweisung mehr als einmal in einer Zeile erwähnt werden muss. 

Sehr oft erfordert ein Skript für Metamath mehrere Befehlszeilen für jede zu verarbeitende Anweisung.  Sie möchten zum Beispiel den Beweis-Assistenten starten, \texttt{minimize{\char`\_}with} für Ihren zuletzt bearbeitetes Theorem ausführen, mit \texttt{save} den neuen Beweis speichern und mit \texttt{exit} den Beweis-Assistenten beenden.  Um dies zu erreichen, können Sie eine Datei mit diesen vier Befehlen für jede Anweisung in einer einzigen Zeile erstellen und jeden Befehl durch ein bestimmtes Zeichen wie \texttt{@} abtrennen.  Am Ende können Sie dann jedes \texttt{@} mit \texttt{{\char`\\}n} ersetzen, um die Zeilen in einzelne Befehlszeilen aufzulösen (siehe \texttt{help substitute}). 


\subsection{Beispiel für eine \texttt{tools}-Sitzung}

Um Ihnen ein schnelles Gefühl für das Dienstprogramm \texttt{tools} zu vermitteln, zeigen wir eine einfache Sitzung, in der wir eine Datei \texttt{n.txt} mit 3 Zeilen erstellen, Zeichenketten vor und nach jeder Zeile hinzufügen und die Zeilen auf dem Bildschirm anzeigen. Sie können mit den verschiedenen Befehlen experimentieren, um Erfahrungen mit dem Dienstprogramm \texttt{tools} zu sammeln. 

\begin{verbatim}
MM> tools
Entering the Text Tools utilities.
Type HELP for help, EXIT to exit.
TOOLS> number
Output file <n.tmp>? n.txt
First number <1>?
Last number <10>? 3
Increment <1>?
TOOLS> add
Input/output file? n.txt
String to add to beginning of each line <>? This is line
String to add to end of each line <>? .
The file n.txt has 3 lines; 3 were changed.
First change is on line 1:
This is line 1.
TOOLS> type n.txt
This is line 1.
This is line 2.
This is line 3.
TOOLS> exit
Exiting the Text Tools.
Type EXIT again to exit Metamath.
MM>
\end{verbatim}



\appendix
\chapter{Beispielhafte Darstellungen}
\label{ASCII}

Dieser Anhang enthält eine Auswahl von {\sc ASCII}-Darstellungen, die ent\-spre\-chen\-den traditionellen mathematischen Symbole und eine Erläuterung ihrer Bedeutungen in der Datenbasis \texttt{set.mm}. Die Symbole sind in der Reihenfolge ihres Auftretens aufgeführt. Dies ist nur eine unvollständige Liste, und es werden laufend neue Definitionen hinzugefügt. Eine vollständige Liste finden Sie unter \url{http://metamath.org}. 

Diese {\sc ASCII}-Darstellungen sowie Informationen zu ihrer Anzeige werden in der Datenbasisdatei \texttt{set.mm} in einem speziellen Kommentar namens \texttt{\$t} {\em comment}\index{\texttt{\$t}-Anweisung} oder {\em Schriftsatzkommentar} definiert. Ein Schriftsatzkommentar ist durch die zweistellige Zeichenfolge \texttt{\$t} am Anfang des Kommentars gekennzeichnet. Weitere Informationen finden Sie in Abschnitt~\ref{tcomment}, S.~\pageref{tcomment}. 

In der folgenden Tabelle zeigt die Spalte "`{\sc ASCII}"' die {\sc ASCII}-Darstellung, "`Symbol"' die mathematisch-symbolische Darstellung, die dieser {\sc ASCII}-Dar\-stel\-lung entspricht, "`Labels"' die Schlüssel-Labels, die die Darstellung de\-fi\-nie\-ren, und "`Beschreibung"' liefert eine Beschreibung des Symbols. Wie üblich ist "`gdw"' die Abkürzung für "`genau dann, wenn"' oder "`dann und nur dann, wenn"'. \index{gdw} In den meisten Fällen zeigt die Spalte "`{\sc ASCII}"' nur das Schlüssel-Token an, aber manchmal wird auch eine Folge von Token angezeigt, wenn dies für die Verständlichkeit notwendig ist. 

{\setlength{\extrarowsep}{4pt} % Keep rows from being too close together
\begin{longtabu}   { @{} c c l X }
\textbf{ASCII} & \textbf{Symbol} & \textbf{Labels} & \textbf{Beschreibung} \\
\endhead
\texttt{|-} & $\vdash$ & &
"`Es ist beweisbar, dass..."' \\
\texttt{ph} & $\varphi$ & \texttt{wph} &
Die (boolesche) wff-Variable Phi, üblicherweise die erste wff-Variable. \\
\texttt{ps} & $\psi$ & \texttt{wps} &
Die (boolesche) wff-Variable Psi, üblicherweise die zweite wff-Variable. \\  
\texttt{ch} & $\chi$ & \texttt{wch} &
Die (boolesche) wff-Variable Chi, üblicherweise die dritte wff-Variable. \\  
\texttt{-.} & $\lnot$ & \texttt{wn} &
Logisch nicht. Wenn z.B. $\varphi$ wahr ist, dann ist $\lnot \varphi$ falsch. \\
\texttt{->} & $\rightarrow$ & \texttt{wi} &
Impliziert, auch als materielle Implikation bezeichnet.   In der klassischen Logik ist der Ausdruck $\varphi \rightarrow \psi$ wahr, wenn entweder $\varphi$ falsch oder $\psi$ wahr ist (oder beides), d.h. $\varphi \rightarrow \psi$ hat die gleiche Bedeutung wie $\lnot \varphi \lor \psi$ (wie in Theorem \texttt{imor} bewiesen). \\
\texttt{<->} & $\leftrightarrow$ &
\hyperref[df-bi]{\texttt{df-bi}} &
Bikonditional (auch bekannt als ist-gleich für boolesche Werte). $\varphi \leftrightarrow \psi$ ist wahr, wenn und nur dann wenn $\varphi$ und $\psi$ den gleichen Wert haben.\\
\texttt{\char`\\/} & $\lor$ &
\makecell[tl]{{\hyperref[df-or]{\texttt{df-or}}}, \\
	\hyperref[df-3or]{\texttt{df-3or}}} &
Disjunktion (logisches "`oder"'). $\varphi \lor \psi$ ist wahr, wenn $\varphi$, $\psi$, oder beide wahr sind. \\
\texttt{/\char`\\} & $\land$ &
\makecell[tl]{{\hyperref[df-an]{\texttt{df-an}}}, \\
	\hyperref[df-3an]{\texttt{df-3an}}} &
Konjunktion (logisches "`und"'). $\varphi \land \psi$ ist wahr, wenn sowohl $\varphi$ als auch $\psi$ wahr sind. \\
\texttt{A.} & $\forall$ &
\texttt{wal} &
Für alle; die wff $\forall x \varphi$ ist wahr, wenn $\varphi$ für alle Werte von $x$ wahr ist. \\
\texttt{E.} & $\exists$ &
\hyperref[df-ex]{\texttt{df-ex}} &
Es existiert; die wff $\exists x \varphi$ ist wahr, wenn es mindestens ein $x$ gibt, für das $\varphi$ wahr ist. \\
\texttt{[ y / x ]} & $[ y / x ]$ &
\hyperref[df-sb]{\texttt{df-sb}} &
Die wff $[ y / x ] \varphi$ ist das Ergebnis, wenn $y$ in $\varphi$ echt durch $x$ ersetzt wird ($y$ ersetzt $x$). 
% Dies ist elsb4 
% ( [ x / y ] z e. y <-> z e. x ) 
Zum Beispiel ist $[ x / y ] z \in y$ das Gleiche wie $z \in x$. \\
\texttt{E!} & $\exists !$ &
\hyperref[df-eu]{\texttt{df-eu}} &
Es gibt genau ein; $\exists ! x \varphi$ ist wahr, wenn es genau ein $x$ gibt, bei dem $\varphi$ wahr ist. \\
\texttt{\{ y | phi \}}  & $ \{ y | \varphi \}$ &
\hyperref[df-clab]{\texttt{df-clab}} &
Die Klasse aller Mengen, in denen $\varphi$ wahr ist. \\
\texttt{=} & $ = $ &
\hyperref[df-cleq]{\texttt{df-cleq}} &
Klassengleichheit; $A = B$ gdw $A$ gleich $B$ ist. \\
\texttt{e.} & $ \in $ &
\hyperref[df-clel]{\texttt{df-clel}} &
Klassenzugehörigkeit; $A \in B$ gdw $A$ ein Element von $B$ ist. \\
\texttt{{\char`\_}V} & {\rm V} &
\hyperref[df-v]{\texttt{df-v}} &
Klasse aller Mengen (selbst keine Menge). \\
\texttt{C\_} & $ \subseteq $ &
\hyperref[df-ss]{\texttt{df-ss}} &
Unterklasse (Untermenge); $A \subseteq B$ ist wahr gdw $A$ eine Unterklasse von $B$ ist. \\
\texttt{u.} & $ \cup $ &
\hyperref[df-un]{\texttt{df-un}} &
$A \cup B$ ist die Vereinigung der Klassen $A$ und $B$. \\
\texttt{i\char`\^i} & $ \cap $ &
\hyperref[df-in]{\texttt{df-in}} &
$A \cap B$ ist die Schnittmenge der Klassen $A$ und $B$. \\
\texttt{\char`\\} & $ \setminus $ &
\hyperref[df-dif]{\texttt{df-dif}} &
$A \setminus B$ (Klassendifferenz) ist die Klasse aller Mengen in $A$ mit Ausnahme derjenigen in $B$. \\
\texttt{(/)} & $ \varnothing $ &
\hyperref[df-nul]{\texttt{df-nul}} &
$ \varnothing $ ist die leere Menge. \\
\texttt{\char`\~P} & $ \cal P $ &
\hyperref[df-pw]{\texttt{df-pw}} &
Potenzklasse. \\
\texttt{<.\ A , B >.} & $\langle A , B \rangle$ &
\hyperref[df-op]{\texttt{df-op}} &
Das geordnete Paar $\langle A , B \rangle$. \\
\texttt{( F ` A )} & $ ( F ` A ) $ &
\hyperref[df-fv]{\texttt{df-fv}} &
Der Wert der Funktion $F$ an der Stelle $A$. \\
\texttt{\_i} & $ i $ &
\texttt{df-i} &
Die Quadratwurzel von minus eins. \\
\texttt{x.} & $ \cdot $ &
\texttt{df-mul} &
Multiplikation komplexer Zahlen; $2~\cdot~3~=~6$. \\
\texttt{CC} & $ \mathbb{C} $ &
\texttt{df-c} &
Die Menge der komplexen Zahlen. \\
\texttt{RR} & $ \mathbb{R} $ &
\texttt{df-r} &
Die Menge der reellen Zahlen. \\
\end{longtabu}
} % end of extrarowsep}}% }}entfernen

\chapter{Komprimierte Beweise}
\label{compressed}\index{komprimierter Beweis}\index{Beweis!komprimiert}

Die Beweise in der Mengenlehre-Datenbasis \texttt{set.mm} werden aus Effizienzgründen in einem komprimierten Format gespeichert.  Normalerweise brau\-chen Sie sich nicht um das komprimierte Format zu kümmern, da Sie es mit den üblichen Werkzeugen zur Anzeige von Beweisen im Metamath-Programm (\texttt{show proof}\ldots) anzeigen oder in das normale RPN-Beweisformat konvertieren können, so wie in Abschnitt~\ref{proof} beschrieben (mit \texttt{save proof} {\em label} \texttt{/normal}).  Der Vollständigkeit halber beschreiben wir hier jedoch das Format und zeigen, wie es auf das normale RPN-Beweisformat abgebildet wird. 

Ein komprimierter Beweis, der sich zwischen den Schlüsselwörtern \texttt{\$=} und \texttt{\$.}\ befindet, besteht aus einer linken Klammer, einer Folge von Anweisungs-Labels, einer rechten Klammer und einer Folge von Großbuchstaben \texttt{A} bis \texttt{Z} (mit optionalem Whitespace dazwischen).  Die Klammern und die Labels müssen von Whitespace umgeben sein.  Die linke Klammer sagt Metamath, dass ein komprimierter Beweis folgt (Ein normaler RPN-Beweis besteht nur aus einer Folge von Labels, und eine Klammer ist kein zulässiges Zeichen in einem Label).

Die Folge von Großbuchstaben entspricht einer Folge von ganzen Zahlen mit der folgenden Zuordnung.  Jede ganze Zahl entspricht einem Beweisschritt, wie später beschrieben. 
\begin{center}
  \texttt{A} = 1 \\
  \texttt{B} = 2 \\
   \ldots \\
  \texttt{T} = 20 \\
  \texttt{UA} = 21 \\
  \texttt{UB} = 22 \\
   \ldots \\
  \texttt{UT} = 40 \\
  \texttt{VA} = 41 \\
  \texttt{VB} = 42 \\
   \ldots \\
  \texttt{YT} = 120 \\
  \texttt{UUA} = 121 \\
   \ldots \\
  \texttt{YYT} = 620 \\
  \texttt{UUUA} = 621 \\
   etc.
\end{center}

Mit anderen Worten: \texttt{A} bis \texttt{T} stehen für die niedrigstwertige Ziffer zur Basis 20, und \texttt{U} bis \texttt{Y} stehen für null oder mehr höchstwertige Ziffern zur Basis 5, wobei die Ziffern bei 1 anstelle der üblichen 0 beginnen. Bei diesem Schema brauchen wir keinen Whitespace zwischen diesen "`Ziffern"'. 

(Beim Entwurf des komprimierten Beweisformats wurden nur Großbuchstaben gewählt, im Gegensatz zu allen druckbaren nicht-Whitespace {\sc ascii}-Zeichen außer
%\texttt{\$}, was chosen to make the compressed proof a little less
%displeasing to the eye, at the expense of a typical 20\% compression
\texttt{\$}, um nicht mit der Suchfunktion der meisten Texteditorn in Konflikt zu geraten. Dadurch wird ein Kompressionsverlust von typischerweise 20\% i Kauf genommen.  Die Gruppierung Basis 5/Basis 20 wurde gewählt, z.B. statt Basis 6/Basis 19, nachdem experimentell die Gruppierung ermittelt wurde, die in typischen Fällen die beste Kompression ergab). 

Der Buchstabe \texttt{Z} kennzeichnet ("`taggt"') einen Beweisschritt, der mit einem später im Beweis vorkommenden Schritt übereinstimmt; dadurch wird ein Beweis verkürzt, indem identische Beweisschritte nicht immer wieder erneut bewiesen werden müssen (was bei der Erstellung von wff's häufig vorkommt).  Das \texttt{Z} wird unmittelbar nach der niedrigstwertigen Ziffer (Buchstaben \texttt{A} bis \texttt{T}) platziert, die die ganze Zahl beendet, die dem Schritt entspricht, auf den später verwiesen werden soll. 

Die ganzen Zahlen, denen die Großbuchstaben entsprechen, werden wie folgt auf Labels abgebildet.  Wenn die zu beweisende Aussage $m$ zwingende Hypothesen hat, entsprechen die ganzen Zahlen 1 bis $m$ den Labels dieser Hypothesen in der Reihenfolge, die durch den Befehl \texttt{show statement ... / full} angezeigt werden, d.h. der RPN-Reihenfolge\index{RPN-Reihenfolge} der zwingenden Hypothesen.  Die ganzen Zahlen $m+1$ bis $m+n$ entsprechen den in den Klammern des komprimierten Beweises eingeschlossenen Labels, und zwar in der Reihenfolge ihres Auftretens, wobei $n$ die Anzahl dieser Labels ist.  Ganze Zahlen ab $m+n+1$ entsprechen nicht direkt den Labels der Anweisung, sondern verweisen auf Beweisschritte, die mit dem Buchstaben \texttt{Z} gekennzeichnet sind, so dass auf diese Beweisschritte später im Beweis Bezug genommen werden kann.  Die ganze Zahl $m+n+1$ entspricht dem ersten Schritt, der mit einem \texttt{Z} gekennzeichnet ist, $m+n+2$ dem zweiten Schritt, der mit einem \texttt{Z} gekennzeichnet ist, usw.  Wenn der komprimierte Beweis in einen normalen Beweis umgewandelt wird, ersetzt der gesamte Teilbeweis eines mit \texttt{Z} gekennzeichneten Schritts die Referenz auf diesen Schritt. 

Aus Effizienzgründen arbeitet Metamath direkt mit komprimierten Beweisen, ohne sie intern in normale Beweise umzuwandeln.  Zusätzlich zur üblichen Fehlerprüfung wird eine Fehlermeldung ausgegeben, wenn (1) ein Label in der Label-Liste in Klammern nicht auf eine vorherige \texttt{\$p}- oder \texttt{\$a}-Anweisung oder eine nicht zwingende Hypothese der zu beweisenden Anweisung verweist und (2) ein mit \texttt{Z} markierter Beweisschritt vor dem mit \texttt{Z} markierten Schritt referenziert wird. 

Wie bei einem normalen Beweis in der Entwicklung (Abschnitt~\ref{unknown}) kann jeder Schritt oder Teilbeweis, der noch nicht bekannt ist, mit einem einzigen \texttt{?} dargestellt werden. Zwischen dem \texttt{?}\ und den Großbuchstaben (oder anderen \texttt{?}'s), die den Rest des Beweises darstellen, muss kein Whitespace eingefügt sein. 

% April 1, 2004 Appendix C has been added back in with corrections.
%
% May 20, 2003 Appendix C was removed for now because there was a problem found
% by Bob Solovay
%
% Also, removed earlier \ref{formalspec} 's (3 cases above)
%
% Bob Solovay wrote on 30 Nov 2002:
%%%%%%%%%%%%% (start of email comment )
%      3. My next set of comments concern appendix C. I read this before I
% read Chapter 4. So I first noted that the system as presented in the
% Appendix lacked a certain formal property that I thought desirable. I
% then came up with a revised formal system that had this property. Upon
% reading Chapter 4, I noticed that the revised system was closer to the
% treatment in Chapter 4 than the system in Appendix C.
%
%         First a very minor correction:
%
%         On page 142 line 2: The condition that V(e) != V(f) should only be
% required of e, f in T such that e != f.
%
%         Here is a natural property [transitivity] that one would like
% the formal system to have:
%
%         Let Gamma be a set of statements. Suppose that the statement Phi
% is provable from Gamma and that the statement Psi is provable from Gamma
% \cup {Phi}. Then Psi is provable from Gamma.
%
%         I shall present an example to show that this property does not
% hold for the formal systems of Appendix C:
%
%         I write the example in metamath style:
%
% $c A B C D E $.
% $v x y
%
% ${
% tx $f A x $.
% ty $f B y $.
% ax1 $a C x y $.
% $}
%
% ${
% tx $f A x $.
% ty $f B y $.
% ax2-h1 $e C x y $.
% ax2 $a D y $.
% $}
%
% ${
% ty $f B y $.
% ax3-h1 $e D y $.
% ax3 $a E y $.
% $}
%
% $(These three axioms are Gamma $)
%
% ${
% tx $f A x $.
% ty $f B y $.
% Phi $p D y $=
% tx ty tx ty ax1 ax2 $.
% $}
%
% ${
% ty $f B y $.
% Psi $p E y $=
% ty ty Phi ax3 $.
% $}
%
%
% I omit the formal proofs of the following claims. [I will be glad to
% supply them upon request.]
%
% 1) Psi is not provable from Gamma;
%
% 2) Psi is provable from Gamma + Phi.
%
% Here "provable" refers to the formalism of Appendix C.
%
% The trouble of course is that Psi is lacking the variable declaration
%
% $f Ax $.
%
% In the Metamath system there is no trouble proving Psi. I attach a
% metamath file that shows this and which has been checked by the
% metamath program.
%
% I next want to indicate how I think the treatment in Appendix C should
% be revised so as to conform more closely to the metamath system of the
% main text. The revised system *does* have the transitivity property.
%
% We want to give revised definitions of "statement" and
% "provable". [cf. sections C.2.4. and C.2.5] Our new definitions will
% use the definitions given in Appendix C. So we take the following
% tack. We refer to the original notions as o-statement and o-provable. And
% we refer to the notions we are defining as n-statement and n-provable.
%
%         A n-statement is an o-statement in which the only variables
% that appear in the T component are mandatory.
%
%         To any o-statement we can associate its reduct which is a
% n-statement by dropping all the elements of T or D which contain
% non-mandatory variables.
%
%         An n-statement gamma is n-provable if there is an o-statement
% gamma' which has gamma as its reduct andf such that gamma' is
% o-provable.
%
%         It seems to me [though I am not completely sure on this point]
% that n-provability corresponds to metamath provability as discussed
% say in Chapter 4.
%
%         Attached to this letter is the metamath proof of Phi and Psi
% from Gamma discussed above.
%
%         I am still brooding over the question of whether metamath
% correctly formalizes set-theory. No doubt I will have some questions
% re this after my thoughts become clearer.
%%%%%%%%%%%%%%%% (end of email comment)

%%%%%%%%%%%%%%%% (start of 2nd email comment from Bob Solovay 1-Apr-04)
%
%         I hope that Appendix C is the one that gives a "formal" treatment
% of Metamath. At any rate, thats the appendix I want to comment on.
%
%         I'm going to suggest two changes in the definition.
%
%         First change (in the definition of statement): Require that the
% sets D, T, and E be finite.
%
%         Probably things are fine as you give them. But in the applications
% to the main metamath system they will always be finite, and its useful in
% thinking about things [at least for me] to stick to the finite case.
%
%         Second change:
%
%         First let me give an approximate description. Remove the dummy
% variables from the statement. Instead, include them in the proof.
%
%         More formally: Require that T consists of type declarations only
% for mandatory variables. Require that all the pairs in D consist of
% mandatory variables.
%
%         At the start of a proof we are allowed to declare a finite number
% of dummy variables [provided that none of them appear in any of the
% statements in E \cup {A}. We have to supply type declarations for all the
% dummy variables. We are allowed to add new $d statements referring to
% either the mandatory or dummy variables. But we require that no new $d
% statement references only mandatory variables.
%
%         I find this way of doing things more conceptual than the treatment
% in Appendix C. But the change [which I will use implicitly in later
% letters about doing Peano] is mainly aesthetic. I definitely claim that my
% results on doing Peano all apply to Metamath as it is presented in your
% book.
%
%         --Bob
%
%%%%%%%%%%%%%%%% (end of 2nd email comment)

%%
%% When uncommenting the below, also uncomment references above to {formalspec}
%%
\chapter{Das formale System von Metamath}\label{formalspec}\index{Metamath!als ein formales System}

\section{Einführung}

\begin{quote}
  {\em Vollkommenheit ist, wenn es nichts mehr wegzunehmen gibt.}
    \flushright\sc Antoine de Saint-Exupery\footnote{Nach \cite[S.~3-25]{Campbell}.}\\
\end{quote}\index{de Saint-Exupery, Antoine}

Dieser Anhang beschreibt die Theorie hinter der Metamath-Sprache in einer abstrakten Form, die für Mathematiker gedacht ist.  Konkret konstruieren wir zwei Mengen-theoretische Objekte: ein "`formales System"' (grob gesagt, eine Menge von Syntaxregeln, Axiomen und logischen Regeln) und sein "`Universum"' (grob gesagt, die Menge der Theoreme, die im formalen System ableitbar sind).  Die Computersprache Metamath bietet uns eine Möglichkeit, bestimmte formale Systeme zu beschreiben und mit Hilfe eines vom Benutzer bereitgestellten Beweises zu überprüfen, ob gegebene Theoreme zu ihren Universen gehören. 

Um diesen Anhang zu verstehen, benötigen Sie Grundkenntnisse der informellen Mengenlehre. Es sollte ausreichen, z.B. Kap.\ 1 von Munkres' {\em Topology} zu verstehen\cite{Munkres}\index{Munkres, James R.} oder das einführende Kapitel zur Mengenlehre in vielen Lehrbüchern, die in die abstrakte Mathematik einführen. (Beachten Sie, dass es zwischen den Autoren kleinere Unterschiede in der Schreibweise gibt; z.B. verwendet Munkres $\subset$ anstelle unseres $\subseteq$ für "`subset"'.  Wir verwenden "`enthalten in"' für "`eine Teilmenge von"' und "`gehört zu"' oder "`ist enthalten in"' für "`ist ein Element von"'). Was wir hier als "`formale"' Beschreibung bezeichnen, ist anders als früher, eigentlich eine informelle Beschreibung in der gewöhnlichen Sprache der Mathematiker.  Wir geben jedoch genügend Details an, so dass ein Mathematiker sie leicht formalisieren kann, sogar in der Sprache von Metamath selbst, falls gewünscht.  Um die Logikbeispiele am Ende dieses Anhangs zu verstehen, wäre die Kenntnis eines einführenden Buches über mathematische Logik hilfreich. 

\section{Die formale Beschreibung}

\subsection[Vorbereitende Maßnahmen]{Vorbereitende Maßnahmen\protect\footnotemark}%
\footnotetext{Dieser Abschnitt ist größtenteils wörtlich von Tarski\cite[p.~63]{Tarski1965}\index{Tarski, Alfred} übernommen und frei übersetzt.}

Mit $\omega$ bezeichnen wir die Menge aller natürlichen Zahlen (nichtnegative ganze Zahlen). Jede natürliche Zahl $n$ wird mit der Menge aller kleineren Zahlen identifiziert: $n = \{ m | m < n \}$.  Die Formel $m < n$ ist also äquivalent zu der Bedingung: $m \in n$ und $m,n \in \omega$. Insbesondere ist 0 die Zahl Null und zugleich die leere Menge $\varnothing$, $1=\{0\}$, $2=\{0,1\}$ usw. ${}^B A$ bezeichnet die Menge aller Funktionen von  $B$ nach $A$ (d.h. \ mit dem Definitionsbereich $B$ und einem in $A$ enthaltenen Wertebereich).  Die Elemente von ${}^\omega A$ sind so genannte {\em einfache unendliche Folgen},\index{einfache unendliche Folge} mit allen {\em Gliedern}\index{Glied} in $A$.  Für den Fall $n \in \omega$ werden die Elemente von ${}^n A$ als {\em endliche $n$-gliedrige Folgen},\index{endliche $n$-gliedrige Folge} bezeichnet, wiederum mit Gliedern in $A$.  Die aufeinanderfolgenden Glieder (Funktionswerte) einer endlichen oder unendlichen Folge $f$ werden mit $f_0, f_1, \ldots ,f_n,\ldots$ bezeichnet.  Jede endliche Folge $f \in \bigcup _{n \in \omega} {}^n A$ bestimmt eindeutig die Zahl $n$, so dass $f \in {}^n A$; $n$ heißt die {\em Länge}\index{Länge einer Folge ({$"|\"|$})} von $f$ und wird mit $|f|$ bezeichnet.  $\langle a \rangle$ ist die Folge $f$ mit $|f|=1$ und $f_0=a$; $\langle a,b \rangle$ ist die Folge $f$ mit $|f|=2$, $f_0=a$, $f_1=b$; usw.  Für zwei gegebene endliche Folgen $f$ und $g$ bezeichnen wir mit $f\frown g$ ihre {\em Verkettung},\index{Verkettung} d.h. die endliche Folge $h$, die durch die folgende Bedingungen bestimmt ist: 
\begin{eqnarray*}
& |h| = |f|+|g|;&  \\
& h_n = f_n & \mbox{\ for\ } n < |f|;  \\
& h_{|f|+n} = g_n & \mbox{\ for\ } n < |g|.
\end{eqnarray*}

\subsection{Konstanten, Variablen und Ausdrücke}

Ein formales System hat eine Menge von {\em Symbolen}\index{Symbol!in einem formalen System}, die mit $\mbox{\em SM}$ bezeichnet wird.  Eine genaue mengentheoretische Definition dieser Menge ist unwichtig; ein Symbol kann als primitives oder atomares Element betrachtet werden, wenn man will.  Wir nehmen an, dass diese Menge in zwei disjunkte Teilmengen unterteilt ist: eine Menge $\mbox{\em CN}$ von {\em Konstanten}\index{Konstante!in einem formalen System} und eine Menge $\mbox{\em VR}$ von {\em Variablen}\index{Variable!in einem formalen System}. $\mbox{\em CN}$ und $\mbox{\em VR}$ bestehen jeweils aus abzählbar vielen Symbolen, die in endlichen oder einfachen unendlichen Folgen $c_0, c_1, \ldots$ bzw. $v_0, v_1, \ldots$ ohne Wiederholumgen angeordnet werden können.  Beliebige Symbole werden wir durch Metavariablen $\alpha$, $\beta$ usw. darstellen. 

{\footnotesize\begin{quotation}
{\em Kommentar:} Die Variablen $v_0, v_1, \ldots$ unseres formalen Systems ent\-spre\-chen dem, was in der Literatur zu spezifischen formalen Systemen gewöhnlich als "`Metavariablen"' bezeichnet wird.  Typischerweise wird bei der Beschreibung eines bestimmten formalen Systems in einem Buch eine Reihe von primitiven Objekten postuliert, die Variablen genannt werden, und dann werden deren Eigenschaften mit Hilfe von Metavariablen beschrieben, die sich über diese erstrecken, wobei die eigentlichen Variablen selbst nie wieder erwähnt werden.  Unser formales System erwähnt diese primitiven, Variablen genannte Objekte überhaupt nicht, sondern befasst sich von Anfang an direkt mit Metavariablen als seine primitiven Objekten.  Dies ist ein subtiler, aber wichtiger Unterschied, den man im Auge behalten sollte. Denn dadurch unterscheidet sich unsere Definition von "`formalem System"' etwas von denen, die man normalerweise in der Literatur findet.  (So sind die oben genannten Metavariablen $\alpha$, $\beta$ usw.\ eigentlich "`Metametavariablen"', wenn sie zur Darstellung von $v_0, v_1, \ldots$ verwendet werden.)
\end{quotation}}

Endliche Folgen, bei denen alle Glieder Symbole sind, heißen {\em-Ausdrücke}.\index{Ausdruck!in einem formalen System} $\mbox{\em EX}$ ist die Menge aller Ausdrücke; also 
\begin{displaymath}
\mbox{\em EX} = \bigcup _{n \in \omega} {}^n \mbox{\em SM}.
\end{displaymath}

Ein {\em konstant-gepräfixter Ausdruck}\index{konstant-gepräfixter Ausdruck} ist ein Ausdruck der Länge ungleich Null, dessen erstes Glied eine Konstante ist.  Wir bezeichnen die Menge aller konstant-gepräfixter Ausdrücke mit $\mbox{\em EX}_C = \{ e \in \mbox{\em EX} | ( |e| > 0 \wedge e_0 \in \mbox{\em CN} ) \}$. 

Ein {\em Konstante-Variable-Paar}\index{Konstante-Variable-Paar} ist ein Ausdruck der Länge 2, dessen erstes Glied eine Konstante ist und dessen zweites Glied eine Variable ist.  Wir bezeichnen die Menge aller Konstanten-Variablen-Paare mit $\mbox{\em EX}_2 = \{ e \in \mbox{\em EX}_C | ( |e| = 2 \wedge e_1 \in \mbox{\em VR} ) \}$. 


{\footnotesize\begin{quotation}
{\em Beziehung zu Metamath:} Im Allgemeinen entspricht die Menge $\mbox{\em SM}$ der Menge der deklarierten mathematischen Symbole in einer Metamath-Datenbasis, die Menge $\mbox{\em CN}$ denjenigen Symbolen, die mit \texttt{\$c}-Anweisungen deklariert sind, und die Menge $\mbox{\em VR}$ denjenigen Symbolen, die mit \texttt{\$v}-Anweisungen deklariert sind.  Natürlich kann eine Metamath-Datenbasis nur eine endliche Anzahl von mathematischen Symbolen haben, während formale Systeme im Allgemeinen eine unendliche Anzahl haben können, obwohl die Anzahl der in Metamath verfügbaren mathematischen Symbole im Prinzip unbegrenzt ist.  Die Menge $\mbox{\em EX}_C$ entspricht der Menge der zulässigen Ausdrücke für \texttt{\$e}-, \texttt{\$a}- und \texttt{\$p}-Anweisungen.  Die Menge $\mbox{\em EX}_2$ entspricht der Menge der zulässigen Ausdrücke für \texttt{\$f}-Anweisungen.
\end{quotation}}

Wir bezeichnen mit ${\cal V}(e)$ die Menge aller Variablen in einem Ausdruck $e \in \mbox{\em EX}$, d.h. die Menge aller $\alpha \in \mbox{\em VR}$, so dass $\alpha = e_n$ für mindestens ein $n < |e|$.  Wir bezeichnen auch (unter Missbrauch der Notation) mit ${\cal V}(E)$ die Menge aller Variablen in einer Sammlung von Ausdrücken $E \subseteq \mbox{\em EX}$, d.h.\ $\bigcup _{e \in E} {\cal V}(e)$. 


\subsection{Substitution}

Bei einer Funktion $F$ von $\mbox{\em VR}$ nach $\mbox{\em EX}$ bezeichnen wir mit $\sigma_{F}$ oder einfach $\sigma$ die Funktion von $\mbox{\em EX}$ nach $\mbox{\em EX}$, die rekursiv für nichtleere Folgen durch 
\begin{eqnarray*}
& \sigma(<\alpha>) = F(\alpha) & \mbox{mit\ } \alpha \in \mbox{\em VR}; \\
& \sigma(<\alpha>) = <\alpha> & \mbox{mit\ } \alpha \not\in \mbox{\em VR}; \\
& \sigma(g \frown h) = \sigma(g) \frown
    \sigma(h) & \mbox{mit\ } g,h \in \mbox{\em EX}.
\end{eqnarray*}
definiert ist.

Wir definieren außerdem $\sigma(\varnothing)=\varnothing$.  Wir nennen $\sigma$ eine {\em simultane Substitution}\index{Substitution!Variable}\index{Variablensubstitution} (oder einfach {\em Substitution}) mit {\em Substitutionsabbildung}\index{Substitutionsabbildung} $F$. 

Mit $\sigma(E)$ bezeichnen wir (unter Missbrauch der Notation) auch eine Substitution auf einer Sammlung von Ausdrücken $E \subseteq \mbox{\em EX}$, d.h. die Menge $\{ \sigma(e) | e \in E \}$.  Die Sammlung $\sigma(E)$ kann natürlich weniger Ausdrücke als $E$ enthalten, weil durch die Substitution doppelte Ausdrücke entstehen könnten. 


\subsection{Aussagen}

Wir bezeichnen mit $\mbox{\em DV}$ die Menge aller ungeordneten Paare $\{\alpha, \beta \} \subseteq \mbox{\em VR}$, so dass $\alpha \neq \beta$. $\mbox{\em DV}$ steht für "`unterscheidbare Variablen"'. 

Eine {\em Prä-Aussage}\index{Prä-Aussage!in einem formalen System} ist ein Quadrupel $\langle D,T,H,A \rangle$ derart, dass $D\subseteq \mbox{\em DV}$, $T\subseteq \mbox{\em EX}_2$, $H\subseteq \mbox{\em EX}_C$ und $H$ endlich ist, $A\in \mbox{\em EX}_C$, ${\cal V}(H\cup\{A\}) \subseteq {\cal V}(T)$, und $\forall e,f\in T {\ } {\cal V}(e) \neq {\cal V}(f)$ (oder äquivalent, $e_1 \ne f_1$), wann immer $e \neq f$. Die Terme des Quadrupels werden respektive
{\em disjunkte Variableneinschränkungen},\index{disjunkte Variableneinschränkung!in einem formalen System},
{\em Variablentyp-Hypothesen},\index{Variablentyp-Hypothese!in einem formalen System},
{\em logische Hypothesen},\index{logische Hypothese!in einem formalen System} und die 
{\em Behauptung}\index{Behauptung!in einem formalen System} genannt.
Wir bezeichnen mit $T_M$ ({\em obligatorische Variablentyp-Hypothesen}\index{obligatorische Variablentyp-Hypothese!in einem formalen System}) die Teilmenge von $T$, so dass ${\cal V}(T_M) ={\cal V}(H \cup \{A\})$.  Wir bezeichnen mit $D_M=\{\{\alpha,\beta\}\in D|\{\alpha,\beta\}\subseteq {\cal V}(T_M)\}$ die {\em obligatorischen disjunkte Variableneinschränkung}\index{obligatorische disjunkte Variableneinschränkung!in einem formalen System} der Prä-Aussage. Die Menge der {\em obligatorischen Hypothesen}\index{obligatorische Hypothese!in einem formalen System} ist $T_M\cup H$.  Wir nennen das Quadrupel $\langle D_M,T_M,H,A \rangle$ das {\em Redukt}\index{Redukt!in einem formalen System} der Prä-Aussage $\langle D,T,H,A \rangle$.  

Eine {\em Aussage} ist das Redukt einer Prä-Aussage\index{Aussage!in einem formalen System}.  Eine Aussage ist also eine besondere Art von Prä-Aussage; insbesondere ist eine Aussage das Redukt ihrer selbst. 

{\footnotesize\begin{quotation}
{\em Kommentar:}  $T$ ist eine Menge von Ausdrücken der Länge 2, die eine Menge von Konstanten ("`Variablentypen"') mit einer Menge von Variablen verknüpfen.  Die Bedingung ${\cal V}(H\cup\{A\}) \subseteq {\cal V}(T) $ bedeutet, dass jede Variable, die in den logischen Hypothesen oder Behauptungen einer Aussage vorkommt, eine zugehörige Variablentyp-Hypothese oder eine "`Typendeklaration"' haben muss, in Analogie zu einer Programmiersprache für Computer, in der eine Variable beispielsweise als String oder Integer deklariert werden muss.  Die Anforderung, dass $\forall e,f\in T \, e_1 \ne f_1$ für $e\neq f$ bedeutet, dass jede Variable eindeutig einer Konstanten zugeordnet sein muss, die ihren Variablentyp bezeichnet; z.B. kann eine Variable ein "`wff"' oder ein "`set"' sein, aber nicht beides.

Disjunkte Variableneinschränkungen werden verwendet, um anzugeben, welche Variablensubstitutionen zulässig sind, damit die Anweisung gültig bleibt.  In dem Theoremschema der Mengenlehre $\lnot\forall x\,x=y$ dürfen wir zum Beispiel nicht dieselbe Variable sowohl für $x$ als auch für $y$ einsetzen.  Andererseits verlangt das Theoremschema $x=y\to y=x$ nicht, dass $x$ und $y$ verschieden sein müssen, so dass wir keine disjunkte Variableneinschränkungen brauchen, obwohl eine solche Einschränkung nur dazu führen würde, dass das Schema weniger allgemein wäre.  

Eine obligatorische Variablentyp-Hypothese ist eine, deren Variable in einer logischen Hypothese oder der Behauptung vorkommt.  Eine beweisbare Prä-Aussage (siehe unten) kann nicht-obligatorische Variablentyp-Hypothe\-sen erfordern, die im Endeffekt "`Dummy"'-Variablen zur Verwendung in ihrem Beweis einführen.  Jede mögliche Anzahl von Dummy-Variablen kann für einen bestimmten Beweis erforderlich sein; tatsächlich wurde von H.\ Andr\'{e}ka\index{Andr{\'{e}}ka, H.} \cite{Nemeti} gezeigt, dass es keine endliche Obergrenze für die Anzahl der Dummy-Variablen gibt, die benötigt werden, um einen beliebiges Theorem in der Logik erster Ordnung (mit Gleichheit) zu beweisen, der eine feste Anzahl $n>2$ von individuellen Variablen hat.  (Siehe auch den Kommentar zu S.~\pageref{nodd}.) Aus diesem Grund setzen wir keine endliche Größenbeschränkung für die Sammlungen $D$ und $T$, obwohl diese in einer tatsächlichen Anwendung (Metamath-Datenbasis) natürlich endlich sein werden und deren Anzahl wenn nötig vergrößert werden muss, wenn mehr Beweise hinzugefügt werden.
\end{quotation}}

{\footnotesize\begin{quotation}
{\em Beziehung zu Metamath:} Eine Prä-Aussage eines formalen Systems entspricht einem erweiterten Rahmen in einer Metamath-Datenbasis (Abschnitt~\ref{frames}).  Die Sammlungen $D$, $T$ und $H$ entsprechen den Sammlungen der Anweisungen \texttt{\$d}, \texttt{\$f} und \texttt{\$e} in einem erweiterten Rahmen.  Der Ausdruck $A$ entspricht der Anweisung \texttt{\$a} (oder \texttt{\$p}) in einem erweiterten Rahmen.  Eine Ausage eines formalen Systems entspricht einem Frame in einer Metamath-Datenbasis.
\end{quotation}}

\subsection{Formale Systeme}

Ein {\em formales System}\index{formales System} ist ein Tripel $\langle \mbox{\em CN},\mbox{\em VR},\Gamma\rangle$ wobei $\Gamma$ eine Menge von Aussagen ist.  Die Elemente von $\Gamma$ werden {\em axiomatische Aussagen} genannt\index{axiomatische Aussagen!in einem formalen System}.  Manchmal wird ein formales System nur mit $\Gamma$ bezeichnet, wenn $\mbox{\em CN}$ und $\mbox{\em VR}$ klar sind.\footnote{Anm. der Übersetzer: Üblicherweise ist ein {\em formales System}\index{formales System} ein Quadrupel $\langle \mbox{\em A},\mbox{\em B},\Gamma,\mbox{\em R}\rangle$
wobei $\mbox{\em A}$ ein Alphabet (hier also $\mbox{\em A} = \mbox{\em SM} = \mbox{\em CN}\cup \mbox{\em VR}$),
$\mbox{\em B}$ eine Teilmenge aller Wörter, die sich über dem Alphabet $\mbox{\em A}$ bilden lassen, also die Menge aller "`wohlgeformten Formeln"' oder eine "`formale Sprache"' über dem Alphabet $\mbox{\em A}$,
$\Gamma$ eine Menge von Aussagen, die als "`Axiome"' aufgefasst werden (es gilt $\Gamma\subseteq\mbox{\em B}$) und 
$\mbox{\em R}$ eine Menge von zwei- oder mehrstelligen Relationen über Wörtern aus $\mbox{\em B}$ (hier also die Substitution $\sigma$ als Funktion/zweistellige Releation) ist.}

In einem formalen System $\Gamma$ ist der {\em Abschluss}\index{Abschluss}\footnote{Diese Definition des Abschlusses enthält eine Vereinfachung, die Josh Purinton zu verdanken ist.\index{Purinton, Josh}.} einer Prä-Aussage\linebreak
$\langle D,T,H,A \rangle$ die kleinste Menge $C$ von Ausdrücken, die so beschaffen ist, dass: 
\begin{list}{}{\itemsep 0.0pt}
  \item[1.] $T\cup H\subseteq C$ und
  \item[2.] Wenn für eine axiomatische Aussage
    $\langle D_M',T_M',H',A' \rangle \in
       \Gamma$ und eine Substitution $\sigma$ gilt
    \begin{enumerate}
       \item[a.] $\sigma(T_M' \cup H') \subseteq C$ und
       \item[b.] für alle $\{\alpha,\beta\}\in D_M'$, für alle $\gamma\in
         {\cal V}(\sigma(\langle \alpha
         \rangle))$ und für alle $\delta\in  {\cal V}(\sigma(\langle \beta
         \rangle))$ gilt $\{\gamma, \delta\} \in D$,
   \end{enumerate}
   dann gilt $\sigma(A') \in C$.
\end{list}
Eine Prä-Aussage $\langle D,T,H,A \rangle$ ist {\em beweisbar}\index{beweisbare Aussage!in einem formalen System}, wenn $A\in C$ d.h.\ wenn ihre Behauptung zu ihrem Abschluss gehört.  Eine Aussage ist {\em beweisbar}, wenn sie das Redukt einer beweisbaren Prä-Aussage ist. Das {\em Universum}\index{Universum eines formalen Systems} eines formalen Systems ist die Sammlung aller seiner beweisbaren Aussagen.  Man beachte, dass die Menge der axiomatischen Aussagen $\Gamma$ in einem formalen System eine Teilmenge seines Universums ist. 

{\footnotesize\begin{quotation}
{\em Kommentar:} Die erste Bedingung in der Definition des Abschlusses besagt einfach, dass die Hypothesen der Prä-Aussage in ihrem Abschluss enthalten sind.  

Bedingung 2(a) besagt, dass es eine Substitution gibt, die dafür sorgt, dass die obligatorischen Hypothesen einer axiomatischen Aussage genau mit mindestens einem Element des Abschlusses übereinstimmt.  Dies zeigen wir explizit in einem Beweis mittels der Metamath-Sprache.

%Conditions 2(a) and 2(b) say that a substitution exists that makes the
%(mandatory) hypotheses of an axiomatic statement exactly match some members of
%the closure.  This is what we explicitly demonstrate with a Metamath language
%proof.
%
%The set of expressions $F$ in condition 2(b) excludes the variable-type
%hypotheses; this is done because non-mandatory variable-type hypotheses are
%effectively "`dropped"' as irrelevant whereas logical hypotheses must be
%retained to achieve a consistent logical system.

Bedingung 2(b) beschreibt, wie die disjunkte Variableneinschränkung in der axiomatischen Aussage erfüllt werden müssen.  Sie besagt, dass nach einer Substitution für zwei Variablen, die verschieden sein müssen, die beiden resultierenden Ausdrücke entweder keine Variablen enthalten dürfen oder, falls doch, keine Variablen gemeinsam haben dürfen, und dass jedes Paar von Variablen, die sie haben, mit einer Variablen aus jedem Ausdruck, in der ursprünglichen Anweisung als distinkt angegeben werden muss.
\end{quotation}}

{\footnotesize\begin{quotation}
{\em Beziehung zu Metamath:} Axiomatische Aussagen und beweisbare Aussagen in einem formalen System entsprechen den Frames für \texttt{\$a}- bzw. \texttt{\$p}-Aussagen in einer Metamath-Datenbasis.  Die Menge der axiomatischen Aussagen ist eine Teilmenge der Menge der beweisbaren Aussagen in einem formalen System, obwohl in einer Metamath-Datenbasis eine \texttt{\$a}-Aussage dadurch gekennzeichnet ist, dass sie keinen Beweis hat.  Ein Beweis in der Metamath-Sprache für eine \texttt{\$p}-Anweisung sagt dem Computer, wie er explizit eine Folge von Elementen des Abschlusses konstruieren soll, was schließlich zu dem Nachweis führt, dass die zu beweisende Behauptung in dem Abschluss enthalten ist.  Der tatsächliche Abschluss enthält normalerweise eine unendliche Anzahl von Ausdrücken.  Ein formales System selbst hat kein explizites Objekt, das als "`Beweis"' bezeichnet wird, sondern die Existenz eines Beweises wird indirekt durch die Zugehörigkeit einer Behauptung zum Abschluss einer beweisbaren Ausage impliziert.  Wir tun dies, um das formale System leichter in der Sprache der Mengenlehre beschreiben zu können.  

Wir weisen auch darauf hin, dass eine einmal als beweisbar nachgewiesene Aussage denselben Status wie eine axiomatische Aussage erhält, denn wenn die Menge der axiomatischen Aussagen um eine beweisbare Aussage erweitert wird, bleibt das Universum des formalen Systems unverändert (vorausgesetzt, dass $\mbox{\em VR}$ unendlich ist). In der Praxis bedeutet dies, dass wir eine Hierarchie von beweisbaren Aussagen aufbauen können, um effizienter weitere beweisbare Aussagen zu ermitteln.  Genau das tun wir in Metamath, wenn wir zulassen, dass Beweise auf vorherige \texttt{\$p}-Anweisungen sowie auf vorherige \texttt{\$a}-Anweisungen verweisen.
\end{quotation}}


\section{Beispiele für formale Systeme}

{\footnotesize\begin{quotation}
{\em Beziehung zu Metamath:} Die Beispiele in diesem Abschnitt, mit Ausnahme von Beispiel~2, entsprechen größtenteils exakt dem Vorgehen in der Mengenlehre-Datenbasis \texttt{set.mm}.  Vergleichen Sie die Beispiele~1, 3 und 5 mit Abschnitt~\ref{metaaxioms}, Beispiel 4 mit den Abschnitten~\ref{metadefprop} und \ref{metadefpred} und Beispiel 6 mit Abschnitt~\ref{setdefinitions}.\label{exampleref}
\end{quotation}}

\subsection{Beispiel~1 --- Aussagenlogik}\index{Aussagenlogik}

Die klassische Aussagenlogik kann durch das folgende formale System beschrieben werden.  Wir nehmen an, dass die Menge der Variablen unendlich ist.  Anstatt die Konstanten und Variablen mit $c_0, c_1, \ldots$ und $v_0, v_1, \ldots$ zu bezeichnen, werden wir aus Gründen der Lesbarkeit stattdessen gängigere Symbole verwenden, wobei wir natürlich davon ausgehen, dass sie unterschiedliche primitive Objekte bezeichnen. Der Lesbarkeit halber können wir auch Kommas zwischen aufeinanderfolgenden Glieder einer Folge weglassen; so steht $\langle \mbox{wff\ } \varphi\rangle$ für $\langle \mbox{wff}, \varphi\rangle$. 

Sei
\begin{itemize}
  \item[] $\mbox{\em CN}=\{\mbox{wff}, \vdash, \to, \lnot, (,)\}$
  \item[] $\mbox{\em VR}=\{\varphi,\psi,\chi,\ldots\}$
  \item[] $T = \{\langle \mbox{wff\ } \varphi\rangle,
             \langle \mbox{wff\ } \psi\rangle,
             \langle \mbox{wff\ } \chi\rangle,\ldots\}$, d.h. diejenigen Ausdrücke der Länge 2, deren erstes Glied $\mbox{\rm wff}$ ist und deren zweites Glied zu $\mbox{\em VR}$ gehört.\footnote{ Der Einfachheit halber lassen wir $T$ eine unendliche Menge sein; die Definition einer Aussage erlaubt dies im Prinzip.  Da eine Metamath-Quelldatei eine endliche Größe hat, müssen wir in der Praxis natürlich geeignete endliche Teilmengen dieses $T$ verwenden, und zwar solche, die zumindest die obligatorischen Variablentyp-Hypothesen enthalten.  In ähnlicher Weise führen wir in der Quelldatei nach Bedarf neue Variablen ein, wobei wir davon ausgehen, dass eine potenziell unendliche Anzahl von ihnen verfügbar ist.}
\end{itemize}

\noindent Dann besteht $\Gamma$ aus den axiomatischen Aussagen, die die Redukte der folgenden Prä-Aussagen sind:
    \begin{itemize}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }(\varphi\to\psi)\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }\lnot\varphi\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \vdash(\varphi\to(\psi\to\varphi))
               \rangle\rangle$
      \item[] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash((\varphi\to(\psi\to\chi))\to
               ((\varphi\to\psi)\to(\varphi\to\chi)))
               \rangle\rangle$
      \item[] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash((\lnot\varphi\to\lnot\psi)\to
               (\psi\to\varphi))\rangle\rangle$
      \item[] $\langle\varnothing,T,
               \{\langle\vdash(\varphi\to\psi)\rangle,
                 \langle\vdash\varphi\rangle\},
               \langle\vdash\psi\rangle\rangle$
    \end{itemize}

\noindent Zum Beispiel ist das Redukt von $\langle\varnothing,T,\varnothing, \langle \mbox{wff\ }(\varphi\to\psi)\rangle\rangle$ 
\begin{itemize}
\item[] $\langle\varnothing,
\{\langle \mbox{wff\ } \varphi\rangle,
             \langle \mbox{wff\ } \psi\rangle\},
             \varnothing,
               \langle \mbox{wff\ }(\varphi\to\psi)\rangle\rangle$,
\end{itemize}

und von $\langle\varnothing,T,\varnothing,\langle \vdash((\varphi\to(\psi\to\chi))\to((\varphi\to\psi)\to(\varphi\to\chi)))
\rangle\rangle$
\begin{itemize}
\item[] $\langle\varnothing,\{\langle \mbox{wff\ } \varphi\rangle,
\langle \mbox{wff\ } \psi\rangle, \langle \mbox{wff\ } \chi\rangle\},\varnothing,\langle \vdash((\varphi\to(\psi\to\chi))\to((\varphi\to\psi)\to(\varphi\to\chi)))
\rangle\rangle$,
\end{itemize}
welches die erste und die vierte axiomatischen Aussagen sind.

Wir nennen die Elemente von $\mbox{\em VR}$ {\em wff-Variablen} oder (im Kontext der Logik erster Ordnung, die wir gleich beschreiben werden) {\em wff-Metavariablen}. Man beachte, dass die Symbole $\phi$, $\psi$ usw.\ tatsächliche spezifische Elemente der Menge $\mbox{\em VR}$ bezeichnen; sie sind keine Metavariablen unserer Beschreibungssprache (die wir mit $\alpha$, $\beta$ usw. bezeichnen), sondern sind stattdessen (meta)konstante Symbole (Elemente der Menge $\mbox{\em SM}$) aus der Sicht unserer Beschreibungssprache.  Das in \cite{Tarski1965} beschriebene äquivalente System der Aussagenlogik verwendet ebenfalls die Symbole $\phi$, $\psi$ usw.\, um wff-Metavariablen zu bezeichnen, aber in \cite{Tarski1965} sind dies im Gegensatz zu hier Metavariablen der Beschreibungssprache und keine primitiven Symbole des formalen Systems. 

Die ersten beiden Aussagen definieren wffs: wenn $\varphi$ und $\psi$ wffs sind, dann ist $(\varphi \to \psi)$ auch eine wff; wenn $\varphi$ eine wff ist, dann ist $\lnot\varphi$ auch eine wff. Die nächsten drei sind die Axiome der Aussagenlogik: Wenn $\varphi$ und $\psi$ wffs sind, dann ist $\vdash (\varphi \to (\psi \to \varphi))$ ein (axiomatisches) Theorem; usw. Die letzte ist der Modus ponens: wenn $\varphi$ und $\psi$ wffs sind, und $\vdash (\varphi\to\psi)$ und $\vdash \varphi$ Theoreme sind, dann ist $\vdash \psi$ ein Theorem. 

Die Entsprechung zur gewöhnlichen Aussagenlogik ist wie folgt.  Wir betrachten nur beweisbare Aussagen der Form $\langle\varnothing, T,\varnothing,A\rangle$ mit $T$ definiert wie oben.  Der erste Term der Behauptung $A$ einer solchen Aussage ist entweder "`wff"' oder "`$\vdash$"'.  Eine Aussage, bei der der erste Term "`wff"' ist, ist eine {\em wff} der Aussagenlogik, und eine, bei der der erste Term "`$\vdash$"' ist, ist ein {\em Theorem (Schema)} der Aussagenlogik. 

Das Universum dieses formalen Systems enthält auch viele andere beweisbare Aussagen.  Diejenigen mit Beschränkungen für unterschiedliche Variablen sind irrelevant, da die Aussagenlogik keine Beschränkungen für Substitutionen kennt.  Diejenigen, die logische Hypothesen haben, nennen wir {\em Inferenzen}\index{Inferenz}, wenn die logischen Hypothesen von der Form $\langle\vdash\rangle\frown w$ sind, wobei $w$ eine wff ist (wobei der führende konstante Term "`wff"' entfernt wurde).  Inferenzen (mit Ausnahme des Modus ponens) sind kein eigentlicher Bestandteil der Aussagenlogik, lassen sich aber beim Aufbau einer Hierarchie von beweisbaren Aussagen gut verwenden.  Eine beweisbare Aussage mit einer unsinnigen Hypothese wie $\langle \to,\vdash,\lnot\rangle$ und demselben Ausdruck als Behauptung betrachten wir als irrelevant; sie kann beim Beweis von Theoremen nicht verwendet werden, da es keine Möglichkeit gibt, die unsinnige Hypothese zu eliminieren. 

{\footnotesize\begin{quotation}
{\em Kommentar:} Unsere Verwendung von Klammern in der Definition einer wff zeigt, dass axiomatische Aussagegen sorgfältig so formuliert werden sollten, dass sie eindeutig mit den vom formalen System erlaubten Substitutionen zusammenpassen. Es gibt viele Möglichkeiten, wffs zu definieren - die polnische Präfix-Notation hätte es uns beispielsweise erlaubt, die Klammern ganz wegzulassen, was allerdings zu Lasten der Lesbarkeit gegangen wäre -, aber wir müssen sie auf eine Weise definieren, die eindeutig ist.  Hätten wir z.B. die Klammern in der Definition von $(\varphi\to \psi)$ weggelassen, hätte die wff $\lnot\varphi\to \psi$ entweder als $\lnot(\varphi\to\psi)$ oder $(\lnot\varphi\to\psi)$ interpretiert werden können und hätte uns erlaubt, Unsinn zu beweisen.  Es ist zu beachten, dass unser formales System kein Konzept der Vorrangigkeit von Operatoren enthält.
\end{quotation}}

\begin{sloppy}
\subsection{Beispiel~2 --- Prädikatenlogik mit Gleichheit}\index{Prädikatenlogik}
\end{sloppy}

Hier erweitern wir Beispiel~1 um die Prädikatenlogik mit Gleichheit zu erhalten und veranschaulichen damit die Verwendung von disjunkte Variableneinschränkungen.  Dieses System ist dasselbe wie Tarskis System $\mathfrak{S}_2$ in \cite{Tarski1965} (mit der Ausnahme, dass die Axiome der Aussagenlogik unterschiedlich, aber äquivalent sind, und dass ein redundantes Axiom weggelassen wird).  Wir erweitern $\mbox{\em CN}$ um die Konstanten $\{\mbox{var},\forall,=\}$ und $\mbox{\em VR}$ um eine unendliche Menge von {\em individuelle Metavariablen}\index{individuelle Metavariable} $\{x,y,z,\ldots\}$ und bezeichnen diese Teilmenge als $\mbox{\em Vr}$. 

Wir erweitern $\mbox{\em CN}$ auch um eine möglicherweise unendliche Menge $\mbox{\em Pr}$ von {\em Prädikaten} $\{R,S,\ldots\}$.  Wir assoziieren mit $\mbox{\em Pr}$ eine Funktion $\mbox{rnk}$ von $\mbox{\em Pr}$ nach $\omega$, und für $\alpha\in \mbox{\em Pr}$ nennen wir $\mbox{rnk}(\alpha)$ den {\em Rang} des Prädikats $\alpha$, der einfach die Anzahl der "`Argumente"' ist, die das Prädikat hat.  (Die meisten Anwendungen der Prädikatenlogik haben eine endliche Anzahl von Prädikaten; in der Mengenlehre gibt es z.B. ein einziges Prädikat mit zwei Argumenten (auch binäres Prädikat genannt) $\in$, das üblicherweise mit seinen Argumenten um das Prädikatssymbol herum geschrieben wird und nicht mit der Präfix-Notation, die wir für den allgemeinen Fall verwenden).
Um unsere Diskussion zu erleichtern sei $\mbox{\em Vs}$ eine beliebige feste injektive Funktion von $\omega$ nach $\mbox{\em Vr}$; somit ist $\mbox{\em Vs}$ eine beliebige einfache unendliche Folge von einzelnen Metavariablen ohne Wiederholungen. 

In diesem Beispiel verzichten wir auf die Funktionssymbole, die häufig Teil von Formalisierungen der Prädikatenlogik sind.  Unter Verwendung metalogischer Argumente, die den Rahmen unserer Diskussion sprengen würden, kann gezeigt werden, dass unsere Formalisierung äquivalent ist, wenn Funktionen über geeignete Definitionen eingeführt werden. 

Wir erweitern die in Beispiel~1 definierte Menge $T$ um die Ausdrücke $\{\langle \mbox{var\ } x\rangle,$ $ \langle \mbox{var\ } y\rangle, \langle \mbox{var\ } z\rangle,\ldots\}$ und das obige $\Gamma$ um die axiomatischen Aussagen, die die Redukte der folgenden Prä-Aussagen sind: 
\begin{list}{}{\itemsep 0.0pt}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }\forall x\,\varphi\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }x=y\rangle\rangle$
      \item[] $\langle\varnothing,T,
               \{\langle\vdash\varphi\rangle\},
               \langle\vdash\forall x\,\varphi\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \vdash((\forall x(\varphi\to\psi)
                  \to(\forall x\,\varphi\to\forall x\,\psi))
               \rangle\rangle$
      \item[] $\langle\{\{x,\varphi\}\},T,\varnothing,
               \langle \vdash(\varphi\to\forall x\,\varphi)
               \rangle\rangle$
      \item[] $\langle\{\{x,y\}\},T,\varnothing,
               \langle \vdash\lnot\forall x\lnot x=y
               \rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \vdash(x=z
                  \to(x=y\to z=y))
               \rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \vdash(y=z
                  \to(x=y\to x=z))
               \rangle\rangle$
\end{list}
Dies sind die Axiome, die keine Prädikatssymbole beinhalten. Die ersten beiden Anweisungen erweitern die Definition einer wff.  Die dritte ist die Regel der Verallgemeinerung.  Die fünfte besagt: "`Für eine wff $\varphi$ und die Variable $x$ gilt: $\vdash(\varphi\to\forall x\,\varphi)$, sofern $x$ nicht in $\varphi$ vorkommt."'  Die sechste lautet: "`Für die Variablen $x$ und $y$ gilt $\vdash\lnot\forall x\lnot x = y$, sofern $x$ und $y$ verschieden sind."' (Dieser Vorbehalt ist nicht notwendig, wurde aber von Tarski eingefügt, um das Axiom abzuschwächen und trotzdem zu zeigen, dass das System logisch vollständig ist.) 

Schließlich fügen wir für jedes Prädikatssymbol $\alpha\in \mbox{\em Pr}$ eine axiomatische Aussage zu $\Gamma$ hinzu, die die Definition von wff erweitert und die das Redukt der folgenden Prä-Ausage ist: 
\begin{displaymath}
    \langle\varnothing,T,\varnothing,
            \langle \mbox{wff},\alpha\rangle\
            \frown \mbox{\em Vs}\restriction\mbox{rnk}(\alpha)\rangle
\end{displaymath}
und für jedes $\alpha\in \mbox{\em Pr}$ und jedes $n < \mbox{rnk}(\alpha)$ fügen wir zu $\Gamma$ ein Gleichheitsaxiom hinzu, das das Redukt der folgenden Prä-Aussage ist:
\begin{eqnarray*}
    \lefteqn{\langle\varnothing,T,\varnothing,
            \langle
      \vdash,(,\mbox{\em Vs}_n,=,\mbox{\em Vs}_{\mbox{rnk}(\alpha)},\to,
            (,\alpha\rangle\frown \mbox{\em Vs}\restriction\mbox{rnk}(\alpha)} \\
  & & \frown
            \langle\to,\alpha\rangle\frown \mbox{\em Vs}\restriction n\frown
            \langle \mbox{\em Vs}_{\mbox{rnk}(\alpha)}\rangle \\
 & & \frown
            \mbox{\em Vs}\restriction(\mbox{rnk}(\alpha)\setminus(n+1))\frown
            \langle),)\rangle\rangle
\end{eqnarray*}
wobei $\restriction$ die Einschränkung des Definitionsbereichs und $\setminus$ die Mengendifferenz bezeichnet.  Erinnern Sie sich daran, dass ein tiefgestellter Index in $\mbox{\em Vs}$ einen seiner Terme kennzeichnet.  (In den beiden obigen axiomatischen Aussagen werden Kommas zwischen aufeinanderfolgende Terme von Sequenzen gesetzt, um Mehrdeutigkeit zu vermeiden, und wenn Sie sie genau betrachten, werden Sie in der Lage sein, die Klammern, die konstante Symbole bezeichnen, von den Klammern unserer Beschreibungssprache, die Funktionsargumente abgrenzen, zu unterscheiden.  Es wäre vielleicht besser gewesen, unsere primitiven Symbole fett zu schreiben, aber leider waren nicht für alle Zeichen in dem \LaTeX-System, das für den Schriftsatz dieses Textes verwendet wurde, Fettschrift verfügbar).  Diese scheinbar verbotenen Axiome lassen sich in Analogie zur Verkettung von Teilzeichenfolgen in einer Computersprache verstehen.  Tatsächlich sind sie für jeden spezifischen Fall relativ einfach und werden deutlicher, wenn man den Spezialfall eines binären Prädikats $\alpha = R$ betrachtet, bei dem $\mbox{rnk}(R)=2$ ist.  Wenn $\mbox{\em Vs}$ die Folge $\langle x,y,z,\ldots\rangle$ ist, wären die Axiome, die wir für diesen Fall zu $\Gamma$ hinzufügen würden, die wff-Erweiterung und zwei Gleichheitsaxiome, die die Redukte der folgenden Aussagen sind: 
\begin{list}{}{\itemsep 0.0pt}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }R x y\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \vdash(x=z
                  \to(R x y \to R z y))
               \rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \vdash(y=z
                  \to(R x y \to R x z))
               \rangle\rangle$
\end{list}
Studieren Sie diese sorgfältig, um zu sehen, wie sie aus den obigen allgemeinen Axiome entstehen.  In der Praxis werden typischerweise nur wenige Spezialfälle wie dieser benötigt, und in jedem Fall erlaubt uns die Metamath-Sprache nur die Beschreibung einer endlichen Anzahl von Prädikaten, im Gegensatz zu der unendlichen Anzahl, die das formale System erlaubt.  (Sollte aus irgendeinem Grund eine unendliche Anzahl benötigt werden, könnten wir das formale System nicht direkt in der Metamath-Sprache definieren, sondern könnten es stattdessen metalogisch unter der Mengenlehre definieren, wie wir es in diesem Anhang tun, und nur die zugrunde liegende Mengenlehre mit ihrem einzigen binären Prädikat würde direkt in der Metamath-Sprache definiert). 


{\footnotesize\begin{quotation}
{\em Kommentar:}  Wie bereits erwähnt, handelt es sich bei den spezifischen Variablen, die durch die Symbole $x,y,z,\ldots\in \mbox{\em Vr}\subseteq \mbox{\em VR}\subseteq \mbox{\em SM}$ in Beispiel~2 dargestellt werden, nicht um die eigentlichen Variablen der gewöhnlichen Prädikatenlogik, sondern sie sind als Metavariablen zu betrachten, die sich über diese erstrecken.  Zum Beispiel wäre eine disjunkte Variableneinschränkung für eigentliche Variablen der gewöhnlichen Prädikatenlogik bedeutungslos, da zwei verschiedene eigentliche Variablen per Definition unterschiedlich sind.  Und wenn wir über einen beliebigen Repräsentanten $\alpha\in \mbox{\em Vr}$ sprechen, ist $\alpha$ eine Metavariable (in unserer Erklärungssprache), die sich über Metavariablen erstreckt (die Primitive unseres formalen Systems sind), von denen sich jede über die einzelnen eigentlichen Variablen der Prädikatenlogik erstreckt (die in unserem formalen System nie erwähnt werden).  

Die oben genannte Konstante "`var"' heißt in der \texttt{set.mm}-Datenbasis \texttt{setvar}, aber sie bedeutet dasselbe.  Ich war der Meinung, dass "`var"' im Kontext der Prädikatenlogik, deren Verwendung nicht auf die Mengenlehre beschränkt ist, ein sinnvollerer Name ist.  Aus Gründen der Konsistenz bleiben wir in diesem Anhang bei dem Namen "`var"', auch nachdem die Mengenlehre eingeführt wurde.
\end{quotation}}

\subsection{Freie Variablen und echte Substitution}\index{freie Variable}
\index{echte Substitution}\index{Substitution!echte}

Typische Darstellungen mathematischer Axiome verwenden Konzepte wie "`freie Variable"', "`gebundene Variable"' und "`echte Substitution"' als primitive Begriffe. Eine freie Variable ist eine Variable, die kein Parameter eines Containerausdrucks ist. Eine gebundene Variable ist das Gegenteil einer freien Variable; sie ist eine Variable, die in einem Containerausdruck gebunden wurde. Zum Beispiel ist in dem Ausdruck $\forall x \varphi$ (für alle $x$ ist $\varphi$ wahr) die Variable $x$ in dem "`für alle"'-Ausdruck ($\forall$) gebunden. Es ist möglich, eine Variable durch eine andere zu ersetzen, und diesen Vorgang nennt man "`echte Substitution"'. In den meisten Büchern hat die echte Substitution eine etwas komplizierte rekursive Definition mit mehreren Fällen, die auf dem Vorkommen von freien und gebundenen Variablen basieren.
Sie können in \cite[ch.\ 3--4]{Hamilton}\index{Hamilton, Alan G.} (sowie in vielen anderen Texten) für weitere formale Details zu diesen Begriffen nachschauen. 

Die Verwendung dieser Konzepte als \texttt{primitives} schafft Komplikationen für Computerimplementierungen. 

In dem System von Beispiel~2 gibt es keine primitiven Begriffe für freie Variablen und die echten Substitution.  Tarski \cite{Tarski1965} zeigt, dass dieses System logisch äquivalent zu den typischeren Lehrbuchsystemen ist, die diese primitiven Begriffe haben, wenn wir diese Begriffe mit geeigneten Definitionen und Metalogik einführen.  Wir könnten auch direkt Axiome für solche Systeme definieren, obwohl die rekursiven Definitionen der freien Variablen und der echten Substitution unübersichtlich und umständlich zu handhaben wären.  Stattdessen weisen wir auf zwei Hilfsmittel hin, die in der Praxis verwendet werden können, um diese Begriffe zu imitieren.  (1) Anstatt eine spezielle Notation einzuführen, um (als logische Hypothese) "`wobei $x$ nicht frei in $\varphi$ ist"' auszudrücken, können wir die logische Hypothese $\vdash(\varphi\to\forall x\,\varphi)$ verwenden.\label{effectivelybound}\index{effektiv nicht frei}\footnote{Dies ist eine etwas schwächere Anforderung als "`wobei $x$ nicht frei in $\varphi$ ist"'.  Ersetzen wir $\varphi$ durch $x=x$, so haben wir den Satz $(x=x\to\forall x\,x=x)$, der die Hypothese erfüllt, obwohl $x$ in $x=x$ frei ist. In einem solchen Fall sagen wir, dass $x$ {\em effektiv nicht frei}\index{effektiv nicht frei} in $x=x$ ist, da $x=x$ logisch äquivalent zu $\forall x\,x=x$ ist, in dem $x$ gebunden ist.} (2) Es kann gezeigt werden, dass die wff $((x=y\to\varphi)\wedge\exists x(x=y\wedge\varphi))$ (mit den üblichen Definitionen von $\wedge$ und $\exists$; siehe Beispiel~4 unten) logisch äquivalent ist zu "`die wff, die sich aus der echten Substitutiong von $y$ für $x$ in $\varphi$ ergibt"'.  Das funktioniert unabhängig davon, ob $x$ und $y$ verschieden sind oder nicht. 

\subsection{Metalogische Vollständigkeit}\index{metalogische Vollständigkeit}

In dem System von Beispiel~2 sind die folgenden Prä-Aussagen beweisbar (und ihre Redukte sind beweisbare Aussagen): 
\begin{eqnarray*}
      & \langle\{\{x,y\}\},T,\varnothing,
               \langle \vdash\lnot\forall x\lnot x=y
               \rangle\rangle & \\
     &  \langle\varnothing,T,\varnothing,
               \langle \vdash\lnot\forall x\lnot x=x
               \rangle\rangle &
\end{eqnarray*}
wohingegen die folgende Prä-Aussage meines Wissens nach nicht beweisbar ist (aber wir werden in der folgenden Diskussion so tun, als ob sie es nicht wäre: 
\begin{eqnarray*}
     &  \langle\varnothing,T,\varnothing,
               \langle \vdash\lnot\forall x\lnot x=y
               \rangle\rangle &
\end{eqnarray*}
Mit anderen Worten, wir können "`$\lnot\forall x\lnot x=y$, wobei $x$ und $y$ verschieden sind"' und separat "`$\lnot\forall x\lnot x=x$"' beweisen, aber wir können den kombinierten allgemeinen Fall "`$\lnot\forall x\lnot x=y$"' nicht beweisen, der keine zusätzlich Bedingung hat.  Dies beeinträchtigt jedoch nicht die logische Vollständigkeit, da die Variablen wirklich Metavariablen sind und die beiden beweisbaren Fälle zusammen alle möglichen Fälle abdecken.  Der dritte Fall kann als ein Metatheorem betrachtet werden, dessen direkter Beweis mit dem System von Beispiel~2 außerhalb der Möglichkeiten des formalen Systems liegt. 

Außerdem ist im System von Beispiel~2 die folgende Anweisung meines Wissens nicht beweisbar (wiederum eine Vermutung, die wir als wahr unterstellen werden): 
\begin{eqnarray*}
     & \langle\varnothing,T,\varnothing,
               \langle \vdash(\forall x\, \varphi\to\varphi)
               \rangle\rangle &
\end{eqnarray*}
Stattdessen können wir nur spezielle Fälle von $\varphi$ mit individuellen Metavariablen beweisen und durch Induktion über die Formellänge die obige allgemeine Anweisung als Metatheorem außerhalb unseres formalen Systems beweisen.  Die Einzelheiten dieses Beweises finden sich in \cite{Kalish}. 

Es gibt jedoch ein System der Prädikatenlogik, in dem alle derartigen "`einfachen Metatheoreme"' wie die obigen direkt bewiesen werden können, und wir stellen es in Beispiel~3 vor. Ein {\em einfaches Metatheorem}\index{einfaches Metatheorem} ist jede Aussage des formalen Systems aus Beispiel~2, in dem alle disjukte Variableneinschränkung entweder aus zwei individuellen Metavariablen oder einer individuellen Metavariablen und einer wff-Metavariablen bestehen, und die durch Kombination von Fällen außerhalb des Systems wie oben bewiesen werden kann.  Ein System ist {\em metalogisch vollständig}\index{metalogische Vollständigkeit}, wenn alle seine einfachen Metatheoreme (direkt) beweisbare Aussagen sind. Die genaue Definition von "`einfachem Metatheorem"' und der Beweis der "`metalogischen Vollständigkeit"' von Beispiel~3 findet sich in Bemerkung 9.6 und Theorem 9.7 von \cite{Megill}.\index{Megill, Norman} 

\begin{sloppy}
\subsection{Beispiel~3 --- Metalogisch vollständige Prädikatenlogik mit Gleichheit}
\end{sloppy}

Der Einfachheit halber nehmen wir an, dass es ein binäres Prädikat $R$ gibt; dieses System reicht für die Mengenlehre aus, wobei das $R$ natürlich das Prädikat $\in$ ist.  Wir enennen die Axiome so, wie sie in \cite{Megill} vorkommen.  Dieses System ist logisch äquivalent zu dem in Beispiel~2 (wenn letzteres auf dieses eine binäre Prädikat beschränkt wird), ist aber auch metalogisch vollständig\index{metalogische Vollständigkeit}.

Angenommen
\begin{itemize}
  \item[] $\mbox{\em CN}=\{\mbox{wff}, \mbox{var}, \vdash, \to, \lnot, (,),\forall,=,R\}$.
  \item[] $\mbox{\em VR}=\{\varphi,\psi,\chi,\ldots\}\cup\{x,y,z,\ldots\}$.
  \item[] $T = \{\langle \mbox{wff\ } \varphi\rangle,
             \langle \mbox{wff\ } \psi\rangle,
             \langle \mbox{wff\ } \chi\rangle,\ldots\}\cup
       \{\langle \mbox{var\ } x\rangle, \langle \mbox{var\ } y\rangle, \langle
       \mbox{var\ }z\rangle,\ldots\}$.

\noindent Dann besteht $\Gamma$ aus den Redukten der folgenden Prä-Aussagen:
    \begin{itemize}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }(\varphi\to\psi)\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }\lnot\varphi\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }\forall x\,\varphi\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }x=y\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }Rxy\rangle\rangle$
      \item[(C1$'$)] $\langle\varnothing,T,\varnothing,
               \langle \vdash(\varphi\to(\psi\to\varphi))
               \rangle\rangle$
      \item[(C2$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash((\varphi\to(\psi\to\chi))\to
               ((\varphi\to\psi)\to(\varphi\to\chi)))
               \rangle\rangle$
      \item[(C3$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash((\lnot\varphi\to\lnot\psi)\to
               (\psi\to\varphi))\rangle\rangle$
      \item[(C4$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\forall x(\forall x\,\varphi\to\psi)\to
                 (\forall x\,\varphi\to\forall x\,\psi))\rangle\rangle$
      \item[(C5$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\forall x\,\varphi\to\varphi)\rangle\rangle$
      \item[(C6$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\forall x\forall y\,\varphi\to
                 \forall y\forall x\,\varphi)\rangle\rangle$
      \item[(C7$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\lnot\varphi\to\forall x\lnot\forall x\,\varphi
                 )\rangle\rangle$
      \item[(C8$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(x=y\to(x=z\to y=z))\rangle\rangle$
      \item[(C9$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\lnot\forall x\, x=y\to(\lnot\forall x\, x=z\to
                 (y=z\to\forall x\, y=z)))\rangle\rangle$
      \item[(C10$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\forall x(x=y\to\forall x\,\varphi)\to
                 \varphi))\rangle\rangle$
      \item[(C11$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\forall x\, x=y\to(\forall x\,\varphi
               \to\forall y\,\varphi))\rangle\rangle$
      \item[(C12$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(x=y\to(Rxz\to Ryz))\rangle\rangle$
      \item[(C13$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(x=y\to(Rzx\to Rzy))\rangle\rangle$
      \item[(C15$'$)] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(\lnot\forall x\, x=y\to(x=y\to(\varphi
                 \to\forall x(x=y\to\varphi))))\rangle\rangle$
      \item[(C16$'$)] $\langle\{\{x,y\}\},T,
               \varnothing,
               \langle \vdash(\forall x\, x=y\to(\varphi\to\forall x\,\varphi)
                 )\rangle\rangle$
      \item[(C5)] $\langle\{\{x,\varphi\}\},T,\varnothing,
               \langle \vdash(\varphi\to\forall x\,\varphi)
               \rangle\rangle$
      \item[(MP)] $\langle\varnothing,T,
               \{\langle\vdash(\varphi\to\psi)\rangle,
                 \langle\vdash\varphi\rangle\},
               \langle\vdash\psi\rangle\rangle$
      \item[(Gen)] $\langle\varnothing,T,
               \{\langle\vdash\varphi\rangle\},
               \langle\vdash\forall x\,\varphi\rangle\rangle$
    \end{itemize}
\end{itemize}

Es ist zwar bekannt, dass diese Axiome "`metalogisch vollständig"' sind, aber es ist nicht bekannt, ob sie im metalogischen Sinne unabhängig sind (d.h. keines ist redundant); insbesondere, ob irgendein Axiom (möglicherweise mit zusätzlichen optionalen disjunkte Variableneinschränkungen zur Verwendung von beliebigen Dummy-Variablen in seinem Beweis) aus den anderen beweisbar ist.  Beachten Sie, dass metalogische Unabhängigkeit eine schwächere Anforderung ist als Unabhängigkeit im üblichen logischen Sinne.  Nicht alle der oben genannten Axiome sind logisch unabhängig: beispielsweise kann C9$'$ als Metatheorem aus den anderen bewiesen werden, und zwar außerhalb des formalen Systems, indem die möglichen Fälle von unterscheidbaren Variablen kombiniert werden. 

\subsection{Beispiel~4 --- Hinzufügen von Definitionen}\index{Definition}

Es gibt mehrere Möglichkeiten, einem formalen System Definitionen hinzuzu\-fügen.  Der wahrscheinlich beste Weg ist, Definitionen überhaupt nicht als Teil des formalen Systems zu betrachten, sondern als Abkürzungen, die Teil der erklärenden Metalogik außerhalb des formalen Systems sind.  Der Einfachheit halber können wir jedoch das formale System selbst verwenden, um Definitionen einzubeziehen, indem wir sie als axiomatische Erweiterungen zum System hinzufügen.  Dies könnte durch das Hinzufügen einer Konstante geschehen, die den Begriff "`ist definiert als"' zusammen mit Axiomen für diesen Begriff repräsentiert. Aber es gibt einen schöneren Weg, zumindest meiner Meinung nach, der Definitionen als direkte Erweiterungen der Sprache und nicht als extralogische primitive Begriffe einführt.  Wir führen zusätzliche logische Junktoren ein und stellen Axiome für sie bereit.  Für Logiksysteme wie die Beispiele 1 bis 3 müssen die zusätzlichen Axiome in dem Sinne konservativ sein, dass keine wff des ursprünglichen Systems, das kein Theorem war (wenn der ursprüngliche Begriff "`wff"' natürlich durch "`$\vdash$"' ersetzt wird), zu einem Theorem des erweiterten Systems wird.  In diesem Beispiel erweitern wir Beispiel~3 (oder 2) mit Standardabkürzungen der Logik. 

Wir erweitern $\mbox{\em CN}$ aus Beispiel~3 um neue Konstanten $\{\leftrightarrow, \wedge,\vee,\exists\}$, die der logischen Äquivalenz\index{logische Äquivalenz ($\leftrightarrow$)}\index{Bikonditional ($\leftrightarrow$)}, Konjunktion\index{Konjunktion ($\wedge$)}, Disjunktion\index{Disjunktion ($\vee$)} und dem Existenzquantor\index{Existenzquantor ($\exists$)} entsprechen. Wir erweitern $\Gamma$ um die axiomatischen Ausagen, die die Redukte der folgenden Prä-Aussagen sind: 
\begin{list}{}{\itemsep 0.0pt}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }(\varphi\leftrightarrow\psi)\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }(\varphi\vee\psi)\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }(\varphi\wedge\psi)\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }\exists x\, \varphi\rangle\rangle$
  \item[] $\langle\varnothing,T,\varnothing,
     \langle\vdash ( ( \varphi \leftrightarrow \psi ) \to
     ( \varphi \to \psi ) )\rangle\rangle$
  \item[] $\langle\varnothing,T,\varnothing,
     \langle\vdash ((\varphi\leftrightarrow\psi)\to
    (\psi\to\varphi))\rangle\rangle$
  \item[] $\langle\varnothing,T,\varnothing,
     \langle\vdash ((\varphi\to\psi)\to(
     (\psi\to\varphi)\to(\varphi
     \leftrightarrow\psi)))\rangle\rangle$
  \item[] $\langle\varnothing,T,\varnothing,
     \langle\vdash (( \varphi \wedge \psi ) \leftrightarrow\neg ( \varphi
     \to \neg \psi )) \rangle\rangle$
  \item[] $\langle\varnothing,T,\varnothing,
     \langle\vdash (( \varphi \vee \psi ) \leftrightarrow (\neg \varphi
     \to \psi )) \rangle\rangle$
  \item[] $\langle\varnothing,T,\varnothing,
     \langle\vdash (\exists x \,\varphi\leftrightarrow
     \lnot \forall x \lnot \varphi)\rangle\rangle$
\end{list}
Die ersten drei logischen Axiome (Aussagen, die "`$\vdash$"' enthalten) führen die logische Äquivalenz, "`$\leftrightarrow$"', ein und definieren sie effektiv.  Die letzten drei verwenden "`$\leftrightarrow$"' effektiv in der bedeutung von "`ist definiert als"'. 


\subsection{Beispiel~5 --- ZFC Mengenlehre}\index{ZFC-Mengenlehre}

Hier fügen wir dem System in Beispiel~4 die Axiome der Zermelo--Fraenkel-Mengenlehre mit Auswahlaxionm hinzu.  Der Einfachheit halber verwenden wir die Definitionen aus Beispiel~4. 

In der $\mbox{\em CN}$ aus Beispiel~4 (die Beispiel~3 erweitert), ersetzen wir das Symbol $R$ durch das Symbol $\in$. Genauer gesagt, wir entfernen aus $\Gamma$ aus Beispiel~4 die drei axiomatischen Aussagegen, die $R$ enthalten, und ersetzen sie durch die Redukte der folgenden: 
\begin{list}{}{\itemsep 0.0pt}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }x\in y\rangle\rangle$
      \item[] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(x=y\to(x\in z\to y\in z))\rangle\rangle$
      \item[] $\langle\varnothing,T,
               \varnothing,
               \langle \vdash(x=y\to(z\in x\to z\in y))\rangle\rangle$
\end{list}
Unter der Annahme, dass $D=\{\{\alpha,\beta\}\in \mbox{\em DV}\,|\alpha,\beta\in \mbox{\em Vr}\}$ (mit anderen Worten müssen alle einzelnen Variablen verschieden sein), erweitern wir $\Gamma$ um die ZFC-Axiome, genannt 
Extensionalität\index{Extensionalitätsaxiom},
Ersetzung\index{Ersetzungsaxiom},
Vereinigung\index{Vereinigungsaxiom},
Potenzmenge\index{Potenzmengenaxiom},
Regelmäßigkeit\index{Fundierungsaxiom},
Unendlichkeit\index{Unendlichkeitsaxiom} und
dem Auswahlaxiom\index{Auswahlaxiom}, die die Redukte der folgenden Prä-Aussagen sind: 
\begin{list}{}{\itemsep 0.0pt}
      \item[Ext] $\langle D,T,
               \varnothing,
               \langle\vdash (\forall x(x\in y\leftrightarrow x \in z)\to y
               =z) \rangle\rangle$
      \item[Rep] $\langle D,T,
               \varnothing,
               \langle\vdash\exists x ( \exists y \forall z (\varphi \to z = y
                        ) \to
                        \forall z ( z \in x \leftrightarrow \exists x ( x \in
                        y \wedge \forall y\,\varphi ) ) )\rangle\rangle$
      \item[Un] $\langle D,T,
               \varnothing,
               \langle\vdash \exists x \forall y ( \exists x ( y \in x \wedge
               x \in z ) \to y \in x ) \rangle\rangle$
      \item[Pow] $\langle D,T,
               \varnothing,
               \langle\vdash \exists x \forall y ( \forall x ( x \in y \to x
               \in z ) \to y \in x ) \rangle\rangle$
      \item[Reg] $\langle D,T,
               \varnothing,
               \langle\vdash (  x \in y \to
                 \exists x ( x \in y \wedge \forall z ( z \in x \to \lnot z
                \in y ) ) ) \rangle\rangle$
      \item[Inf] $\langle D,T,
               \varnothing,
               \langle\vdash \exists x(y\in x\wedge\forall y(y\in
               x\to
               \exists z(y \in z\wedge z\in x))) \rangle\rangle$
      \item[AC] $\langle D,T,
               \varnothing,
               \langle\vdash \exists x \forall y \forall z ( ( y \in z
               \wedge z \in w ) \to \exists w \forall y ( \exists w
              ( ( y \in z \wedge z \in w ) \wedge ( y \in w \wedge w \in x
              ) ) \leftrightarrow y = w ) ) \rangle\rangle$
\end{list}

\subsection{Beispiel~6 --- Begriff der Klasse in der Mengenlehre}\label{class}

Ein leistungsfähiges Hilfsmittel, das die Mengenlehre vereinfacht (und das wir die ganze Zeit in unserer informellen Beschreibungssprache verwendet haben), ist die Notation der {\em Klassenabstraktion}\index{Klassenabstraktion}\index{Abstraktionsklasse}.  Die von uns eingeführten Definitionen werden von Takeuti und Zaring \cite{Takeuti}\index{Takeuti, Gaisi} oder Quine \cite{Quine}\index{Quine, Willard Van Orman} rigoros als konservativ nachgewiesen.  Die Schlüsselidee ist die Einführung der Notation $\{x|\mbox{---}\}$ für Abstraktionsklassen, was "`die Klasse aller $x$, so dass ---"' bedeutet, und die Einführung von (Meta-)Variablen, die sich über sie erstrecken.  Eine Abstraktionsklasse kann eine Menge sein oder auch nicht, je nachdem, ob sie (als Menge) existiert.  Eine Klasse, die nicht (als Menge) existiert, nennt man eine {\em echte Klasse}\index{echte Klasse}\index{Klasse!echte}.

Zur Veranschaulichung der Verwendung von Abstraktionsklassen geben wir einige Beispiele für Definitionen, die von ihnen Gebrauch machen: die leere Menge, die Klassenvereinigung und das ungeordnete Paar.  Viele weitere derartige Definitionen finden sich in der Metamath-Datenbasis für Mengenlehre, \texttt{set.mm}\index{Mengenlehre-Datenbasis (\texttt{set.mm})}. 

% We intentionally break up the sequence of math symbols here
% because otherwise the overlong line goes beyond the page in narrow mode.
Wir erweitern $\mbox{\em CN}$ aus Beispiel~5 um neue Symbole $\{$ $\mbox{class},$ $\{,$ $|,$ $\},$ $\varnothing,$ $\cup,$ $,$ $\}$, wobei die inneren Klammern und das letzte Komma konstante Symbole sind. (Wie zuvor sollte unsere doppelte Verwendung einiger mathematischer Symbole sowohl für unsere Beschreibungssprache als auch als Primitive des formalen Systems aus dem Kontext heraus klar sein). 

Wir erweitern $\mbox{\em VR}$ aus Beispiel~5 mit einer Menge von {\em Klassenvariablen}\index{Klassenvariable} $\{A,B,C,\ldots\}$. Wir erweitern das $T$ aus Beispiel~5 mit $\{\langle \mbox{class\ } A\rangle, \langle \mbox{class\ }B\rangle,$ $\langle \mbox{class\ } C\rangle, \ldots\}$. 

Um unsere Definitionen einzuführen, fügen wir zu $\Gamma$ aus Beispiel~5 die axiomatischen Aussagen hinzu, die die Redukte der folgenden Prä-Aussagen sind: 
\begin{list}{}{\itemsep 0.0pt}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{class\ }x\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{class\ }\{x|\varphi\}\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }A=B\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{wff\ }A\in B\rangle\rangle$
      \item[Ab] $\langle\varnothing,T,\varnothing,
               \langle \vdash ( y \in \{ x |\varphi\} \leftrightarrow
                  ( ( x = y \to\varphi) \wedge \exists x ( x = y
                  \wedge\varphi) ))
               \rangle\rangle$
      \item[Eq] $\langle\{\{x,A\},\{x,B\}\},T,\varnothing,
               \langle \vdash ( A = B \leftrightarrow
               \forall x ( x \in A \leftrightarrow x \in B ) )
               \rangle\rangle$
      \item[El] $\langle\{\{x,A\},\{x,B\}\},T,\varnothing,
               \langle \vdash ( A \in B \leftrightarrow \exists x
               ( x = A \wedge x \in B ) )
               \rangle\rangle$
\end{list}
Hier sagen wir, dass eine individuelle Variable eine Klasse ist; $\{x|\varphi\}$ ist eine Klasse; und wir erweitern die Definition einer wff, um Klassengleichheit und -zugehörigkeit einzuschließen.  Axiom Ab definiert die Zugehörigkeit einer Variablen zu einer Klassenabstraktion; die rechte Seite kann gelesen werden als "`die wff, die sich aus der echten Substitution von $y$ für $x$ in $\varphi$ ergibt."'\footnote{Anmerkung: Diese Definition macht die Einführung einer separaten Notation ähnlich $\varphi(x|y)$ für die echte Substitution überflüssig, obwohl wir dies aus Gründen der Konvention tun könnten.  Übrigens wäre $\varphi(x|y)$ in seiner jetzigen Form in den formalen Systemen unserer Beispiele mehrdeutig, da wir nicht wissen würden, ob $\lnot(\varphi(x|y)$ entweder $\lnot(\varphi(x|y))$ oder $(\lnot\varphi)(x|y)$ bedeutet. Stattdessen müssten wir eine eindeutige Variante wie $(\varphi\, x|y)$ verwenden.}  Die Axiome Eq und El erweitern die Bedeutung des bestehenden Gleichheitszeichens und des Elementprädikats.  Dies ist potenziell gefährlich und muss sorgfältig begründet werden.  Zum Beispiel können wir aus Eq das Extensionalitätsaxiom allein mit Prädikatenlogik ableiten; daher sollten wir das Extensionalitätsaxiom im Prinzip als logische Hypothese aufnehmen.  Wir machen uns jedoch nicht die Mühe, dies zu tun, da wir dieses Axiom bereits vorher vorausgesetzt haben. Die disjunkte Variableneinschränkungen sollten verstanden werden als: "`wobei $x$ nicht in $A$ oder $B$ vorkommt."'  Wir tun dies typischerweise, wenn die rechte Seite einer Definition eine individuelle Variable beinhaltet, die nicht in dem zu definierenden Ausdruck vorkommt; dies geschieht, damit die rechte Seite unabhängig von der speziellen "`Dummy'-Variable bleibt, die wir verwenden. 

Wir fügen $\Gamma$ weiterhin die folgenden Definitionen (d.h. die Reduktionen der folgenden Prä-Aussagen) für die leere Menge,\index{leere Menge}, die Klassenvereinigung,\index{Vereinigung} und das ungeordnete Paar\index{ungeordnetes Paar} hinzu.  Sie sollten selbsterklärend sein.  Analog zu unserer Verwendung von "`$\leftrightarrow$"' zur Definition neuer wffs in Beispiel~4, verwenden wir "`$=$"' zur Definition neuer Abstraktionsbegriffe, und beide können in diesem Zusammenhang informell als "`ist definiert als"' gelesen werden. 
\begin{list}{}{\itemsep 0.0pt}
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{class\ }\varnothing\rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \vdash \varnothing = \{ x | \lnot x = x \}
               \rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{class\ }(A\cup B)\rangle\rangle$
      \item[] $\langle\{\{x,A\},\{x,B\}\},T,\varnothing,
               \langle \vdash ( A \cup B ) = \{ x | ( x \in A \vee x \in B ) \}
               \rangle\rangle$
      \item[] $\langle\varnothing,T,\varnothing,
               \langle \mbox{class\ }\{A,B\}\rangle\rangle$
      \item[] $\langle\{\{x,A\},\{x,B\}\},T,\varnothing,
               \langle \vdash \{ A , B \} = \{ x | ( x = A \vee x = B ) \}
               \rangle\rangle$
\end{list}

\section{Metamath als formales System}\label{theorymm}

Dieser Abschnitt setzt die Kenntnis der Computersprache Metamath voraus.

Unsere Theorie beschreibt formale Systeme und ihre Universen.  Die Metamath-Sprache bietet eine Möglichkeit, diese mengentheoretischen Objekte auf einem Computer darzustellen.  Eine Metamath-Datenbasis, die aus einer endlichen Menge von {\sc ascii}-Zeichen besteht, kann in der Regel nur eine Teilmenge eines formalen Systems und seines Universums, die normalerweise unendlich sind, beschreiben.  Allerdings kann die Datenbasis eine beliebig große endliche Teilmenge des formalen Systems und seines Universums enthalten.  (Natürlich kann eine Metamath-Mengenlehre-Datenbasis im Prinzip indirekt ein ganzes unendliches formales System beschreiben, indem sie die Beschreibungssprache in diesem Anhang formalisiert). 

Für unsere Diskussion gehen wir davon aus, dass die Metamath-Datenbasis die auf S.~\pageref{framelist} beschriebene einfache Form hat, die aus allen Konstanten- und Variablendeklarationen am Anfang besteht, gefolgt von einer Folge erweiterter Frames, die jeweils durch \texttt{\$\char`\{} und \texttt{\$\char`\}} begrenzt sind.  Jede Metamath-Datenbasis kann in diese Form konvertiert werden, wie auf S.~\pageref{frameconvert} beschrieben. 

Die mathematischen Symbol-Token einer Metamath-Quelldatei, die mit den Anweisungen \texttt{\$c} und \texttt{\$v} deklariert werden, sind Namen, die wir den Repräsentanten von $\mbox{\em CN}$ und $\mbox{\em VR}$ zuweisen.  Der Eindeutigkeit halber könnten wir annehmen, dass das erste mathematische Symbol, das als Variable deklariert wird, $v_0$ entspricht, das zweite $v_1$ usw., obwohl die gewählte Zuordnung nicht von bedeutung ist. 

In der Metamath-Sprache entspricht jede \texttt{\$d}-, \texttt{\$f}- und \texttt{\$e}-Quellanweisung in einem erweiterten Rahmen (Abschnitt~\ref{frames}) jeweils einem Element der Sammlungen $D$, $T$ und $H$ in einer Aussage  $\langle D_M,T_M,H,A\rangle$ des formalen Systems.  Die auf diese Metamath-Schlüsselwörter folgenden Zeichenketten mit mathematischen Symbolen entsprechen einem Variablenpaar (im Fall von \texttt{\$d}) oder einem Ausdruck (für die beiden anderen Schlüsselwörter). Die mathematische Symbolkette nach einer \texttt{\$a}-Quellanweisung entspricht dem Ausdruck $A$ in einer axiomatischen Aussage des formalen Systems; die nach einer \texttt{\$p}-Quellanweisung entspricht $A$ in einer beweisbaren Aussage, die nicht axiomatisch ist.  Mit anderen Worten: Jeder erweiterte Rahmen in einer Metamath-Datenbasis entspricht einer Prä-Aussage des formalen Systems, und ein Rahmen entspricht einer Aussage des formalen Systems\footnote{Anm. der Übersetzer: Im englischen Originaltext folgt hier ein Hinweis auf die doppelte Bedeutung des Wortes "`statement"', was wir durch die unterschiedliche Übersetzung ("`Aussage"' im formalen System, "`Anweisung"' in der Metamath-Datenbasis) vermieden haben.}.  

Damit der Computer überprüfen kann, ob eine Aussage des formalen Systems beweisbar ist, wird jede entsprechende Anweisung von einem Beweis begleitet. Der Beweis hat jedoch keine Entsprechung im formalen System, sondern ist lediglich eine Möglichkeit, dem Computer die für seine Verifikation benötigten Informationen mitzuteilen.  Der Beweis sagt dem Computer, {\em wie} er bestimmte Glieder des Abschlusses der Prä-Aussage des formalen Systems konstruieren soll, die dem erweiterten Rahmen der \texttt{\$p}-Anweisung entspricht.  Das Endergebnis der Konstruktion ist das Element des Abschlusses, das mit der Anweisung \texttt{\$p} übereinstimmt.  Das abstrakte formale System hingegen befasst sich nur mit der {\em Existenz} von Elementen des Abschlusses. 

Wie auf S.~\pageref{exampleref} erwähnt, entsprechen die Beispiele 1 und 3--6 im vorigen Abschnitt der Entwicklung der Logik und Mengenlehre in der Metamath-Datenbasis \texttt{set.mm}.\index{Mengenlehre-Datenbasis (\texttt{set.mm})} Es ist sicherlich aufschlussreich, sie zu vergleichen. 


\chapter{Das MIU-System}
\label{MIU}
\index{formales System}
\index{MIU-System}

Es folgt eine (übersetzte\footnote{Anm. der Übersetzer: Übersetzung angelehnt an die deutschen Übersetzung von \textit{Gödel, Escher, Bach: ein Endloses Geflochtenes Band} (Klett-Cotta, Stuttgart, 1986), S. 37ff.}) Auflistung der Datei \texttt{miu.mm}.  Sie ist selbsterklärend.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbatim}
$( Das MIU-System: Ein einfaches formales System $)

$( Hinweis: Dieses formale System ist insofern ungewöhnlich,
als es leere wffs zulässt.  Um mit einem Beweis zu arbeiten,
müssen Sie SET EMPTY_SUBSTITUTION ON eingeben, bevor Sie den
Befehl PROVE verwenden. Standardwert ist OFF, um die Anzahl
der mehrdeutigen Vereinheitlichungsmöglichkeiten zu reduzieren,
die während der Konstruktion eines Beweises bereitgestellt
werden müssen.  $) 

$( Hofstadters MIU-System ist ein einfaches Beispiel für ein
formales System, das einige Konzepte von Metamath illustriert.
Siehe Douglas R. Hofstadter, _Goedel, Escher, Bach: An Eternal
Golden Braid_ (Vintage Books, New York, 1979), S. 33ff. für
eine Beschreibung des MIU-Systems.

Das System hat 3 konstante Symbole, M, I, und U. Das einzige
Axiom des Systems ist MI. Es gibt 4 Regeln:
      Regel I:  Wenn Sie eine Zeichenkette besitzen, deren
      letzter Buchstabe I ist, können Sie am Schluß ein U
      zufügen.
      Regel II: Angenommen Sie haben Mx.  Dann können Sie
      Ihrer Sammlung Mxx zufügen.
      Regel III: Wenn in einer der Zeichenketten Ihrer
      Sammlung III vorkommt, können Sie eine neue Kette mit
      U anstelle von III bilden.
      Regel IV: Wenn UU in einer Ihrer Ketten vorkommt,
      kann man es streichen.
Leider haben die Regeln III und IV keine eindeutigen
Ergebnisse: (Zeichen-)Ketten können mehr als ein Vorkommen
von III oder UU haben. Daher müssen wir das Konzept der
"wohlgeformten MIU-Formel" oder wff einführen, das es uns
ermöglicht, eindeutige Symbolfolgen zu konstruieren, auf
die die Regeln III und IV angewendet werden können. $)

$( Zuerst deklarieren wir die konstanten Symbole der Sprache.
Man beachte, dass wir zwei Symbole brauchen, um die Behauptung,
dass eine Folge eine wff ist, von der Behauptung, dass sie ein
Theorem ist, zu unterscheiden; wir haben willkürlich "wff" und
"|-" gewählt. $)
 $c M I U |- wff $. $( Konstanten deklarieren $) 

$( Als nächstes deklarieren wir einige Variablen. $)
 $v x y $. 

$( In unserer gesamten Theorie gehen wir davon aus, dass diese
Variablen wffs darstellen. $) 
 wx   $f wff x $.
 wy   $f wff y $.

$( Definition von MIU-wffs. Wir erlauben, dass die leere Folge
eine wff ist. $) 

$( Die leere Folge ist eine wff. $)
 we $a wff $.
$( "M" nach einer beliebigen wff ist eine wff. $)
 wM $a wff x M $.
$( "I" nach einer beliebigen wff ist eine wff. $)
 wI $a wff x I $.
$( "U" nach einer beliebigen wff ist eine wff. $)
 wU $a wff x U $.

$( Festlegung des Axioms. $)
 ax   $a |- M I $.

$( Festlegung der Regeln. $)
 ${
   Ia   $e |- x I $.
$( Ein beliebiger Satz, der mit "I" endet, bleibt auch dann ein
Satz, wenn ein "U" angehängt wird.  (Wir unterscheiden das Label
I_ vom mathematischen Symbol I, um der Metamath-Spezifikation
vom 24. Juni 2006 zu entsprechen.) $) 
   I_    $a |- x I U $.
 $}
 ${
IIa  $e |- M x $.
$( Jeder Satz, der mit "M" beginnt, bleibt ein Satz, wenn der
Teil nach dem "M" nochmals hinzugefügt wird. $) 
   II   $a |- M x x $.
 $}
 ${
   IIIa $e |- x I I I y $.
$( Jeder Satz mit "III" in der Mitte bleibt ein Satz, wenn das
 "III" durch "U" ersetzt wird. $) 
   III  $a |- x U y $.
 $}
 ${
   IVa  $e |- x U U y $.
$( Ein beliebiger Satz mit "UU" in der Mitte bleibt ein Satz,
wenn das "UU" gelöscht wird. $) 
   IV   $a |- x y $.
  $}

$( Nun beweisen wir das Theorem MUIIU.  Vielleicht ist es
für Sie interessant, diesen Beweis mit dem von Hofstadter
(S. 35 - 36 bzw. S. 40 in der deutschen Ausgabe) zu
vergleichen. $) 
 theorem1  $p |- M U I I U $=
      we wM wU wI we wI wU we wU wI wU we wM we wI wU we wM
      wI wI wI we wI wI we wI ax II II I_ III II IV $.
\end{verbatim}\index{wohlgeformte Formel (wff)}

Der Befehl \texttt{show proof /lemmon/renumber} erzeugt die folgende Anzeige.  Sie ist derjenigen in \cite[S.~35--36]{Hofstadter}\index{Hofstadter, Douglas R.}\footnote{Anm. der Übersetzer: S. 40 in der deutschen Ausgabe} sehr ähnlich. 

\begin{verbatim}
1 ax             $a |- M I
2 1 II           $a |- M I I
3 2 II           $a |- M I I I I
4 3 I_           $a |- M I I I I U
5 4 III          $a |- M U I U
6 5 II           $a |- M U I U U I U
7 6 IV           $a |- M U I I U
\end{verbatim}

Wir stellen fest, dass Hofstadters "`MU-Rätsel"', indem es um die Frage geht, ob MU ein Satz des MIU-Systems ist, nicht mit dem obigen System beantwortet werden kann, weil das MU-Rätsel eine Frage {\em über} das System ist.  Um die Antwort auf das MU-Rätsel zu beweisen, ist ein viel ausgefeilteres System erforderlich, nämlich eines, das das MIU-System innerhalb der Mengenlehre modelliert.  (Die Antwort auf das MU-Rätsel ist übrigens nein.) 


\chapter{Metamath-Sprache EBNF}%
\label{BNF}%
\index{Metamath-Sprache EBNF}

Dieser Anhang enthält eine formale Beschreibung der grundlegenden Syntax der Metamath-Sprache (mit komprimierten Beweisen und Unterstützung für unbekannte Beweisschritte). Sie ist definiert unter Verwendung der Erweiterten Backus--Naur-Form (EBNF)\index{erweiterte Backus--Naur-Form}\index{EBNF}, eine Notation, so wie sie in W3C\index{W3C} \textit{Extensible Markup Language (XML) 1.0 (Fifth Edition)} (W3C Recommendation 26 November 2008) unter \url{https://www.w3.org/TR/xml/#sec-notation} beschrieben und verwendet wird. 

Die Regel \texttt{database} wird bis zum Ende der Datei (\texttt{EOF}) verarbeitet. Die Regeln erfordern schließlich das Lesen von Token, die durch ein Whitespace getrennt sind. Ein Token hat eine Großbuchstaben-Definition (siehe unten) oder ist eine String-Konstante in einem Nicht-Token (wie \texttt{'\$a'}). Wir hoffen, dass dies korrekt ist, aber wenn es einen Konflikt gibt, gelten die Regeln des Abschnitts \ref{spec}. In diesem Abschnitt werden auch nicht-syntaktische Einschränkungen erörtert, die hier nicht gezeigt werden (z. B. dass jedes neue Label-Token, das in einem \texttt{hypothesis-stmt} oder \texttt{assert-stmt} definiert wird, eindeutig sein muss). 

\begin{verbatim}
database ::= outermost-scope-stmt*

outermost-scope-stmt ::=
  include-stmt | constant-stmt | stmt

/* Anweisung zum Einbinden von Dateien; behandelt eine Datei als
   (einen Teil einer) Datenbasis. Innerhalb des Dateinamens darf
   sich KEIN Kommentar befinden. */
include-stmt ::= '$[' filename '$]'

/* Deklaration von Symbolen für Konstanten. */
constant-stmt ::= '$c' constant+ '$.'

/* Eine normale Anweisung kann sich in jedem Scope befinden. */
stmt ::= block | variable-stmt | disjoint-stmt |
  hypothesis-stmt | assert-stmt

/* Ein Block, der auch leer sein kann. */
block ::= '${' stmt* '$}'

/* Deklaration von Symbolen für Variablen. */
variable-stmt ::= '$v' variable+ '$.'

/* Disjunkte Variablen. Einfache disjunkte Variableneinschränkung
   bestehen aus 2 Variables, d.h. "variable*" ist in diesem Fall 
   leer. */
disjoint-stmt ::= '$d' variable variable variable* '$.'

hypothesis-stmt ::= floating-stmt | essential-stmt

/* Fließende (Variablentyp-)Hypothese. */
floating-stmt ::= LABEL '$f' typecode variable '$.'

/* Essenzielle (logische) Hypothese. */
essential-stmt ::= LABEL '$e' typecode MATH-SYMBOL* '$.'

assert-stmt ::= axiom-stmt | provable-stmt

/* Axiomatische Behauptung. */
axiom-stmt ::= LABEL '$a' typecode MATH-SYMBOL* '$.'

/* Beweisbare Behauptung. */
provable-stmt ::= LABEL '$p' typecode MATH-SYMBOL*
  '$=' proof '$.'

/* Ein Beweis. Innerhalb von Beweisen können sich auch
   Kommentare befinden. Wenn ein '?' in dem Beweis 
   enthalten ist, dann handelt es sich um einen
   "unvollständigen" Beweis. */
proof ::= uncompressed-proof | compressed-proof
uncompressed-proof ::= (LABEL | '?')+
compressed-proof ::= '(' LABEL* ')' COMPRESSED-PROOF-BLOCK+

typecode ::= constant

filename ::= MATH-SYMBOL /* enthält kein Whitespace oder '$' */
constant ::= MATH-SYMBOL
variable ::= MATH-SYMBOL
\end{verbatim}

\needspace{2\baselineskip}
Ein \texttt{frame} ist eine Folge von keinem, einem oder mehreren \texttt{disjoint-{\allowbreak}stmt}- und \texttt{hypothe\-ses-{\allowbreak}stmt}-Anweisungen (möglicherweise verschachtelt mit anderen Anweisungen, die keine \texttt{assert-stmt}-Anweisungen sind), gefolgt von einem \texttt{assert-stmt}.

\needspace{3\baselineskip}
Hier sind die Regeln für die lexikalische Verarbeitung (Tokenisierung) über die oben gezeigten konstanten Token hinaus. Konventionell werden diese Tokenisierungsregeln in Großbuchstaben geschrieben. Jedes Token wird so lang wie möglich gelesen. Durch ein Whitespace getrennte Token werden nacheinander gelesen; beachten Sie, dass der trennende Whitespace und die Kommentare \texttt{\$(} ... \texttt{\$)} übersprungen werden. 

Wenn eine Token-Definition eine andere Token-Definition verwendet, wird das Ganze als ein einziges Token betrachtet. Ein Muster, das nur Teil eines vollständigen Tokens ist, hat einen Namen, der mit einem Unterstrich ("`\_"') beginnt. Eine Implementierung könnte viele Token als \texttt{PRINTABLE-SEQUENCE} tokenisieren und dann prüfen, ob sie die hier dargestellte spezifischere Regel erfüllen. 

Kommentare lassen sich nicht verschachteln, und sowohl \texttt{\$(} als auch \texttt{\$)} müssen von mindestens einem Whitespace-Zeichen (\texttt{\_WHITECHAR}) umgeben sein. Technisch gesehen enden Kommentare vor dem abschließenden \texttt{\_WHITECHAR}, aber das abschließende \texttt{\_WHITECHAR} wird sowieso ignoriert, so dass wir dieses Detail hier ignorieren. Metamath-Sprachprozessoren müssen kein \texttt{\$)} unterstützen, das unmittelbar vor dem Dateiende steht, da auf das abschließende Kommentarsymbol ein \texttt{\_WHITECHAR}, wie ein Zeilenumbruch, folgen muss. 

\begin{verbatim}
PRINTABLE-SEQUENCE ::= _PRINTABLE-CHARACTER+

MATH-SYMBOL ::= (_PRINTABLE-CHARACTER - '$')+

/* druckbare ASCII-Zeichen ohne Whitespace-Zeichen */
_PRINTABLE-CHARACTER ::= [#x21-#x7e]

LABEL ::= ( _LETTER-OR-DIGIT | '.' | '-' | '_' )+

_LETTER-OR-DIGIT ::= [A-Za-z0-9]

COMPRESSED-PROOF-BLOCK ::= ([A-Z] | '?')+

/* Definition von Whitespace zwischen Token. Das -> SKIP
   bedeutet, dass ein auftretendes Whitespace übersprungen
   und mit dem Lesen weiterer Zeichen fortgefahren wird. */
WHITESPACE ::= (_WHITECHAR+ | _COMMENT) -> SKIP

/* Kommentare. $( ... $), die nicht verschachtelt sind. */
_COMMENT ::= '$(' (_WHITECHAR+ (PRINTABLE-SEQUENCE - '$)'))*
  _WHITECHAR+ '$)' _WHITECHAR

/* Whitespace: (' ' | '\t' | '\r' | '\n' | '\f') */
_WHITECHAR ::= [#x20#x09#x0d#x0a#x0c]
\end{verbatim}
% This EBNF was developed as a collaboration between
% David A. Wheeler\index{Wheeler, David A.},
% Mario Carneiro\index{Carneiro, Mario}, and
% Benoit Jubin\index{Jubin, Benoit}, inspired by a request
% (and a lot of initial work) by Benoit Jubin.
%

\chapter{Metamath 100}%
\label{Metamath100}%

Die folgende Tabelle enthält alle Theoreme der Liste 
"`Formalisierung von 100 Theoremen"' ("`Formalizing 100 Theorems"', siehe \url{http://www.cs.ru.nl/\%7Efreek/100/}) von Freek Wiedijk, die bereits mit Metamath bewiesen wurden (Stand 12.11.2023). Die Nr. entspricht der Nummer in der Liste von Freek Wiedijk, die Bezeichnung wurde ins Deutsche übersetzt\footnote{Anm. der Übersetzer: Dieser Anhang ist im Original nicht vorhanden}

\begin{longtabu}   to \textwidth {
	X[1,c]
	X[10,l]
	X[5,l]
	X[5,l]
	X[5,l]}
\textbf{Nr.} & \textbf{Bezeichnung des Theorems} & \textbf{Label in set.mm} & \textbf{Autor} & \textbf{Datum}\\
& & & & \\
\endhead
1.  & Die Quadratwurzel aus 2 ist irrational        & sqrt2irr     & Norman Megill     & 2001-08-20 \\
2.  & Der Fundamentalsatz der Algebra               & fta          & Mario Carneiro    & 2014-09-15 \\
3.  & Die Abzählbarkeit der rationalen Zahlen       & qnnen        & Norman Megill     & 2004-07-31 \\
4.  & Der Satz von Pythagoras                       & pythi        & Norman Megill     & 2008-04-17 \\
5.  & Der Primzahlensatz                            & pnt          & Mario Carneiro    & 2016-06-01 \\
7.  & Das quadratische Reziprozitätsgesetz          & lgsquad      & Mario Carneiro    & 2015-06-19 \\
9.  & Die Kreisfläche                               & areacirc     & Brendan Leahy     & 2017-08-31 \\
10. & Der Satz von Euler (Verallgemeinerung  
      des kleinen Fermatschen Satzes)               & eulerth      & Mario Carneiro    & 2014-02-28 \\
11. & Der Satz von Euklid
      (Existenz unendlich vieler Primzahlen)        & infpn2       & Norman Megill     & 2005-05-05 \\
14. & Das Baseler Problem 
      (Summe der reziproken Quadratzahlen)          & basel        & Mario Carneiro    & 2014-07-30 \\
15. & Der Fundamentalsatz der Analysis              & ftc1, ftc2   & Mario Carneiro    & 2014-09-03 \\
17. & Der Moivresche Satz                           & demoivreALT  & Steve Rodriguez   & 2006-11-10 \\
18. & Der Approximationssatz von Liouville          & aaliou       & Stefan O'Rear     & 2014-11-22 \\
19. & Der Vier-Quadrate-Satz von Lagrange           & 4sq          & Mario Carneiro    & 2014-07-16 \\
20. & Der Zwei-Quadrate-Satz von Fermat             & 2sq          & Mario Carneiro    & 2015-06-20 \\
22. & Die Überabzählbarkeit des Kontinuums
      (der reelen Zahlen)                           & ruc          & Norman Megill     & 2004-08-13 \\
23. & Formel zur Bildung der pythagoreischen Tripel & pythagtrip   & Scott Fenton      & 2014-04-19 \\
25. & Der Cantor--Bernstein--Schrödersche
      Äquivalenzssatz                               & sbth         & Norman Megill     & 1998-06-08 \\
26. & Die Leibniz-Reihe für Pi                      & leibpi       & Mario Carneiro    & 2015-04-16 \\
27. & Der Innenwinkelsatz für Dreiecke              & ang180       & Mario Carneiro    & 2014-09-24 \\
30. & Bertrand's Ballot Problem                     & ballotth     & Thierry Arnoux    & 2016-12-07 \\
31. & Der Satz von Ramsey (Kombinatorik)            & ramsey       & Mario Carneiro    & 2015-04-23 \\
34. & Die Divergenz der harmonischen Reihe          & harmonic     & Mario Carneiro    & 2014-07-11 \\
35. & Der Satz von Taylor                           & taylth       & Mario Carneiro    & 2017-01-01 \\
37. & Die Lösungsformel für kubische Gleichungen    & cubic        & Mario Carneiro    & 2015-04-26 \\
38. & Die Ungleichung vom arithmetischen
      und geometrischen Mittel                      & amgm         & Mario Carneiro    & 2015-06-21 \\
39. & Lösungen der Pellschen Gleichung              & rmxycomplete & Stefan O'Rear     & 2014-11-22 \\
42. & Die Summe der Kehrwerte aller Dreieckszahlen  & trirecip     & Scott Fenton      & 2014-05-02 \\
44. & Der binomische Lehrsatz                       & binom        & Norman Megill     & 2005-12-07 \\
45. & Der Partitionssatz von Euler
      (als Spezialfall des Satzes von Glaisher)     & eulerpart    & Thierry Arnoux    & 2018-08-30 \\
46. & Die Lösungsformel für allgemeine quartische
      Gleichungen                                   & quart        & Mario Carneiro    & 2015-05-06 \\
48. & Der Dirichletsche Primzahlsatz                & dirith       & Mario Carneiro    & 2016-05-12 \\
49. & Der Satz von Cayley--Hamilton                  & cayleyhamilton & Alexander van der Vekens
                                                                                       & 2019-11-25 \\
51. & Der Satz von Wilson                           & wilth        & Mario Carneiro    & 2015-01-28 \\
52. & Die Anzahl der Teilmengen von Mengen          & pw2en        & Norman Megill     & 2004-01-29 \\
54. & Das Königsberger Brückenproblem               & konigsberg   & Mario Carneiro    & 2015-04-16 \\
55. & Der Sehnensatz                                & chordthm     & David Moews       & 2017-02-28 \\
57. & Der Satz von Heron                            & heron        & Mario Carneiro
                                                         (Jon Pennant, Thierry Arnoux) & 2019-03-10 \\
58. & Die Formel für die Anzahl von Kombinationen   & hashbc       & Mario Carneiro    & 2014-07-13 \\
60. & Das Lemma von Bézout                          & bezout       & Mario Carneiro    & 2014-02-22 \\
61. & Der Satz von Ceva                             & cevath       & Saveliy Skresanov & 2017-09-24 \\
63. & Der Satz von Cantor                           & canth2       & Norman Megill     & 1994-08-07 \\
64. & Die Regel von de L’Hospital                   & lhop         & Mario Carneiro    & 2016-12-30 \\
65. & Der Basiswinkelsatz in gleichschenkligen
      Dreiecken                                     & isosctr      & Saveliy Skresanov & 2017-01-01 \\
66. & Die (endlichen) Partialsummen einer
      geometrischen Reihe                           & geoser       & Norman Megill     & 2006-05-09 \\
67. & Die Eulersche Zahl e ist transzendent         & etransc      & Glauco Siliprandi & 2020-04-05 \\
68. & Die Gaußsche Summenformel                     & arisum       & Frédéric Liné     & 2006-11-16 \\
69. & Der Euklidische Algorithmus                   & eucalg       & Paul Chapman      & 2011-03-31 \\
70. & Der Euklid--Euler-Satz über vollkommene Zahlen & perfect      & Mario Carneiro    & 2016-05-17 \\
71. & Der Satz von Lagrange                         & lagsubg, lagsubg2 
                                                                   & Mario Carneiro    & 2014-07-11 \\ 
72. & Die Sylow-Sätze                               & sylow1, sylow2, sylow2b, sylow3
                                                                   & Mario Carneiro    & 2015-01-19 \\
73. & Der Satz von Erdős und Szekeres               & erdsze, erdsze2 & Mario Carneiro & 2015-01-28 \\
74. & Das Prinzip der vollständigen Induktion       & finds        & Norman Megill     & 1995-04-14 \\
75. & Der Mittelwertsatz der Differentialrechnung   & mvth         & Mario Carneiro    & 2014-09-14 \\
76. & Fourierreihen                                 & fourier      & Glauco Siliprandi & 2019-12-11 \\
77. & Die Faulhabersche Formel für Potenzsummen     & fsumkthpow   & Scott Fenton      & 2014-05-16 \\
78. & Die Cauchy--Schwarz-Ungleichung                & sii          & Norman Megill     & 2008-01-12 \\
79. & Der Zwischenwertsatz (der reellen Analysis)   & ivth         & Paul Chapman      & 2008-01-22 \\
80. & Der Fundamentalsatz der Arithmetik            & 1arith2      & Paul Chapman      & 2012-11-17 \\
81. & Erdős Beweis der Divergenz der Reihe der
      Kehrwerte der Primzahlen (Satz von Euler)     & prmrec       & Mario Carneiro    & 2014-08-10 \\
83. & Der Freundschaftssatz                         & friendship   & Alexander van der Vekens
                                                                                       & 2018-10-09 \\
85. & Quersummenregel für die Teilbarkeit durch 3   & 3dvds        & Mario Carneiro    & 2014-07-14 \\
86. & Lebesgue-Maß und -Integral                    & itgcl        & Mario Carneiro    & 2014-06-29 \\
87. & Der Satz von Desargues                        & dath         & Norman Megill     & 2012-08-20 \\
88. & Die Anzahl der fixpunktfreien Permutationen   & derangfmla, subfaclim 
                                                                   & Mario Carneiro    & 2015-01-28 \\
89. & Der Restpolynom-Satz                          & facth, plyrem & Mario Carneiro   & 2014-07-26 \\
90. & Die Stirling-Formel                           & stirling     & Glauco Siliprandi & 2017-06-29 \\
91. & Die Dreiecksungleichung                       & abstrii      & Norman Megill     & 1999-10-02 \\
93. & Das Geburtstagsproblem                        & birthday     & Mario Carneiro    & 2015-04-17 \\
94. & Der Kosinussatz                               & lawcos       & David A. Wheeler  & 2015-06-12 \\
95. & Der Satz des Ptolemäus                        & ptolemy      & David A. Wheeler  & 2015-05-31 \\
96. & Das Prinzip von Inklusion und Exklusion       & incexc       & Mario Carneiro    & 2017-08-07 \\
97. & Die Cramersche Regel                          & cramer       & Alexander van der Vekens
                                                                       (Stefan O'Rear) & 2019-02-21 \\
98. & Das Bertrandsche Postulat                     & bpos         & Mario Carneiro    & 2014-03-15 \\
\end{longtabu}
\pagebreak 

\chapter{Glossar}%
\section{Deutsch - Englisch}

\begin{longtabu}   { @{} X[l] X[l] }
\textbf{Deutsch} & \textbf{Englisch}\\
 & \\
\endhead
    Abschluss & closure \\
    abstrakte Algebra & abstract algebra \\
    Abstraktionsklasse & abstraction class \\
    Addition & addition \\
    aktive Anweisung & active statement \\
    aktives mathematisches Symbol & active math symbol \\
    Allquantor & universal quantifier \\
    Analysis & analysis \\
    Anweisung & statement   \\
    äußerster Block & outermost block \\
    Ausdruck & expression \\
    Aussage & statement \\
    Aussagenlogik & propositional calculus \\
    Aussonderungssaxiom & Axiom of Separation \\
    Auswahlaxiom & Axiom of Choice \\
    Auszeichnungsnotation & markup notation \\
    automatisches Theorembeweisen & automated theorem proving \\
    automatisierte Beweisverifizierung & automated proof verification \\
    Axiom & axiom \\
    axiomatische Aussagen & axiomatic statement \\
    axiomatische Behauptung & axiomatic assertion \\
    Axiome der Aussagenlogik & axioms of propositional calculus \\
    Axiome der Logik & axioms of logic \\
    Axiome der Mengenlehre & axioms of set theory \\
    Axiome der Prädikatenlogik & axioms of predicate calculus \\
    Axiome für die Gleichheit & axioms for equality  \\
    Axiome für die Mathematik & axioms for mathematics \\
    Axiomenschema & axiom scheme \\
    Axiom von Pasch & Pasch's axiom \\
     & \\
    Baumdarstellung eines Beweises & tree-style proof \\
    Befehlsschlüsselwort & command keyword \\
    Befehlszeilenparameter & command qualifier \\
    Befehlszeilenschnittstelle (CLI) & command line interface \\
    Behauptung & assertion \\
    Behauptungslabel & assertion label \\
    Betriebssystem-Befehl & operating system command \\
    Beweis & proof \\
    Beweis-Assistent & Proof Assistant \\
    beweisbare Aussage & provable statement \\
    beweisbare Behauptung & provable assertion \\
    Beweislänge & proof length \\
    Beweisschema & proof scheme \\
    Beweisschritt & proof step \\
    Beweistheorie & proof theory \\
    bijektive Funktion & one-to-one, onto function \\
    Bikonditional & biconditional \\
    Bild & image \\
    binäre Relation & binary relation \\
    Block & block \\
    Boolesche Algebra & Boolean algebra \\
    Bug & software bug \\
    Burali-{\allowbreak}Forti Paradoxon & Burali-{\allowbreak}Forti paradox \\
     & \\
    Clifford-{\allowbreak}Algebren & Clifford algebras \\
    Computeralgebrasystem & computer algebra system \\
    Courier Schriftart & Courier font \\
     & \\
    Dateieinbindung & file inclusion \\
    Dateiname & file name \\
    Datenbasis & database \\
    Deduktionsform & deduction form \\
    Deduktionsstil & deduction style \\
    Deduktionstheorem & deduction theorem \\
    Definiendum & definiendum \\
    Definiens & definiens \\
    Definition & definition \\
    Definitionsbereich & domain \\
    Deklaration & declaration \\
    disjunkte Mengen & disjoint sets \\
    disjunkte Variablen & disjoint variables \\
    disjunkte Variableneinschränkung & disjoint-{\allowbreak}variable restriction \\
    Disjunktion & disjunction \\
    Drehkreuz & turnstile \\
    druckbares Zeichen & printable character \\
    Drucker & printer \\
    Dummy-Variable & dummy variable \\
     & \\
    echte Klasse & proper class \\
    echte Substitution & proper substitution \\
    effektiv gebundene Variable & effectively bound variable \\
    effektiv nicht frei & effectively not free \\
    einelementige Menge & singleton \\
    Eindeutigkeitsquantor & existential uniqueness quantifier \\
    einfache Deklaration & simple declaration \\
    einfache unendliche Folge & simple infinite sequence \\
    einfacher Text & plain text \\
    einfaches Anführungszeichen & grave accent \\
    einfaches Metatheorem & simple metatheorem \\
    eingeschränkter Allquantor & restricted universal quantifier \\
    eingeschränkter Existenzquantor & restricted existential quantifier \\
    eingebundene Datei & included file \\
    Einschränkung & restriction \\
    Element & element \\
    endliche n-gliedrige Folge & finite n-termed sequence \\
    entfernen & pop \\
    entscheidbare Theorie & decidable theory \\
    Entscheidungsverfahren & decision procedure \\
    Epsilon-Relation & epsilon relation \\
    Ersetzung & substitution \\
    Ersetzungsaxiom & Axiom of Replacement \\
    erweiterte Backus--Naur-Form & Extended Backus--Naur Form \\
    erweiterte Sprache & extended language \\
    erweiterter Frame & extended frame \\
    essentielle Hypothese & essential hypothesis \\
    euklidische Geometrie & Euclidean geometry \\
    Existenzquantor & existential quantifier \\
    Extensionalitätsaxiom & Axiom of Extensionality \\
     & \\
    Familie & family \\
    Fehler in Beweisen & errors in proofs \\
    Fehlerprüfung & error checking \\
    finite Induktion & finite induction \\
    finitistischer Beweis & finitary proof \\
    fließende Hypothese & floating hypothesis \\
    formale Logik & formal logic \\
    formaler Beweis & formal proof \\
    formales System & formal system \\
    Formalismus & formalism \\
    Formen & forms \\
    Frame & frame \\
    freie Logik & free logic \\
    freie Variable & free variable \\
    fundierte Relation & founded relation \\
    Fundierungsaxiom & Axiom of Regularity \\
    Funktion & function \\
    Funktionswert & function value \\
     & \\
    ganze Zahl & integer \\
    gebundene Variable & bound variable \\
    genau dann, wenn & iff \\
    geordnetes Paar & ordered pair \\
    geschlossene Form & closed form \\
    Gleichheit & equality \\
    Glied & member \\
    globale Anweisung & global statement \\
    Gödelscher Unvollständigkeitssatz & Gödel's incompleteness theorem \\
    Grenzzahl & limit ordinal \\
    Großer Fermatscher Satz & Fermat's Last Therorem \\
    Grundlagen der Mathematik & foundations of mathematics \\
    grundlegende Sprache & basic language \\
    grundlegendes Schlüsselwort & basic keyword \\
    Gruppentheorie & group theory \\
    Gültigkeitsbereich & scope \\
    Gültigkeitsbereichsanweisung & scoping statement \\
     & \\
    Hierarchie & hierarchy \\
    Hilfsschlüsselwort & auxiliary keyword \\
    Hypothese & hypothesis \\
    Hypothesenlabel & hypothesis label \\
    Hypothesenzuordnung & hypothesis association \\
     & \\
    Implikation & implication \\
    implizites Axiom & implicit axiom \\
    implizite Substitution & implicit substitution \\
    individuelle Metavariable & individual metavariable \\
    individuelle Variable & individual variable \\
    Inferenz & inference \\
    Inferenzform & inference form \\
    Inferenzregel & inference rule \\
    Infix-Konnektor & inflix connective \\
    informeller Beweis & informal proof \\
    injektive Funktion & one-to-one function \\
    Intuitionismus & intuitionism \\
     & \\
    Junktor & connective \\
     & \\       
    Kardinalität & cardinality \\
    Kardinalzahl & cardinal \\
    Kartesisches Produkt & Cartesian product \\
    Kategorientheorie & category theory \\
    Klammerschreibweise & brace notation \\
    Klasse & class \\
    Klassenabstraktion & class abstraction \\
    Klassendifferenz & class difference \\
    Klassengleichheit & class equality \\
    Klassenvariable & class variable \\
    Klassenzugehörigkeit & class membership \\
    Kommentar & comment \\
    \hangindent=0.5cm Kommentar mit zusätzlichen Informationen\vspace{3pt} & additional information comment \\
    kompakter Beweis & compact proof \\
    komplexe Zahl & complex number \\
    Komposition & composition \\
    komprimierter Beweis & compressed proof \\
    kondensierte Ablösung & condensed detachment \\
    Konjunktion & conjunction \\
    Konstante & constant \\
    Konstantendeklaration & constant declaration \\
    Konstante-Variable-Paar & constant-variable pair \\
    konstant-gepräfixter Ausdruck & constant-prefixed expression \\
    konstruktive Sprache & constructive language \\
    Konstruktivismus & constructivism \\
    kontinuierliche Integration & continuous integration \\
    Kontinuumshypothese & continuum hypothesis \\
    kreative Definintion & creative definition \\
    Kreuzprodukt & cross product \\
    künstliche Intelligenz & artificial intelligence \\
     & \\
    Label & label \\
    Label-Deklaration & label declaration \\
    Label-Modus & label mode \\
    Label-Referenz & label reference \\
    Label-Sequenz & label sequence \\
    leere Menge & empty set, null set \\
    leerer Definitionsbereich & empty domain \\
    leere Substitution & empty substitution \\
    Leermengenaxiom & Axiom of the Null Set \\
    Leerraum & white space \\
    Lemmon-Stil Beweis & Lemmon-style proof \\
    Logik & logic \\
    Logik erster Ordnung & first-order logic (FOL) \\
    Logik höherer Ordnung & higher-order logic (HOL) \\
    logische Äquivalenz & logical equivalenz \\
    logische Hypothese & logical hypothesis \\
    logisches ODER & logical OR \\
    logisches UND & logical AND \\
    lokale Variable & local variable \\
    lokales Label & local label \\
    Lücken in Beweisen & gaps in proofs \\
     & \\
    Macintosh-Dateiname & Macintosh file name \\
    maschinelles Lernen & machine learning \\
    mathematisches Symbol & math symbol \\
    Mathe-Modus & math mode \\
    mehrdeutige Vereinheitlichung & ambiguous unification \\
    Menge & set \\
    Mengendifferenz & set difference \\
    Mengenlehre & set theory \\
    Metalogik & metalogic \\
    metalogische Vollständigkeit & metalogical completeness \\
    Metamath & Metamath \\
    Metamath Proof Explorer & Metamath Proof Explorer \\
    Metamathematik & metamathematics \\
    Metamath-Sprache EBNF & Metamath Language EBNF \\
    Metasprache & metalanguage \\
    Metatheorem & metatheorem \\
    Metavariable & metavariable \\
    Mitglied & member \\
    MIU-System & MIU-system \\
    modale Logik & modal logic \\
    Modelltheorie & model theory \\
    Modus ponens & modus ponens \\
    Monaco Schriftart & Monaco font \\
     & \\
    Nachfolger & successor \\
    natürliche Deduktion & natural deduction \\
    natürliche Zahl & natural number \\
    Negation & negation \\
    nichtproportionale Schriftart & monospaced font \\
    nicht-triviale Theorie & non-trivial theory \\
    normaler Beweis & normal proof \\
     & \\
    Objekt & object \\
    Objektsprache & object language \\
    obligatorische \texttt{\$d}-Anweisung & mandatory \texttt{\$d} statement \\
    \hangindent=0.5cm obligatorische disjunkte Variableneinschränkung & \hangindent=0.5cm mandatory distinct-/disjoint-{\allowbreak}variable restriction \\
    obligatorische Hypothese & mandatory hypothesis \\
    obligatorische Variable & mandatory variable \\
    \hangindent=0.5cm obligatorische Variablentyp-{\allowbreak}Hypothese\vspace{2pt} & mandatory variable-{\allowbreak}type hypothesis \\
    Omega & omega \\
    Operation & operation \\
    \hangindent=0.5cm optionale disjunkte Variableneinschränkung\vspace{2pt} & optional disjoint-{\allowbreak}variable restriction \\
    optionale Hypothese & optional hypothesis \\
    optionale Variable & optional variable \\
    ordinale Addition & ordinal addition \\
    Ordinalprädikat & ordinal predicate \\
    Ordinalzahl & ordinal number \\
     & \\
    Paar & pair \\
    Paarmengenaxiom & Axiom of Pairing \\
    Parser & parser \\
    Peano-Postulate & Peano's postulates \\
    Pierces Axiom & Pierce's axiom \\
    Poincaré-Vermutung & Poincaré conjecture \\
    polnische Notation & Polish notation \\
    Postfix-Konnektor & postfix connective \\
    Potenzklasse & power class \\
    Potenzmenge & power set \\
    Potenzmengenaxiom & Axiom of Power Sets  \\
    Prä-Aussage & pre-statement \\
    Prädikatenlogik & predicate calculus \\
    Präfix-Konnektor & prefix connective \\
    Principia Mathematica & Principia Mathematica \\
    Programmfehler & software bug \\
     & \\
    qualifizierender Ausdruck & qualifying expression \\
    Quantenlogik & quantum logic \\
    Quantenmechanik & quantum mechanics \\
    Quantifizierungstheorie & quantifier theory \\
    Quelldatei & source file \\
    Quellpuffer & source buffer \\
    Querverweis zu Literaturangaben & bibliographical references \\
     & \\
    rationale Zahl & rational number \\
    Redukt & reduct \\
    reelle Zahl & real number \\
    Reflexionsprinzip & reflection principle \\
    Regel & rule \\
    Regel der Verallgemeinerung & rule of generalization \\
    reine Mathematik & pure mathematics \\
    Rekursionsoperator & recursion operator \\
    rekursive Definition & recursive definition \\
    Relation & relation \\
    Robbins-Algebra & Robbins algebra \\
    Robinsons Resolutionsprinzip & Robinson's resolution principle \\
    RPN-Reihenfolge & RPN order \\
    RPN-Stapel & RPN stack \\
    Russells Paradoxon & Russell's paradox \\
     & \\
    Sammlung & collection \\
    Satz von Cantor & Cantor's theorem \\
    Satzlogik & sentential logic \\
    schieben & push \\
    Schlüsselwort & keyword \\
    Schlussfolgerung  & conclusion \\
    Schnittmenge & intersection \\
    Schriftsatzanweisung & typesetting comment \\
    Schröder--Bernstein-Theorem & Schröder--Bernstein theorem \\
    schwache Logik & weak logic \\
    Sonderzeichen & special characters \\
    Spinner & crank \\
    Standard-{\allowbreak}Deduktionstheorem & Standard Deduction Theorem \\
    Stapel & stack \\
    stilisiertes Epsilon & stylized epsilon \\
    Substitution & substitution \\
    Substitutionsabbildung & substitution map \\
    Substitutionstheorem & substitution theorem \\
    surjektive Funktion & onto function \\
    Syllogismus & Syllogism \\
    Symbol & symbol \\
    Syntax-Regeln & syntax rules \\
     & \\
    Tautologie & tautology \\
    Teilmenge & subset \\
    temporäre Variable & temporary variable \\
    Term & term \\
    Texteditor & text editor \\
    Textverarbeitung & word processing \\
    Theorem & theorem \\
    Theorem der schwachen Deduktion & Weak Deduction Theorem \\
    Theoremschema & theorem scheme \\
    Tilde & tilde \\
    Token & token \\
    Topologie & topology \\
    transfinite Kardinalzahl & transfinite cardinal \\
    transfinite Rekursion & transfinite recoursion \\
    transitive Klasse & transitive class \\
    transitive Menge & transitive set \\
    Typ & type \\
    Typcode & typecode \\
     & \\
    Umdeklarierung von Symbolen & redeclaration of symbols \\
    umgekehrte polnische Notation & reverse polish notation (RPN) \\
    unendliche Menge & infinite set \\
    Unendlichkeit & infinity \\
    Unendlichkeitsaxiom & Axiom of Infinity  \\
    ungeordnetes Paar & unordered pair \\
    ungeordnetes Tripel & unordered tripel \\
    universelle Klasse & universal class \\
    Universum eines formalen Systems & universe of a formal system \\
    Unix-Dateiname & Unix file name \\
    Unterklasse & subclass \\
    unterschiedliche Variablen & distinct variables \\
    unzugängliche Kardinalzahl & inaccessible cardinal \\
     & \\
    Variable & variable \\
    Variablendeklaration & variable declaration \\
    Variablensubstitution & variable substitution \\
    Variablentyp & variable type \\
    Variablentyp-Hypothese & variable-type hypothesis \\
    Venn-Diagramm & Venn diagram \\
    Vereinheitlichung & unification \\
    Vereinigung & union \\
    Vereinigungsaxiom & Axiom of Union \\
    Vereinigungsmenge & set union \\
    Verkettung & concatenation \\
    verschachtelter Block & nested block \\
    Verschachtelungstiefe & nesting level \\
    verschiedene Variablen & distinct variables \\
    Vier-Farben-Satz & four-color theorem \\
    vollständige Induktion & mathematical induction \\
    \hangindent=0.5cm Vollständigkeitssatz der Aussagenlogik\vspace{2pt} & completeness theorem of propositional calculus \\
    Vorrangigkeit eines Operators & operator precedence \\
     & \\
    Wahrheitstabelle & truth table \\
    Wertebereich & range \\
    Whitespace & white space \\
    widerspruchsfreie Theorie & consistent theory \\
    wohlgeformte Formel (wff) & well-formed formula \\
    Wohlordnung & well-ordering \\
     & \\
    Zahlentheorie & number theory \\
    Zermelo--Fraenkel-{\allowbreak}Mengenlehre & Zermelo--Fraenkel set theory \\
    ZFC-Mengenlehre & ZFC set theory \\
    Zitat & citation \\
    zulässige Definition & proper definition \\
    Zuordnung & mapping \\
    zusammengesetzte Deklaration & compound declaration \\ 
  \end{longtabu}
  \pagebreak


\section{Englisch - Deutsch}

\begin{longtabu}   { @{} X[l] X[l] }
\textbf{Englisch} & \textbf{Deutsch}\\
& \\
\endhead
    abstract algebra & abstrakte Algebra \\
    abstraction class & Abstraktionsklasse \\
    active math symbol & aktives mathematisches Symbol \\
    active statement & aktive Anweisung \\
    addition & Addition \\
    additional information comment & \hangindent=0.5cm Kommentar mit zusätzlichen Informationen\vspace{3pt} \\
    ambiguous unification & mehrdeutige Vereinheitlichung \\
    artificial intelligence & künstliche Intelligenz \\
    analysis & Analysis \\
    assertion & Behauptung \\
    assertion label & Behauptungslabel \\
    automated proof verification & automatisierte Beweisverifizierung \\
    automated theorem proving & automatisches Theorembeweisen \\
    auxiliary keyword & Hilfsschlüsselwort \\
    Axiom & axiom \\
    Axiom of Choice & Auswahlaxiom \\
    Axiom of Extensionality & Extensionalitätsaxiom \\
    Axiom of Infinity & Unendlichkeitsaxiom \\
    Axiom of Pairing & Paarmengenaxiom \\
    Axiom of Power Sets & Potenzmengenaxiom \\
    Axiom of Regularity & Fundierungsaxiom \\
    Axiom of Replacement & Ersetzungsaxiom \\
    Axiom of Separation & Aussonderungssaxiom \\
    Axiom of the Null Set & Leermengenaxiom \\
    Axiom of Union & Vereinigungsaxiom \\
    axiom scheme & Axiomenschema \\
    axiomatic assertion & axiomatische Behauptung \\
    axiomatic statement & axiomatische Aussagen \\
    axioms for equality & Axiome für die Gleichheit \\
    axioms for mathematics & Axiome für die Mathematik \\
    axioms of logic & Axiome der Logik \\
    axioms of predicate calculus & Axiome der Prädikatenlogik \\
    axioms of propositional calculus & Axiome der Aussagenlogik \\
    axioms of set theory & Axiome der Mengenlehre \\
     & \\
    basic keyword & grundlegendes Schlüsselwort \\
    basic language & grundlegende Sprache \\
    bibliographical references & Querverweis zu Literaturangaben \\
    biconditional & Bikonditional \\
    binary relation & binäre Relation \\
    block & Block \\
    Boolean algebra & Boolesche Algebra \\
    bound variable & gebundene Variable \\
    brace notation & Klammerschreibweise \\
    Burali-Forti paradox & Burali-Forti Paradoxon \\
     & \\
    Cantor's theorem & Satz von Cantor \\
    cardinal & Kardinalzahl \\
    cardinality & Kardinalität \\
    Cartesian product & Kartesisches Produkt \\
    category theory & Kategorientheorie \\
    citation & Zitat \\
    class & Klasse \\
    class abstraction & Klassenabstraktion \\
    class difference & Klassendifferenz \\
    class equality & Klassengleichheit \\
    class membership & Klassenzugehörigkeit \\
    class variable & Klassenvariable \\
    Clifford algebras & Clifford-Algebren \\
    closed form & geschlossene Form \\
    closure & Abschluss \\
    collection & Sammlung \\
    command keyword & Befehlsschlüsselwort \\
    command line interface & Befehlszeilenschnittstelle (CLI) \\
    command qualifier & Befehlszeilenparameter \\
    comment & Kommentar \\
    compact proof & kompakter Beweis \\
    completeness theorem of propositional calculus & Vollständigkeitssatz der Aussagenlogik \\
    complex number & komplexe Zahl \\
    composition & Komposition \\
    compound declaration & zusammengesetzte Deklaration \\
    compressed proof & komprimierter Beweis \\
    computer algebra system & Computeralgebrasystem \\
    concatenation & Verkettung \\
    conclusion & Schlussfolgerung \\
    condensed detachment & kondensierte Ablösung \\
    conjunction & Konjunktion \\
    connective & Junktor \\
    consistent theory & widerspruchsfreie Theorie \\
    constant & Konstante \\
    constant declaration & Konstantendeklaration \\
    constant-prefixed expression & konstant-gepräfixter Ausdruck \\
    constant-variable pair & Konstante-Variable-{\allowbreak}Paar \\
    constructive language & konstruktive Sprache \\
    constructivism & Konstruktivismus \\
    continuous integration & kontinuierliche Integration \\
    continuum hypothesis & Kontinuumshypothese \\
    Courier font & Courier Schriftart \\
    crank & Spinner \\
    creative definition & kreative Definintion \\
    cross product & Kreuzprodukt \\
     & \\
    database & Datenbasis \\
    decidable theory & entscheidbare Theorie \\
    decision procedure & Entscheidungsverfahren \\
    declaration & Deklaration \\
    deduction form & Deduktionsform \\
    deduction style & Deduktionsstil \\
    deduction theorem & Deduktionstheorem \\
    definiendum & Definiendum \\
    definiens & Definiens \\
    definition & Definition \\
    disjoint sets & disjunkte Mengen \\
    disjoint variables & disjunkte Variablen \\
    disjoint-variable restriction & disjunkte Variableneinschränkung \\
    disjunction & Disjunktion \\
    distinct variables & \hangindent=0.5cm unterschiedliche/verschiedene Variablen\vspace{3pt} \\
    domain & Definitionsbereich \\
    dummy variable & Dummy-Variable \\
     & \\
    effectively bound variable & effektiv gebundene Variable \\
    effectively not free & effektiv nicht frei \\
    element & Element \\
    empty domain & leerer Definitionsbereich \\
    empty set & leere Menge \\
    empty substitution & leere Substitution \\
    epsilon relation & Epsilon-Relation \\
    equality & Gleichheit \\
    error checking & Fehlerprüfung \\
    errors in proofs & Fehler in Beweisen \\
    essential hypothesis & essentielle Hypothese \\
    Euclidean geometry & euklidische Geometrie \\
    existential quantifier & Existenzquantor \\
    existential uniqueness quantifier & Eindeutigkeitsquantor \\
    expression & Ausdruck \\
    Extended Backus--Naur Form & erweiterte Backus--Naur-Form \\
    extended frame & erweiterter Frame \\
    extended language & erweiterte Sprache \\
     & \\
    family & Familie \\
    Fermat's Last Therorem & Großer Fermatscher Satz \\
    file inclusion & Dateieinbindung \\
    file name & Dateiname \\
    finitary proof & finitistischer Beweis \\
    finite induction & finite Induktion \\
    finite n-termed sequence & endliche n-gliedrige Folge \\
    first-order logic (FOL) & Logik erster Ordnung \\
    floating hypothesis & fließende Hypothese \\
    formal logic & formale Logik \\
    formal proof & formaler Beweis \\
    formal system & formales System \\
    formalism & Formalismus \\
    forms & Formen \\
    foundations of mathematics & Grundlagen der Mathematik \\
    founded relation & fundierte Relation \\
    four-color theorem & Vier-Farben-Satz \\
    frame & Frame \\
    free logic & freie Logik \\
    free variable & freie Variable \\
    function & Funktion \\
    function value & Funktionswert \\
     & \\
    gaps in proofs & Lücken in Beweisen \\
    global statement & globale Anweisung \\
    Gödel's incompleteness theorem &  Gödelscher Unvollständigkeitssatz \\
    grave accent & einfaches Anführungszeichen \\
    group theory & Gruppentheorie \\
     & \\
    hierarchy & Hierarchie \\
    higher-order logic (HOL) & Logik höherer Ordnung \\
    hypothesis & Hypothese \\
    hypothesis association & Hypothesenzuordnung \\
    hypothesis label & Hypothesenlabel \\
     & \\
    iff & genau dann, wenn \\
    image & Bild \\
    implication & Implikation \\
    implicit axiom & implizites Axiom \\
    implicit substitution & implizite Substitution \\
    inaccessible cardinal & unzugängliche Kardinalzahl \\
    included file & eingebundene Datei \\
    individual metavariable & individuelle Metavariable \\
    individual variable & individuelle Variable \\
    inference & Inferenz \\
    inference form & Inferenzform \\
    inference rule & Inferenzregel \\
    infinite set & unendliche Menge \\
    infinity & Unendlichkeit \\
    inflix connective & Infix-Konnektor \\
    informal proof & informeller Beweis \\
    integer & ganze Zahl \\
    intersection & Schnittmenge \\
    intuitionism & Intuitionismus \\
     & \\
    keyword & Schlüsselwort \\
     & \\
    label & Label \\
    label declaration & Label-Deklaration \\
    label mode & Label-Modus \\
    label reference & Label-Referenz \\
    label sequence & Label-Sequenz \\
    Lemmon-style proof & Lemmon-Stil Beweis \\
    limit ordinal & Grenzzahl \\
    local label & lokales Label \\
    local variable & lokale Variable \\
    logical AND & logisches UND \\
    logical equivalenz & logische Äquivalenz \\
    logical hypothesis & logische Hypothese \\
    logical OR & logisches ODER \\
     & \\
    machine learning & maschinelles Lernen \\
    Macintosh file name & Macintosh-Dateinamen \\
    mandatory \texttt{\$d} statement & obligatorische \texttt{\$d}-Anweisung \\
    \hangindent=0.5cm mandatory disjoint-{\allowbreak}variable restriction & \hangindent=0.5cm obligatorische disjunkte Variableneinschränkung \\
    \hangindent=0.5cm mandatory distinct-{\allowbreak}variable restriction & \hangindent=0.5cm obligatorische disjunkte Variableneinschränkung \\
    mandatory hypothesis & obligatorische Hypothese \\
    mandatory variable & obligatorische Variable \\
    mandatory variable-type hypothesis & \hangindent=0.5cm obligatorische Variablentyp-{\allowbreak}Hypothese\vspace{2pt} \\
    mapping & Zuordnung \\
    markup notation & Auszeichnungsnotation \\
    math mode & Mathe-Modus \\
    math symbol & mathematisches Symbol \\
    mathematical induction & vollständige Induktion \\
    member & Glied \\
    member & Mitglied \\
    metalanguage & Metasprache \\
    metalogic & Metalogik \\
    metalogical completeness & metalogische Vollständigkeit \\
    Metamath & Metamath \\
    Metamath Language EBNF & Metamath-Sprache EBNF \\
    Metamath Proof Explorer & Metamath Proof Explorer \\
    metamathematics & Metamathematik \\
    metatheorem & Metatheorem \\
    metavariable & Metavariable \\
    MIU-system & MIU-System \\
    modal logic & modale Logik \\
    model theory & Modelltheorie \\
    modus ponens & Modus ponens \\
    Monaco font & Monaco Schriftart \\
    monospaced font & nichtproportionale Schriftart \\
     & \\
    natural deduction & natürliche Deduktion \\
    natural number & natürliche Zahl \\
    negation & Negation \\
    nested block & verschachtelter Block \\
    nesting level & Verschachtelungstiefe \\
    non-trivial theory & nicht-triviale Theorie \\
    normal proof & normaler Beweis \\
    null set & leere Menge \\
    number theory & Zahlentheorie \\
     & \\
    object & Objekt \\
    object language & Objektsprache \\
    omega & Omega \\
    one-to-one function & injektive Funktion \\
    one-to-one, onto function & bijektive Funktion \\
    onto function & surjektive Funktion \\
    operating system command & Betriebssystem-Befehl \\
    operation & Operation \\
    operator precedence & Vorrangigkeit eines Operators \\
    optional disjoint-{\allowbreak}variable restriction & \hangindent=0.5cm optionale disjunkte Variableneinschränkung\vspace{3pt} \\
    optional hypothesis & optionale Hypothese \\
    optional variable & optionale Variable \\
    ordered pair & geordnetes Paar \\
    ordinal addition & ordinale Addition \\
    ordinal number & Ordinalzahl \\
    ordinal predicate & Ordinalprädikat \\
    outermost block & äußerster Block \\
     & \\
    pair & Paar \\
    parser & Parser \\
    Pasch's axiom & Axiom von Pasch \\
    Peano's postulates & Peano-Postulate \\
    Pierce's axiom & Pierces Axiom \\
    plain text & einfacher Text \\
    Poincaré conjecture & Poincaré-Vermutung \\
    Polish notation & polnische Notation \\
    pop & entfernen \\
    postfix connective & Postfix-Konnektor \\
    power class & Potenzklasse \\
    power set & Potenzmenge \\
    predicate calculus & Prädikatenlogik \\
    prefix connective & Präfix-Konnektor \\
    pre-statement & Prä-Aussage \\
    Principia Mathematica & Principia Mathematica \\
    printable character & druckbares Zeichen \\
    printer & Drucker \\
    proof & Beweis \\
    Proof Assistant & Beweis-Assistent \\
    proof length & Beweislänge \\
    proof scheme & Beweisschema \\
    proof step & Beweisschritt \\
    proof theory & Beweistheorie \\
    proper class & echte Klasse \\
    proper definition & zulässige Definition \\
    proper substitution & echte Substitution \\
    propositional calculus & Aussagenlogik \\
    provable assertion & beweisbare Behauptung \\
    provable statement & beweisbare Aussage \\
    pure mathematics & reine Mathematik \\
    push & schieben \\
     & \\
    qualifying expression & qualifizierender Ausdruck \\
    quantifier theory & Quantifizierungstheorie \\
    quantum logic & Quantenlogik \\
    quantum mechanics & Quantenmechanik \\
     & \\
    range & Wertebereich \\
    rational number & rationale Zahl \\
    real number & reelle Zahl \\
    recursion operator & Rekursionsoperator \\
    recursive definition & rekursive Definition \\
    redeclaration of symbols & Umdeklarierung von Symbolen \\
    reduct & Redukt \\
    reflection principle & Reflexionsprinzip \\
    relation & Relation \\
    restricted universal quantifier & eingeschränkter Allquantor \\
    restricted existential quantifier & eingeschränkter Existenzquantor \\
    restriction & Einschränkung \\
    reverse polish notation (RPN) & umgekehrte polnische Notation \\
    Robbins algebra & Robbins-Algebra \\
    Robinson's resolution principle & Robinsons Resolutionsprinzip \\
    RPN order & RPN-Reihenfolge \\
    RPN stack & RPN-Stapel \\
    rule & Regel \\
    rule of generalization & Regel der Verallgemeinerung \\
    Russell's paradox & Russells Paradoxon \\
     & \\
    Schröder--Bernstein theorem & Schröder--Bernstein-{\allowbreak}Theorem \\
    scope & Gültigkeitsbereich \\
    scoping statement & Gültigkeitsbereichsanweisung \\
    sentential logic & Satzlogik \\
    set & Menge \\
    set difference & Mengendifferenz \\
    set theory & Mengenlehre \\
    set union & Vereinigungsmenge \\
    simple declaration & einfache Deklaration \\
    simple infinite sequence & einfache unendliche Folge \\
    simple metatheorem & einfaches Metatheorem \\
    singleton & einelementige Menge \\
    software bug & Programmfehler, Bug \\
    source buffer & Quellpuffer \\
    source file & Quelldatei \\
    special characters & Sonderzeichen \\
    stack & Stapel \\
    Standard Deduction Theorem & Standard-Deduktionstheorem \\
    statement & Anweisung, Aussage \\
    stylized epsilon & stilisiertes Epsilon \\
    subclass & Unterklasse \\
    subset & Teilmenge \\
    substitution & Substitution, Ersetzung \\
    substitution map & Substitutionsabbildung \\
    substitution theorem & Substitutionstheorem \\
    successor & Nachfolger \\
    Syllogism & Syllogismus \\
    symbol & Symbol \\
    syntax rules & Syntax-Regeln \\
     & \\
    tautology & Tautologie \\
    temporary variable & temporäre Variable \\
    term & Term \\
    text editor & Texteditor \\
    theorem & Theorem \\
    theorem scheme & Theoremschema \\
    tilde & Tilde \\
    token & Token \\
    topology & Topologie \\
    transfinite cardinal & transfinite Kardinalzahl \\
    transfinite recoursion & transfinite Rekursion \\
    transitive class & transitive Klasse \\
    transitive set & transitive Menge \\
    tree-style proof & Baumdarstellung eines Beweises \\
    truth table & Wahrheitstabelle \\
    turnstile & Drehkreuz \\
    type & Typ \\
    typecode & Typcode \\
    typesetting comment & Schriftsatzanweisung \\
     & \\
    unification & Vereinheitlichung \\
    union & Vereinigung \\
    universal class & universelle Klasse \\
    universal quantifier & Allquantor \\
    universe of a formal system & Universum eines formalen Systems \\
    Unix file name & Unix-Dateiname \\
    unordered pair & ungeordnetes Paar \\
    unordered tripel & ungeordnetes Tripel \\
     & \\
    variable & Variable \\
    variable declaration & Variablendeklaration \\
    variable substitution & Variablensubstitution \\
    variable type & Variablentyp \\
    variable-type hypothesis & Variablentyp-Hypothese \\
    Venn diagram & Venn-Diagramm \\
     & \\
    Weak Deduction Theorem & Theorem der schwachen Deduktion \\
    weak logic & schwache Logik \\
    well-formed formula & wohlgeformte Formel (wff) \\
    well-ordering & Wohlordnung \\
    white space & Whitespace, Leerraum \\
    word processing & Textverarbeitung \\
     & \\
    Zermelo--Fraenkel set theory & Zermelo--Fraenkel-{\allowbreak}Mengenlehre \\
    ZFC set theory & ZFC-Mengenlehre \\    
\end{longtabu}

% \chapter{Disclaimer and Trademarks}
%
% Information in this document is subject to change without notice and does not
% represent a commitment on the part of Norman Megill.
% \vspace{2ex}
%
% \noindent Norman D. Megill makes no warranties, either express or implied,
% regarding the Metamath computer software package.
%
% \vspace{2ex}
%
% \noindent Any trademarks mentioned in this book are the property of
% their respective owners.  The name "`Metamath"' is a trademark of
% Norman Megill.
%

\cleardoublepage
\phantomsection  % fixes the link anchor
\addcontentsline{toc}{chapter}{\bibname}

\bibliography{metamath}
%\input{metamath.bbl}

\raggedright
\cleardoublepage
\phantomsection % fixes the link anchor
\addcontentsline{toc}{chapter}{\indexname}
%\printindex   ??
\input{metamath.ind}

\end{document}

